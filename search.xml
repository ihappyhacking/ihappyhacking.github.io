<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>百度地图 SDK 导入 Xcode 编译出错：symbol(s) not found for architecture arm64</title>
    <url>/2018/12/14/BaiduMap-SDK-Xcode-Compile-Error/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>上周接了一个外包的活，因为使用的是百度坐标，所以需要用到百度地图 SDK 里面的坐标转换功能，所以就导入了百度地图的 SDK。项目使用的是 Swift 语言开发，但是有 Objective-C 代码，所以是混编，恰好是因为混编，所以问题解决起来非常快。</p>
<span id="more"></span>

<h1 id="0x01-错误信息"><a href="#0x01-错误信息" class="headerlink" title="0x01 错误信息"></a>0x01 错误信息</h1><p>导入 SDK 之后，连接手机，编译运行发现出错了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Undefined symbols for architecture arm64:</span><br><span class="line">  &quot;vtable for __cxxabiv1::__class_type_info&quot;, referenced from:</span><br><span class="line">      typeinfo for _baidu_vi::CVArray&lt;_baidu_vi::_VPoint, _baidu_vi::_VPoint&gt; in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      typeinfo for _baidu_vi::CVArray&lt;_baidu_vi::CVArray&lt;_baidu_vi::_VPoint, _baidu_vi::_VPoint&gt;, _baidu_vi::CVArray&lt;_baidu_vi::_VPoint, _baidu_vi::_VPoint&gt;&amp;&gt; in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      typeinfo for _baidu_vi::CVArray&lt;_baidu_vi::CVArray&lt;_baidu_vi::_VPoint3, _baidu_vi::_VPoint3&gt;*, _baidu_vi::CVArray&lt;_baidu_vi::_VPoint3, _baidu_vi::_VPoint3&gt;*&amp;&gt; in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      typeinfo for _baidu_vi::CVArray&lt;unsigned int, unsigned int&amp;&gt; in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      typeinfo for _baidu_vi::CVArray&lt;_baidu_vi::tagMarkPoint, _baidu_vi::tagMarkPoint&amp;&gt; in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      typeinfo for _baidu_vi::CVArray&lt;float, float&amp;&gt; in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      typeinfo for _baidu_vi::CVArray&lt;_baidu_vi::CVArray&lt;_baidu_vi::_VPoint3, _baidu_vi::_VPoint3&gt;, _baidu_vi::CVArray&lt;_baidu_vi::_VPoint3, _baidu_vi::_VPoint3&gt;&amp;&gt; in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      ...</span><br><span class="line">  NOTE: a missing vtable usually means the first non-inline virtual member function has no definition.</span><br><span class="line">  &quot;___cxa_begin_catch&quot;, referenced from:</span><br><span class="line">      ___clang_call_terminate in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">  &quot;operator new[](unsigned long)&quot;, referenced from:</span><br><span class="line">      _BMKPolygonContainsPoint in BaiduMapAPI_Utils(BMKGeometry.o)</span><br><span class="line">  &quot;std::terminate()&quot;, referenced from:</span><br><span class="line">      ___clang_call_terminate in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">  &quot;operator delete[](void*)&quot;, referenced from:</span><br><span class="line">      _BMKPolygonContainsPoint in BaiduMapAPI_Utils(BMKGeometry.o)</span><br><span class="line">  &quot;operator delete(void*)&quot;, referenced from:</span><br><span class="line">      _baidu_vi::CVArray&lt;_baidu_vi::_VPoint, _baidu_vi::_VPoint&gt;::~CVArray() in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      _baidu_vi::CVArray&lt;_baidu_vi::CVArray&lt;_baidu_vi::_VPoint, _baidu_vi::_VPoint&gt;, _baidu_vi::CVArray&lt;_baidu_vi::_VPoint, _baidu_vi::_VPoint&gt;&amp;&gt;::~CVArray() in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      _baidu_vi::CVArray&lt;_baidu_vi::CVArray&lt;_baidu_vi::_VPoint3, _baidu_vi::_VPoint3&gt;*, _baidu_vi::CVArray&lt;_baidu_vi::_VPoint3, _baidu_vi::_VPoint3&gt;*&amp;&gt;::~CVArray() in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      _baidu_vi::CVArray&lt;unsigned int, unsigned int&amp;&gt;::~CVArray() in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      _baidu_vi::CVArray&lt;_baidu_vi::tagMarkPoint, _baidu_vi::tagMarkPoint&amp;&gt;::~CVArray() in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      _baidu_vi::CVArray&lt;float, float&amp;&gt;::~CVArray() in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      _baidu_vi::CVArray&lt;_baidu_vi::CVArray&lt;_baidu_vi::_VPoint3, _baidu_vi::_VPoint3&gt;, _baidu_vi::CVArray&lt;_baidu_vi::_VPoint3, _baidu_vi::_VPoint3&gt;&amp;&gt;::~CVArray() in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      ...</span><br><span class="line">  &quot;___gxx_personality_v0&quot;, referenced from:</span><br><span class="line">      l001 in BaiduMapAPI_Base(BMKBaseGeoUtil.o)</span><br><span class="line">      l004 in BaiduMapAPI_Base(BMKBaseGeoUtil.o)</span><br><span class="line">      l005 in BaiduMapAPI_Base(BMKBaseGeoUtil.o)</span><br><span class="line">      _baidu_vi::encode_geo_diff(_baidu_vi::CComplexPt*, _baidu_vi::CVString*) in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      _baidu_vi::decode_geo_diff(char const*, _baidu_vi::CComplexPt*) in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      _baidu_vi::line_clip(_baidu_vi::CVArray&lt;_baidu_vi::_VPoint, _baidu_vi::_VPoint&gt; const*, _baidu_vi::tagMBR const&amp;, _baidu_vi::CVArray&lt;_baidu_vi::_VPoint, _baidu_vi::_VPoint&gt;*) in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      _baidu_vi::line_clip(_baidu_vi::CComplexPt const*, _baidu_vi::tagMBR const&amp;, _baidu_vi::CComplexPt*) in BaiduMapAPI_Base(SpatialUtil.o)</span><br><span class="line">      ...</span><br><span class="line">ld: symbol(s) not found for architecture arm64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>

<p>看着这一大坨错误信息，心里一万只草泥马奔过。</p>
<p>按照正常顺序，copy <code>symbol(s) not found for architecture arm64</code> 去 Google 了一会儿，但是并没有找到解决办法。</p>
<h1 id="0x02-解决办法"><a href="#0x02-解决办法" class="headerlink" title="0x02 解决办法"></a>0x02 解决办法</h1><p>不过仔细一看：<code>&quot;vtable for __cxxabiv1::__class_type_info&quot;</code>，发现是跟 C++ 有关，遂将项目里面的 Objective-C 的一个 <code>.m</code> 文件后缀改成 <code>.mm</code>，编译运行就成功了。</p>
<p>就是这么简单。</p>
<p>原因嘛，大概是这样的，带有这种扩展名的源代码文件，除了可以包含 Objective-C 和 C 代码以外还可以包含 C++ 代码。不过这种文件后缀最好仅在你的 Objective-C 代码中确实需要使用 C++ 类或者特性的时候才用。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>百度地图</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Security</title>
    <url>/2016/11/03/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter10-Security/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac1068ea65.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 10 Security 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-Security"><a href="#0x01-Security" class="headerlink" title="0x01 Security"></a>0x01 Security</h1><p>使用 Security 框架，应用程序可以以编程方式访问 keychain，允许对用户数据进行受保护访问，不会不断地提示进行身份验证。</p>
<p>不幸的是，最终用户的便利性是以开发者为代价的，因为在 Cocoa 中有一些用来与 Keychain 交互的 API 很麻烦。</p>
<p>与 Keychain 的交互是通过查询来调解的，而不是直接操作。查询本身可能相当复杂，并且使用 C API 很麻烦。</p>
<p>查询是由以下组件组成的字典（dictionary）：</p>
<ul>
<li>要搜索的项目的类别，”Generic Password”，”Internet Password”，”Certificate”，”Key” 或 “Identity”。</li>
<li>查询返回类型，”Data”，”Attributes”，”Reference” 或 “Persistent Reference”。</li>
<li>匹配一个或多个属性（attribute）键值对。</li>
<li>一个或多个搜索键值对以进一步修改结果，例如匹配字符串是否区分大小写，只匹配信任的证书，或者限制只有一个结果或返回全部。</li>
</ul>
<p>字符串常量用于几乎所有的键和很多的值，这使得很多 <code>__bridge id</code> 转换 和文档查找。</p>
<h1 id="0x02-获取-Keychain-Items"><a href="#0x02-获取-Keychain-Items" class="headerlink" title="0x02 获取 Keychain Items"></a>0x02 获取 Keychain Items</h1><p>要获取 Keychain item，先构造一个查询，并传递给 <code>SecItemCopyMatching</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *service = <span class="string">@&quot;com.example.app&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *account = <span class="string">@&quot;username&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *query = @&#123;</span><br><span class="line">    (__bridge <span class="type">id</span>)kSecClass:(__bridge <span class="type">id</span>)kSecClassGenericPassword,</span><br><span class="line">    (__bridge <span class="type">id</span>)kSecAttrService : service,</span><br><span class="line">    (__bridge <span class="type">id</span>)kSecAttrAccount : key,</span><br><span class="line">    (__bridge <span class="type">id</span>)kSecMatchLimit : kSecMatchLimitOne,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFTypeRef</span> result;</span><br><span class="line">OSStatus status = SecItemCopyMatching((__bridge <span class="built_in">CFDictionaryRef</span>)query, &amp;result);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，查询指示 keychain 使用匹配的 username 查找服务 <code>com.example.app</code> 的所有通用密码项。<code>kSecAttrService</code> 定义了凭证的范围，而 <code>kSecAttrAccount</code> 作为一个唯一标识符。传递的搜索选项 <code>kSecMatchLimitOne</code> 确保只返回第一个匹配的结果（如果有的话）。</p>
<p>如果 <code>status</code> 等于 <code>errSecSuccess</code> （0），则 <code>result</code> 应该被匹配的凭证所填充。</p>
<h1 id="0x03-添加和更新-Keychain-Items"><a href="#0x03-添加和更新-Keychain-Items" class="headerlink" title="0x03 添加和更新 Keychain Items"></a>0x03 添加和更新 Keychain Items</h1><p>也许是 Keychain Services APIs 的主要症结，但是，为了写到 keychain，必须先读取它。有两个写方法：<code>SecItemAdd</code> 和 <code>SecItemUpdate</code>。用具有已匹配现有 item 的属性调用的 <code>SecItemAdd</code> 会返回状态码 <code>errSecDuplicateItem</code>。用没有匹配现有 item 的属性调用 <code>SecItemUpdate</code> 会返回状态码 <code>errSecItemNotFound</code>。因为缺少 <code>UPSERT</code> 类型命令，其中一个是每次都会被 resigned 以有条件地相应：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data = ...;</span><br><span class="line"><span class="keyword">if</span> (status == errSecSuccess) &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *updatedAttributes = @&#123;(__bridge <span class="type">id</span>)kSecValueData : data&#125;;</span><br><span class="line">    </span><br><span class="line">    SecItemUpdate((__bridge <span class="built_in">CFDictionaryRef</span>)query, (__bridge <span class="built_in">CFDictionaryRef</span>)updatedAttributes);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *attributes = [query mutableCopy];</span><br><span class="line">    attributes[(__bridge <span class="type">id</span>)kSecValueData] = data;</span><br><span class="line">    attributes[(__bridge <span class="type">id</span>)kSecAttrAccessible] = (__bridge <span class="type">id</span>)kSecAttrAccessibleAfterFirstUnlock;</span><br><span class="line">    </span><br><span class="line">    SecItemAdd((__bridge <span class="built_in">CFDictionaryRef</span>)attributes, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上一示例开始，使用 <code>kSecValueData</code> 属性 key 在 item 上设置任意数据。原始查询被复制并合并到 <code>SecItemAdd</code> 的另外的属性，而在更新的属性被传给 <code>SecItemUpdate</code>。</p>
<h1 id="0x04-加密消息语法"><a href="#0x04-加密消息语法" class="headerlink" title="0x04 加密消息语法"></a>0x04 加密消息语法</h1><p>加密消息语法（Cryptographic Message Syntax）是 IETF 用于 S&#x2F;MIME 消息的公钥加密和数字签名的标准。Apple 的加密消息语法服务在 Security 框架中提供了实现这些行业标准算法的 API。</p>
<p>如 <a href="http://meilbn.com/2016/11/02/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter7-Core-Services/">Core Services</a> 章节所述，MIME 是使 email，恩，有用的互联网标准。如果没有它，email 将不支持非 ASCII 字符或附件。S&#x2F;MIME 中的 S 指的是如何安全地发送和接收这些消息。</p>
<p>消息可以由任意数量的签名者或收件人签名或加密，或同时签名和加密。对一个消息签名是允许收件人验证其发件人。对一个消息加密是为了确保这个消息对除了收件人可以解密消息内容之外的任何人都保密。这两个操作是正交的（orthogonal），但是与密码相关。</p>
<p>编码一个消息</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data;</span><br><span class="line">SecCertificateRef certificateRef;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMSEncoderRef</span> encoder;</span><br><span class="line"><span class="built_in">CMSEncoderCreate</span>(&amp;encoder);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encrypt</span></span><br><span class="line"><span class="built_in">CMSEncoderUpdateContent</span>(encoder, [data bytes], [data length]);</span><br><span class="line"><span class="built_in">CMSEncoderAddRecipients</span>(encoder, certificateRef);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sign</span></span><br><span class="line">SecIdentityRef identityRef = <span class="literal">nil</span>;</span><br><span class="line">SecIdentityCreateWithCertificate(<span class="literal">nil</span>, certificateRef, &amp;identityRef);</span><br><span class="line"><span class="built_in">CMSEncoderUpdateContent</span>(encoder, [data bytes], [data length]);</span><br><span class="line"><span class="built_in">CMSEncoderAddSigners</span>(encoder, identityRef);</span><br><span class="line"><span class="built_in">CFRelease</span>(identityRef);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMSEncoderUpdateContent</span>(encoder, [data bytes], [data length]);</span><br><span class="line"><span class="built_in">CMSEncoderAddSignedAttributes</span>(encoder, kCMSAttrSmimeCapabilities);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFDataRef</span> encryptedDataRef;</span><br><span class="line"><span class="built_in">CMSEncoderCopyEncodedContent</span>(encoder, &amp;encryptedDataRef);</span><br><span class="line"><span class="built_in">NSData</span> *encryptedData = [<span class="built_in">NSData</span> dataWithData:(__bridge <span class="built_in">NSData</span> *)encryptedDataRef];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRelease</span>(encoder);</span><br></pre></td></tr></table></figure>

<p>解码一个消息</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CMSDecoderRef</span> decoder;</span><br><span class="line"><span class="built_in">CMSDecoderCreate</span>(&amp;decoder);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMSDecoderUpdateMessage</span>(decoder, [encryptedData bytes], [encryptedData length]);</span><br><span class="line"><span class="built_in">CMSDecoderFinalizeMessage</span>(decoder);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFDataRef</span> decryptedDataRef;</span><br><span class="line"><span class="built_in">CMSDecoderCopyContent</span>(decoder, &amp;decryptedDataRef);</span><br><span class="line"><span class="built_in">NSData</span> *decryptedData = [<span class="built_in">NSData</span> dataWithData:(__bridge <span class="built_in">NSData</span> *)decryptedDataRef];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRelease</span>(decryptedDataRef);</span><br><span class="line"><span class="built_in">CFRelease</span>(decoder);</span><br></pre></td></tr></table></figure>

<h1 id="0x05-Certificate-Key-和-Trust-Services"><a href="#0x05-Certificate-Key-和-Trust-Services" class="headerlink" title="0x05 Certificate, Key 和 Trust Services"></a>0x05 Certificate, Key 和 Trust Services</h1><p>数字证书用来验证其持有人和发送人的身份。</p>
<p>理解证书（certificates） 最好的方法是打开一个，看看里面有什么：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl x509 -<span class="keyword">in</span> certificate.pem -noout -text</span><br><span class="line"></span><br><span class="line">Certificate:</span><br><span class="line"></span><br><span class="line">    Data:</span><br><span class="line">        Version: 1 (0x0)</span><br><span class="line">        Serial Number: 4919 (0x1337)</span><br><span class="line">        Signature Algorithm: md5WithRSAEncryption</span><br><span class="line">        Issuer: C=ZA, ST=Western Cape, L=Cape Town, O=Thawte Consulting cc,</span><br><span class="line">                OU=Certification Services Division,</span><br><span class="line">                CN=Thawte Server CA/emailAddress=server-certs@thawte.com</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jun 2 18:00:00 2014 GMT</span><br><span class="line">            Not After : Jun 2 18:00:00 2015 GMT</span><br><span class="line">        Subject: C=US, ST=Oregon, L=Portland, O=Mattt Thompson,</span><br><span class="line">            OU=NSHipster, CN=nshipster.com/emailAddress=mattt@nshipster.com</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">            RSA Public Key: (1024 bit)</span><br><span class="line">                Modulus (1024 bit):</span><br><span class="line">                    cb:1c:00:aa:bb:89:a0:4c:26:<span class="built_in">cd</span>:8c:4b:0b:13:88:...</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">    Signature Algorithm: md5WithRSAEncryption</span><br><span class="line">        f5:5c:d6:a0:bf:39:95:fb:fa:ba:f5:f5:5a:d5:d9:f8:42:6b:...</span><br></pre></td></tr></table></figure>

<p>与其笨重的声誉相反，证书非常容易解析和理解 —— 总之即使对于没有熟练掌握密码学的人来说。</p>
<p>通过扫描纯文本输出，几个信息浮出表面：</p>
<ul>
<li>证书发行人（Certificate issuer）</li>
<li>有效期（Validity period）</li>
<li>证书持有者（Certificate holder）</li>
<li>所有者的公钥（Public key of the owner）</li>
<li>来自证书认证机构的数字签名（Digital signature from the certiﬁcation authority）</li>
</ul>
<p>每个证书都由其颁发证书进行验证，如此沿着证书链建立信任，一直到由认证机构颁发的根证书。</p>
<p>证书是用于保护互联网的密码基础结构的基础。具有证书的 iOS 和 OS X 开发者最常见的交互之一是验证来自一个 URL 请求的质询（challenge）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURLAuthenticationChallenge</span> *challenge = ...;</span><br><span class="line">SecTrustRef trust = challenge.protectionSpace.serverTrust;</span><br><span class="line">SecPolicyRef X509Policy = SecPolicyCreateBasicX509();</span><br><span class="line">SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)@[(__bridge <span class="type">id</span>)X509Policy]);</span><br><span class="line"></span><br><span class="line">SecTrustResultType result;</span><br><span class="line">assert(SecTrustEvaluate(trust, &amp;result) == errSecSuccess);</span><br></pre></td></tr></table></figure>

<p><code>SecTrustEvaluate</code> 通过验证证书的签名以及证书链中的证书签名一起使证书生效（validates），直到锚证书（anchor certiﬁcate）。为每个指定的策略创建一个证书链，从 leaf 证书开始，检查链中的每一个证书，直到遇到无效的证书，没有更多的证书，或者发现了非默认信任设置的证书。</p>
<p>在身份认证质询期间验证证书持有者的身份至关重要，因为它可以确保服务器是其声明的，并且可以用敏感信息进行信任。</p>
<h1 id="0x06-Security-Transform-Services"><a href="#0x06-Security-Transform-Services" class="headerlink" title="0x06 Security Transform Services"></a>0x06 Security Transform Services</h1><p>密码学的根本考虑是保护消息从被发送者加密到被接收者解密的时间的含义。当该消息是原始二进制数据时，有时需要采取额外的步骤将该数据编码成文本表示。</p>
<p>Base64 编码将二进制数据映射到 8 位 chunks，然后由 64 个可打印的 ASCII 字符表示。它对数据进行编码只需要 33% 的开销，不依赖于密文字符，并且具有相对直接的实现。它是一种 UTF-8 的二进制到文本编码。</p>
<p>Base64 用于任何从 HTTP 基本授权到 CSS 文档中嵌入的 <code>data-uri</code> 资源，一直观地比较固定大小的字节序列，例如 MD5 或 SHA-1 校验和。</p>
<p>Security 框架使用 <code>SecTransformExecute</code> 函数为 Base64（以及 Base32）编解码提供了内置的支持。</p>
<p>要对数据进行编码，使用 <code>kSecBase64Encoding</code> 选项创建一个 <code>SecTransformRef</code> 的实例，然后调用 <code>SecTransformExecute</code>：</p>
<p>Base64 编码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SecTransformRef transform = SecEncodeTransformCreate(kSecBase64Encoding, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">SecTransformSetAttribute(transform, kSecTransformInputAttributeName, (__bridge <span class="built_in">CFDataRef</span>)data, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *encodedData = (__bridge_transfer <span class="built_in">NSData</span> *)SecTransformExecute(transform, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRelease</span>(transform);</span><br></pre></td></tr></table></figure>

<p>逆向几乎是相同的，除了传 <code>kSecBase64Decoding</code> 到 <code>SecEncodeTransformCreate</code>：</p>
<p>Base64 解码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SecTransformRef transform = SecEncodeTransformCreate(kSecBase64Decoding, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSData</span> *decodedData = (__bridge_transfer <span class="built_in">NSData</span> *)SecTransformExecute(transform, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRelease</span>(transform);</span><br></pre></td></tr></table></figure>

<h1 id="0x07-Randomization-Services"><a href="#0x07-Randomization-Services" class="headerlink" title="0x07 Randomization Services"></a>0x07 Randomization Services</h1><p>密码学是基于不可预测的随机值。没有什么保证，它只是安全剧场（security theater）。</p>
<p><code>SecRandomCopyBytes</code> 从 <code>/dev/random</code> 读取，生成密码安全的随机字节。<code>/dev/random</code> 是在 Unix 上基于设备的环境噪声流熵（streams entropy）的一个特殊的文件。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> length = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableData</span> *mutableData = [<span class="built_in">NSMutableData</span> dataWithLength:length];</span><br><span class="line"></span><br><span class="line">OSStatus success = SecRandomCopyBytes(kSecRandomDefault, length, mutableData.mutableBytes);</span><br><span class="line"></span><br><span class="line">__Require_noErr(success, exit);</span><br></pre></td></tr></table></figure>

<h1 id="0x08-CommonCrypto"><a href="#0x08-CommonCrypto" class="headerlink" title="0x08 CommonCrypto"></a>0x08 CommonCrypto</h1><p>CommonCrypto 提供了方便的常见加密操作的 API，可以在 iOS 5.0+ 和 OS X 10.5+ 上使用。</p>
<h2 id="0x0801-摘要（Digests）"><a href="#0x0801-摘要（Digests）" class="headerlink" title="0x0801 摘要（Digests）"></a>0x0801 摘要（Digests）</h2><p>加密 hash 函数在信息安全中扮演了重要的角色。被称为校验和（checksums），指纹或摘要，加密 hash 函数的输出几乎不能被逆向以找到输入。</p>
<p>例如，”NSHipster” 的 SHA-1 校验和为 <code>7c33b28cb6fe3515548ee58812131de07afeef1b</code>，而对 “CFHipsterRef” 执行相同的 hash 函数生成 “342924012ebde06234135698b372e10c5b86c5b2”。</p>
<p>要在代码中计算校验和，请使用 <code>CC_SHA1</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data = ...;</span><br><span class="line"></span><br><span class="line">uint8_t output[CC_SHA1_DIGEST_LENGTH];</span><br><span class="line">cc_SHA1(data.bytes, data.length, output);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *digest = [<span class="built_in">NSData</span> dataWithBytes:output length:CC_SHA1_DIGEST_LENGTH];</span><br></pre></td></tr></table></figure>

<p>有很多加密 hash 函数，每个都有不同的安全特性和用例。开发者有责任评估自己产品的要求，以确定最合适的安全技术。</p>
<h1 id="0x09-HMAC"><a href="#0x09-HMAC" class="headerlink" title="0x09 HMAC"></a>0x09 HMAC</h1><p>密钥散列消息认证码（keyed-hash message authentication code, HMAC）使用加密 hash 函数和密钥来生成可用于同时验证消息的完整性和真实性的代码。HMAC 的强度取决于加密 hash 函数的强度以及密钥的大小。HMAC 通常由 web 服务使用以确保受保护的调用只有被验证的用户可以访问。</p>
<p>Common Crypto 提供了 <code>CCHmac</code> 用于生成 HMAC：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data, *key;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> length = CC_SHA1_DIGEST_LENGTH;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> output[length];</span><br><span class="line"></span><br><span class="line">CCHmac(kCCHmacAlgSHA1, key.bytes, key.length, data.bytes, data.length, output);</span><br></pre></td></tr></table></figure>

<h1 id="0x0A-Symmetric-Encryption"><a href="#0x0A-Symmetric-Encryption" class="headerlink" title="0x0A Symmetric Encryption"></a>0x0A Symmetric Encryption</h1><p>在作者撰写此文时，AES-128 &amp; PBKDF2 是安全对称加密的一种合理方法，即加密和解密消息。</p>
<p>高级加密标准（The Advanced Encryption Standard, AES）是由美国国家标准和技术研究所（NIST）建立的一种加密规范。PBKDF2 是一种使用 hash 函数的方法，通常用于生成一个 block 或 序列码（stream cypher）的 key，就像 AES。</p>
<p>Security 框架提供了构建 block 来进行对称加密，但是需要开发者自己实现特定的实现。</p>
<p>第一步是创建一个函数，该函数从一个加密的密码生成一个 PBKDF2 key。Salt 是用作对密码执行单向函数的附加输入的随机数据。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSData</span> *AES128PBKDF2KeyWithPassword(<span class="built_in">NSString</span> *password,</span><br><span class="line">                                           <span class="built_in">NSData</span> *salt,</span><br><span class="line">                                           <span class="built_in">NSError</span> * __autoreleasing *error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(password);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(salt);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *mutableDerivedKey = [<span class="built_in">NSMutableData</span> dataWithLength:kCCKeySizeAES128];</span><br><span class="line">    </span><br><span class="line">    CCCryptorStatus status =</span><br><span class="line">        CCKeyDerivationPBKDF(kCCPBKDF2,</span><br><span class="line">                             [password UTF8String],</span><br><span class="line">                             [password lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>],</span><br><span class="line">                             [salt bytes],</span><br><span class="line">                             [salt length],</span><br><span class="line">                             kCCPRFHmacAlgSHA256,</span><br><span class="line">                             <span class="number">1024</span>,</span><br><span class="line">                             [mutableDerivedKey mutableBytes],</span><br><span class="line">                             kCCKeySizeAES128);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *derivedKey = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (status != kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [[<span class="built_in">NSError</span> alloc] initWithDomain:<span class="literal">nil</span> code:status userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        derivedKey = [<span class="built_in">NSData</span> dataWithData:mutableDerivedKey];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> derivedKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，可以创建加密数据的函数，其将数据和密码加密，并将生成的 salt 和 初始值返回，以及执行操作的时候遇到的错误返回为输出参数：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSData</span> *AES128EncryotedDataWithData(<span class="built_in">NSData</span> *data,</span><br><span class="line">                                           <span class="built_in">NSString</span> *password,</span><br><span class="line">                                           <span class="built_in">NSData</span> * __autoreleasing *salt,</span><br><span class="line">                                           <span class="built_in">NSData</span> * __autoreleasing *initializationVector,</span><br><span class="line">                                           <span class="built_in">NSError</span> * __autoreleasing *error) &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(initializationVector);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(salt);</span><br><span class="line">    </span><br><span class="line">    uint8_t *saltBuffer = malloc(<span class="number">8</span>);</span><br><span class="line">    SecRandomCopyBytes(kSecRandomDefault, <span class="number">8</span>, saltBuffer);</span><br><span class="line">    *salt = [<span class="built_in">NSData</span> dataWithBytes:saltBuffer length:<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *key = AES128PBKDF2KeyWithPassword(password, *salt, error);</span><br><span class="line">    </span><br><span class="line">    uint8_t *initializationVectorBuffer = malloc(kCCBlockSizeAES128);</span><br><span class="line">    SecRandomCopyBytes(kSecRandomDefault, kCCBlockSizeAES128, initializationVectorBuffer);</span><br><span class="line">    *initializationVector = [<span class="built_in">NSData</span> dataWithBytes:initializationVector length:kCCBlockSizeAES128];</span><br><span class="line">    </span><br><span class="line">    size_t size = [data length] + kCCBlockSizeAES128;</span><br><span class="line">    <span class="type">void</span> *buffer = malloc(size);</span><br><span class="line">    </span><br><span class="line">    size_t numberOfBytesEncrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus status =</span><br><span class="line">        CCCrypt(kCCEncrypt,</span><br><span class="line">                kCCAlgorithmAES128,</span><br><span class="line">                kCCOptionPKCS7Padding,</span><br><span class="line">                [key bytes],</span><br><span class="line">                [key length],</span><br><span class="line">                [*initializationVector bytes],</span><br><span class="line">                [data bytes],</span><br><span class="line">                [data length],</span><br><span class="line">                buffer,</span><br><span class="line">                size,</span><br><span class="line">                &amp;numberOfBytesEncrypted);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *encryptedData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (status != kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [[<span class="built_in">NSError</span> alloc] initWithDomain:<span class="literal">nil</span> code:status userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       encryptedData = [[<span class="built_in">NSData</span> alloc] initWithBytes:buffer length:numberOfBytesEncrypted];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> encryptedData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，为了加密数据，逆向执行相同的过程，这次传递数据和密码以及从加密函数生成的 salt 和初始化向量：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSData</span> *AES128DecryptedDataWithData(<span class="built_in">NSData</span> *data,</span><br><span class="line">                                           <span class="built_in">NSString</span> *password,</span><br><span class="line">                                           <span class="built_in">NSData</span> *salt,</span><br><span class="line">                                           <span class="built_in">NSData</span> *initializationVector,</span><br><span class="line">                                           <span class="built_in">NSError</span> * __autoreleasing *error) &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *key = AES128PBKDF2KeyWithPassword(password, salt, error);</span><br><span class="line">    </span><br><span class="line">    size_t size = [data length] + kCCBlockSizeAES128;</span><br><span class="line">    <span class="type">void</span> *buffer = malloc(size);</span><br><span class="line">    </span><br><span class="line">    size_t numberOfBytesDecrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus status =</span><br><span class="line">        CCCrypt(kCCCDecrypt,</span><br><span class="line">        kCCAlgorithmAES128,</span><br><span class="line">        kCCOptionPKCS7Padding,</span><br><span class="line">        [key bytes],</span><br><span class="line">        [key length],</span><br><span class="line">        [initializationVector bytes],</span><br><span class="line">        [data bytes],</span><br><span class="line">        [data length],</span><br><span class="line">        buffer,</span><br><span class="line">        size,</span><br><span class="line">        &amp;numberOfBytesDecrypted);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *encryptedData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (status != kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [[<span class="built_in">NSError</span> alloc] initWithDomain:<span class="literal">nil</span> code:status userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        encryptedData = [[<span class="built_in">NSData</span> alloc] initWithBytes:buffer length:numberOfBytesDecrypted];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> encryptedData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Security</tag>
        <tag>Keychain</tag>
      </tags>
  </entry>
  <entry>
    <title>System Configuration</title>
    <url>/2016/11/04/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter11-System-Configuration/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac115a9f86.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 11 System Configuration 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-Sysem-Configuration"><a href="#0x01-Sysem-Configuration" class="headerlink" title="0x01 Sysem Configuration"></a>0x01 Sysem Configuration</h1><p>系统配置（Sysem Configuration）包含用于确定硬件配置和网络状态的 C API。</p>
<p>大多数开发者对框架的曝光是通过 Apple 的示例代码，简称 “Reachability”。旨在演示使用系统配置调用来确定互联网连接，如今却成为成千上万的应用程序的一部分。因此，表明 Reachability 是其自身成功的一个受害者。而不是记录系统配置 API，它无意地使它们废弃。</p>
<p>不幸的后果是，大多数开发者对 reachability 是什么，以及如果使用它一知半解。因此，很多那些在其源码中有 <code>Reachability.m</code> 的应用程序可能实际上比根本没有做任何事情的用户体验更糟。</p>
<h1 id="0x02-Reachability"><a href="#0x02-Reachability" class="headerlink" title="0x02 Reachability"></a>0x02 Reachability</h1><p>“我连接到互联网了吗？” 是一个难以回答的问题。</p>
<p>从用户的角度来看，应该很容易，对吧？只需要在 Safari 中输入 <code>apple.com</code>，看看是否有东西加载出来。</p>
<h2 id="0x0201-Determining-Network-Reachability-Synchronously"><a href="#0x0201-Determining-Network-Reachability-Synchronously" class="headerlink" title="0x0201 Determining Network Reachability Synchronously"></a>0x0201 Determining Network Reachability Synchronously</h2><p>与任何网络一样，建立 reachability 不应同步进行。然而，为了建立到更复杂的同步使用，看起来像是这样：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> SystemConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SCNetworkReachabilityRef</span> networkReachability = <span class="built_in">SCNetworkReachabilityCreateWithName</span>(kCFAllocatorDefault, [<span class="string">@&quot;www.apple.com&quot;</span> UTF8String]);</span><br><span class="line"><span class="built_in">SCNetworkReachabilityFlags</span> flags = <span class="built_in">SCNetworkReachabilityGetFlags</span>(networkReachability, &amp;flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use flags to determine reachability</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRelease</span>(networkReachability);</span><br></pre></td></tr></table></figure>

<p><code>SCNetworkReachability</code> 是负责确定网络可达性（Reachability）的数据类型。它可以通过传递主机名（host name）（如上面示例）或一个 <code>sockaddr</code> 地址来创建：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">BOOL</span> ignoreAdHocWiFi = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> sockaddr_in ipAddress;</span><br><span class="line">bzero(&amp;ipAddress, <span class="keyword">sizeof</span>(ipAddress));</span><br><span class="line">ipAddress.sin_len = <span class="keyword">sizeof</span>(ipAddress);</span><br><span class="line">ipAddress.sin_family = AF_INET;</span><br><span class="line">ipAddress.addr.s_addr = htonl(ignoreAdHocWiFi ? INADDR_ANY : IN_LINKLOCALNETNUM);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SCNetworkReachabilityRef</span> networkReachability =</span><br><span class="line">    <span class="built_in">SCNetworkReachabilityCreateWithAddress</span>(kCFAllocatorDefault,</span><br><span class="line">    (<span class="keyword">struct</span> sockaddr *)ipAddress);</span><br></pre></td></tr></table></figure>

<p><code>SCNetworkReachabilityFlags</code> 是一个同步调用，用于确定可用网络接口的可达性。因为有很多不同的因素影响可达性，所以这个函数返回值不是一个简单的 <code>YES</code> &#x2F; <code>NO</code>，而是一个特征位掩码（bitmask of characteristics）：</p>
<p style="text-align: center;">Reachability Flag Values</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Reachable</td>
<td align="left">使用当前的网络配置可以访问指定的节点名称或者地址。</td>
</tr>
<tr>
<td align="left">Transient Connection</td>
<td align="left">可以通过一个瞬态连接（如 PPP）访问指定的节点名称或地址。</td>
</tr>
<tr>
<td align="left">Connection Required</td>
<td align="left">使用当前的网络配置可以访问指定的节点名称或者地址，但必须先建立连接。</td>
</tr>
<tr>
<td align="left">Connection On Traffic</td>
<td align="left">使用当前的网络配置可以访问指定的节点名称或者地址，但必须先建立连接。任何针对指定名称或地址的传输都将启动连接。</td>
</tr>
<tr>
<td align="left">Connection On Demand</td>
<td align="left">使用当前的网络配置可以访问指定的节点名称或者地址，但必须先建立连接。</td>
</tr>
<tr>
<td align="left">Intervention Required</td>
<td align="left">使用当前的网络配置可以访问指定的节点名称或者地址，但必须先建立连接。另外，将需要某种形式的用户干预来建立此连接，例如提供密码，认证 token 等。</td>
</tr>
<tr>
<td align="left">Is Local Address</td>
<td align="left">指定的节点名称或地址是与当前系统上的网络接口相关联的。</td>
</tr>
<tr>
<td align="left">Is Direct</td>
<td align="left">网络传输到指定的节点名称或地址将不会通过网关（gateway），而是直接路由（routed）到系统的一个接口上。</td>
</tr>
</tbody></table>
<p>尽管网络接口的复杂性非常是有趣的，但它们只是对 app 开发者的学术练习（academic exercise），就像它们的用户，真的喜欢 <code>YES</code> 或 <code>NO</code> 答案。</p>
<p>下面是如何归纳一个复杂的真理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">BOOL</span> isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BOOL</span> needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BOOL</span> canConnectionAutomatically =</span><br><span class="line">    (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand) != <span class="number">0</span>) ||</span><br><span class="line">    ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">BOOL</span> canConnectWithoutUserInteraction =</span><br><span class="line">    (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BOOL</span> isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction));</span><br></pre></td></tr></table></figure>

<p>再进一步，reachability flags 也可以用于确定正在使用哪个网络接口：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isNetworkReachable == <span class="literal">NO</span>) &#123;</span><br><span class="line">    <span class="comment">// Not Reachable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Reachable via WWAN</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Reachable via WiFi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主线程上调用 <code>SCNetworkReachabilityFlags</code> 发起一个 30 秒超时的 DNS 查找。这样不好，不要阻塞，同步调用 <code>SCNetworkReachabilityFlags</code>。</p>
<h2 id="0x0202-Determining-Network-Reachability-Asynchronously"><a href="#0x0202-Determining-Network-Reachability-Asynchronously" class="headerlink" title="0x0202 Determining Network Reachability Asynchronously"></a>0x0202 Determining Network Reachability Asynchronously</h2><p>幸运的是，System Configuration 框架提供了一组用于异步监控 reachability 变化的 API。</p>
<p>首先，定义一个静态回调函数，该函数需要网络 reachability reference，flags 以及要传递的任何附加 context。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> ReachabilityCallback(<span class="built_in">SCNetworkReachabilityRef</span> target,</span><br><span class="line">                                 <span class="built_in">SCNetworkConnectionFlags</span> flags,</span><br><span class="line">                                 <span class="type">void</span> *context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦声明了回调函数，它就可以被设置到 <code>SCNetworkReachabilityRef</code> 上，然后在 runloop 上调度：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SCNetworkReachabilityContext</span> context = &#123;<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SCNetworkReachabilitySetCallback</span>(networkReachability, ReachabilityCallback, &amp;context);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SCNetworkReachabilityScheduleWithRunLoop</span>(reachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>

<p>现在，每当设置的网络 reachability 发生变化，<code>ReachabilityCallback</code> 函数就会被调用。然后，可以通过发布到 <code>NSNotificationQueue</code>，或通过调用一个 block 传递到 <code>SCNetworkReachabilityContext</code> 参数中，将此信息传达给应用程序。</p>
<h1 id="0x03-Network-Configuration-Settings"><a href="#0x03-Network-Configuration-Settings" class="headerlink" title="0x03 Network Configuration Settings"></a>0x03 Network Configuration Settings</h1><p>原谅有人认为 System Configuration 是一个 one-trick pony。几乎每个对该框架的提及都是在引用网络 reachability，也就是它本身是一个以该死的 Reachability 例子为主导的话题。</p>
<p>更模糊的功能与查询系统的动态存储有关：<code>SCDynamicStore</code>。这些 API 仅在 OS X 上可用。</p>
<h2 id="0x0301-Query"><a href="#0x0301-Query" class="headerlink" title="0x0301 Query"></a>0x0301 Query</h2><p><code>SCDynamicStoreRef</code> 为当前系统配置提供了一个键-值接口，该接口由 <code>configd</code> 守护程序（daemon）管理。</p>
<p>可用使用 <code>SCDynamicStoreCopyKeyList</code> 获取可用的 key 列表：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SCDynamicStoreContext context = &#123; <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">SCDynamicStoreRef store = SCDynamicStoreCreate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">nil</span>, &amp;context);</span><br><span class="line"><span class="built_in">NSArray</span> *keys = (__bridge_transfer <span class="built_in">NSArray</span> *)SCDynamicStoreCopyKeyList(store, <span class="built_in">CFSTR</span>(<span class="string">&quot;.+&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>Setup:&#x2F; Network&#x2F;Service&#x2F;…IPv4,</li>
<li>Setup:&#x2F; Network&#x2F;Service&#x2F;…IPv6,</li>
<li>… 100+ Items …</li>
<li>State:&#x2F;Network&#x2F;Interface&#x2F;p2p0&#x2F;Link,</li>
<li>State:&#x2F;Network&#x2F;Interface&#x2F;lo0&#x2F;IPv6,</li>
<li>State:&#x2F;IOKit&#x2F;LowBatteryWarning,</li>
<li>State:&#x2F;Network&#x2F;MulticastDNS,</li>
<li>State:&#x2F;Network&#x2F;Global&#x2F;Proxies,</li>
<li>State:&#x2F;Network&#x2F;Interface&#x2F;bridge0&#x2F;Link</li>
</ul>
<p>注：完整的 key 列表可以查看 Apple 的 <a href="https://developer.apple.com/">System Configuration Programming Guide</a>。</p>
<p>有了 key 的列表，<code>SCDynamicStore</code> 的目的变得更清晰。IP 地址和网络接口更改时应用程序能够收到通知，甚至当设备电池过低时也能收到通知。</p>
<p>这里与用于监控网络可达性的语义相同。</p>
<p>例如，可以使用 <code>State:/Network/Interface</code> key 找到可用网络接口的列表：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SCDynamicStoreContext context = &#123; <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">SCDynamicStoreRef store = SCDynamicStoreCreate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">nil</span>, &amp;context);</span><br><span class="line"><span class="built_in">CFPropertyListRef</span> propertyList = SCDynamicStoreCopyValue(store, <span class="built_in">CFSTR</span>(<span class="string">&quot;State:/Network/Interface&quot;</span>));</span><br><span class="line"><span class="built_in">NSArray</span> *interfaces = (__bridge <span class="built_in">NSArray</span> *)<span class="built_in">CFDictionaryGetValue</span>(propertyList, <span class="built_in">CFSTR</span>(<span class="string">&quot;Interfaces&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>lo0</li>
<li>gif0</li>
<li>stf0</li>
<li>en0</li>
<li>en1</li>
<li>en2</li>
<li>bridge0</li>
<li>p2p0</li>
<li>utun0</li>
</ul>
<h2 id="0x0302-Monitoring"><a href="#0x0302-Monitoring" class="headerlink" title="0x0302 Monitoring"></a>0x0302 Monitoring</h2><p>动态存储的真正用处是能够监控更改，以便应用程序可以立即响应如 AirPort 被开启或本地 IP 地址发生变化等事情。</p>
<p>在某种程度上，这只是一个监控网络可达性的更广泛的规划（formulation）。创建一个动态存储，监听一个特定的网络服务实体 key，并且设置一个回调函数指针：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> Callback(SCDynamicStoreRef store, <span class="built_in">CFArrayRef</span> changedKeys, <span class="type">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (info) &#123;</span><br><span class="line">        ((<span class="type">void</span> (^)())info)(changedKeys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> callback = ^(<span class="built_in">NSArray</span> *changedKeys) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SCDynamicStoreContext context = &#123;<span class="number">0</span>, (__bridge <span class="type">void</span> *)callback, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">SCDynamicStoreRef store = SCDnamicSoreCreate(<span class="literal">NULL</span>, <span class="built_in">CFSTR</span>(<span class="string">&quot;IPv4AddressMonitor&quot;</span>), Callback, &amp;context);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *ipv4 =</span><br><span class="line">    (<span class="built_in">NSString</span> *)SCDynamicStoreKeyCreateNetworkServiceEntity(<span class="literal">NULL</span>,</span><br><span class="line">                                                            kSCDynamicStoreDomainState,</span><br><span class="line">                                                            kSCCompAnyRegex,</span><br><span class="line">                                                            kSCEntNetIPv4);</span><br><span class="line"></span><br><span class="line">SCDynamicStoreSetNotificationKeys(store, <span class="literal">NULL</span>, @[ipv4]);</span><br><span class="line">SCDynamicStoreSetDispatchQueue(store, dispatch_get_main_queue());</span><br></pre></td></tr></table></figure>

<p>语言是我们特有的意识的本质。这就是我们如何思考。这就是为什么我们完全可以思考。</p>
<p>我们依据名词来理解世界，用动词浏览它。形容词将将离散观察结果集中到感觉和判断中。我们通过前辈们的书面记录作为一个社会进步。最后，这将会是我们自己的文字，比我们更久。</p>
<p>我们能够交流完全是一个奇迹。这些想法可以心灵（mind）转移到另一个心灵，是超越信仰的 —— 但是很好理解，它几乎没有记录第二个想法。通过沟通，我们创造彼此之间的理解。我们唤起同情，并扩大我们的道德考虑边界给别人。我们的世界变得更大。</p>
<p>然而，当语言的距离太难以克服，沟通失败时，它变得难以同情。一种别样的感觉。无论是个人的还是国际的，沟通失败仍然是冲突的主要原因。</p>
<p>作为一项消除语言和文化距离的技术，有一个强有力的案例表明，Unicode 是为我们的物种创造的最重要的技术之一。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Reachability</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>International Components for Unicode</title>
    <url>/2016/11/05/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter12-International-Components-for-Unicode/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac1271af1a.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 12 International Components for Unicode 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-International-Components-for-Unicode"><a href="#0x01-International-Components-for-Unicode" class="headerlink" title="0x01 International Components for Unicode"></a>0x01 International Components for Unicode</h1><p>至少就 Apple 的 SDK 而言，Unicode 扮演的角色很难去夸大。本章将讨论在 Foundation 和 Core Foundation 中如何使用 Unicode 的一个方面，特别是 ICU 或 Unicode 的国际组件。</p>
<h1 id="0x02-Unicode"><a href="#0x02-Unicode" class="headerlink" title="0x02 Unicode"></a>0x02 Unicode</h1><p>Unicode 是国际计算的基石。这一切始于 1987 年，有三个人：来自 Xerox 的 Joe Becker 和来自 Apple 的 Lee Collins &amp; Mark Davis。</p>
<p>他们对 Unicode 的目标很简单，但是雄心勃勃：</p>
<ul>
<li>广泛，满足世界语言的需求。</li>
<li>统一，带有固定宽度的代码，用于有效访问。</li>
<li>唯一，每个 bit 序列都仅具有一个解释。</li>
</ul>
<p>自成立以来，Unicode 已经成功地创建了一个普遍采用的标准，超过 100,000 个字符表示为数十亿人使用的语言。</p>
<h1 id="0x03-ICU"><a href="#0x03-ICU" class="headerlink" title="0x03 ICU"></a>0x03 ICU</h1><p>ICU 或 Unicode 的国际组件（International Components for Unicode），是用于在软件中提供 Unicode 和全球化支持的行业标准。</p>
<p>它是 IBM 在 90 年代出创建的，自那以后一直保持着。</p>
<p>ICU4C，是 C&#x2F;C++ 库，以 libicucore 形式构成了 Apple 操作系统的支柱，是 Core Foundation 和 Foundation 广泛使用的私有化框架，但是不可公共使用。虽然可以提供 libicucore，但是比起简单使用基于它构建的 SDK API（例如 <code>NSLocale</code>，<code>NSCalendar</code> 和 <code>CFStringTransform</code>），没有什么实际优势。</p>
<p>因此，本章将研究 ICU，以便更好地理解这些高级 API 的工作原理，以及如何利用此信息来利用（exploit）未记录的 API 功能。</p>
<h1 id="0x04-CLDR"><a href="#0x04-CLDR" class="headerlink" title="0x04 CLDR"></a>0x04 CLDR</h1><p>CLDR 或 通用本地化数据仓库（Common Locale Data Repository），是使 ICU 如此引人注目的一项技术。包含超过 400 MB 的 JSON 数据，CLDR 包含了所有人类文化习俗的权威编码。</p>
<p>CLDR 的 <code>main</code> 目录包含了多个子目录 —— 每个可用语言环境一个目录（one for each available locale）。在每个语言环境目录中的是描述该语言环境的一个特殊方面的文件的集合：</p>
<h2 id="0x0401-Calendars"><a href="#0x0401-Calendars" class="headerlink" title="0x0401 Calendars"></a>0x0401 Calendars</h2><p>在 CLDR 中有 18 个不同的日历表示，从标准的 Gregorian，到古代，宗教和模糊系统的所有规矩（manners）。</p>
<ul>
<li>Calendar</li>
<li>Buddhist</li>
<li>Chinese</li>
<li>Coptic (a.k.a Alexandrian)</li>
<li>Dangi</li>
<li>Ethiopic</li>
<li>Ethiopic (Amete Alem)</li>
<li>Hebrew</li>
<li>Indian</li>
<li>Islamic</li>
<li>Islamic (Civil)</li>
<li>Islamic (Saudi Arabia)</li>
<li>Islamic (Tabular)</li>
<li>Islamic (Um al-Qura)</li>
<li>Minguo (Republic of China)</li>
<li>Japanses</li>
<li>Persian</li>
</ul>
<p>每个日历在每个语言环境的单独文件中表示。每个文件几百行长，包含月份，星期在各种级别的缩写，以及日期和时间间隔的格式化规则。</p>
<p><code>NSCalendar</code> 和 <code>NSDateFormatter</code> 使用此信息来将日期解析和格式化成与语言环境相对于的格式：</p>
<h2 id="0x0402-Characters"><a href="#0x0402-Characters" class="headerlink" title="0x0402 Characters"></a>0x0402 Characters</h2><p>对于语言环境中说的每种语言，提供了字符的清单，以及省略的排序索引（collation indexes）和格式化规则。</p>
<p>字符清单（Character inventories）可能被 <code>NSLinguisticTagger</code> 用作评估字符串的 <code>NSLinguisticTagSchemeLanguage</code> 的一个低通（low pass）。具有超出语言拼写库（orthographic inventory）的字符的字符串不太可能匹配。相反，示例字符（exemplar characters）的相对频率可能在两个可能的候选之间是有用的。</p>
<p>可以使用 <code>NSLocaleExemplarCharacterSet</code> key 检索 <code>NSLocale</code> 的示例字符。</p>
<p><code>UILocalizedIndexedCollation</code> 使用排序索引来对当前语言环境适当地分段语言记录。美式英语使用拉丁字母（Latin alphabet）来整理信息，如名字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[A B C D E F G H I J K L M N O P Q R S T U V W X Y Z]</span><br></pre></td></tr></table></figure>

<p>然而，瑞典语扩展了拉丁字母表，还有一些额外的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[A Á B C Č D Đ E É F G H I J K L M N Ŋ O P Q R S Š T Ŧ U V W X Y Z Ž Ø Æ Å Ä Ö]</span><br></pre></td></tr></table></figure>

<p>省略规则指定应如何格式化截断的文本，这取决于截断的位置是起始，中间还是结尾，以及在该点是否有字边界（word boundary）：</p>
<p style="text-align: center;">Example Ellipsis Rules</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Initial</td>
<td></td>
</tr>
<tr>
<td align="left">Medial</td>
<td></td>
</tr>
<tr>
<td align="left">Final</td>
<td></td>
</tr>
<tr>
<td align="left">Word Initial</td>
<td></td>
</tr>
<tr>
<td align="left">Word Medial</td>
<td></td>
</tr>
<tr>
<td align="left">Word Final</td>
<td></td>
</tr>
</tbody></table>
<h2 id="0x0403-Currencies"><a href="#0x0403-Currencies" class="headerlink" title="0x0403 Currencies"></a>0x0403 Currencies</h2><p>忘记音乐或世界语； <em>金钱</em> 才是真正通用的语言。每种货币根据其 ISO 4217 代码（USD，EUR，GBP等）被列出，并包括其地区特定符号（$, €, £等）。大多数这些信息在不同的语言环境中是一致的，但是有内置的冗余来容纳诸如特定计数显示名称。</p>
<p><code>NSLocale</code> 使用此信息来查找指定的语言环境中的货币代码和符号。反之，当使用 <code>NSNumberFormatterCurrencyStyle</code> 表示数字时，此信息被传递到 <code>NSNumberFormatter</code> 中。</p>
<h2 id="0x0404-Date-Fields"><a href="#0x0404-Date-Fields" class="headerlink" title="0x0404 Date Fields"></a>0x0404 Date Fields</h2><p>除了日历的详细信息，每个语言环境都有如何执行相对日期格式化的规则，例如“现在”，“昨天”或“上周”。惯用指示词（Idiomatic deictics）在不同的语言中有所不同。比如，德语中有 “vorgestern” 来描述 “前天”。除了惯用指示词，还有常规的 &#x2F; 刻板的过去和未来指示词，如“1周前”和“4秒”。</p>
<p>当 <code>doesRelativeDateFormatting</code> 被设置为 <code>YES</code> 是，此信息由 <code>NSDateFormatter</code> 使用。</p>
<h2 id="0x0405-Delimiters"><a href="#0x0405-Delimiters" class="headerlink" title="0x0405 Delimiters"></a>0x0405 Delimiters</h2><p>每种语言都具有其自己的如何界定引用：</p>
<p style="text-align: center;">Quotation Delimiters</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">English</td>
<td align="left">“I can eat glass, it doesn’t harm me.”</td>
</tr>
<tr>
<td align="left">German</td>
<td align="left">„Ich kann Glas essen, das tut mir nicht weh.“</td>
</tr>
</tbody></table>
<p>CLDR 指定语言环境中使用的每种语言的主要（””）和可选备用（’’）的引号的开始和结束分隔符。</p>
<p>可以使用 <code>NSLocale</code> 的 <code>NSLocaleQuotationBeginDelimiterKey</code> &#x2F; <code>NSLocaleAlternateQuotationBeginDelimiterKey</code> 和 <code>NSLocaleQuotationEndDelimiterKey</code> &#x2F; <code>NSLocaleAlternateQuotationEndDelimiterKey</code> key 来获取引号分隔符。</p>
<h2 id="0x0406-Languages"><a href="#0x0406-Languages" class="headerlink" title="0x0406 Languages"></a>0x0406 Languages</h2><p><code>languages</code> 文件指定了其各自的语言环境来参考该语言。</p>
<p>例如，<code>NSLocale</code> 在传递 <code>NSLocaleLanguageCode</code> key 时使用此信息作为 <code>displayNameForKey</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLocale</span> *frLocale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@&quot;fr_FR&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;fr: %@&quot;</span>, [frLocale displayNameForKey:<span class="built_in">NSLocaleLanguageCode</span> value:<span class="string">@&quot;fr&quot;</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;en: %@&quot;</span>, [frLocale displayNameForKey:<span class="built_in">NSLocaleLanguageCode</span> valie:<span class="string">@&quot;en&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p style="text-align: center;">NSLocaleLanguageCode</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">fr</td>
<td align="left">français</td>
</tr>
<tr>
<td align="left">en</td>
<td align="left">anglais</td>
</tr>
</tbody></table>
<h2 id="0x0407-Layout"><a href="#0x0407-Layout" class="headerlink" title="0x0407 Layout"></a>0x0407 Layout</h2><p>一个语言环境的布局详情非常简单：它们为每种语言指定字符顺序（从左到右或从右到左）和行顺序（从上到下或从下到上）。</p>
<h2 id="0x0408-List-Patterns"><a href="#0x0408-List-Patterns" class="headerlink" title="0x0408 List Patterns"></a>0x0408 List Patterns</h2><p>列表是宾格的心脏，主体和灵魂。在语言环境和语言之间用于一个列表中的 item 如何分隔不同的规则，和所有这些差异都在 CLDR 中列举。</p>
<p>从一个实现的角度来看，有趣的是看这些规则是如何被编码的。而不是指定，例如，划分字符和连词（conjunction），这至少对英语更有意义，CLDR 指定作为开始，中间和结束模式的格式。相反，语言可能具有唯一的模式集合以适应不同的上下文（context），就像 units（单元）。</p>
<p>在实践中，在语言环境之间最主要的区别是是否使用标准或全宽度逗号，是否使用 item 间（inter-item）间距，以及是否在最后使用一个连词。</p>
<p>Foundation 目前不使用这个信息，因为它没有提供任何类似 <code>NSArrayFormatter</code> 的东西。</p>
<h2 id="0x0409-Locale-Display-Names"><a href="#0x0409-Locale-Display-Names" class="headerlink" title="0x0409 Locale Display Names"></a>0x0409 Locale Display Names</h2><p>像 <code>languages</code>，<code>localeDisplayNames</code> 文件定义了指定语言环境显示不同类型的信息的名称。排序，计数系统，文字系统，日历和排序方案都在这里表示。</p>
<p>在提供语言环境首选项时，此信息始终在 iOS 和 OS X 中使用。然而，并不是 CLDR 提供的所有信息都可以通过系统 API 来访问。</p>
<h2 id="0x040A-Measurement-System-Names"><a href="#0x040A-Measurement-System-Names" class="headerlink" title="0x040A Measurement System Names"></a>0x040A Measurement System Names</h2><p><code>measurementSystemNames</code> 文件指定每个测量系统的本地化名称（公制，US &amp; UK）。</p>
<p>要确定一个给定的 <code>NSLocale</code> 是否使用度量标准系统，在 <code>- objectForKey:</code> 中使用 key <code>NSLocaleUsesMetricSystem</code>。</p>
<h2 id="0x040B-Numbers"><a href="#0x040B-Numbers" class="headerlink" title="0x040B Numbers"></a>0x040B Numbers</h2><p>这个文件编码了关于一个语言环境的数据格式所有的规则：计数系统，十进制格式，科学，百分比和货币样式；首选的符号为小数（.），组（,），列表（;），加号（+），减号（-），百分号（%），千分号（‰），指数（E），无限（∞）和非数字（NaN）；和数据范围的模式。</p>
<p>正如你可能期望的，这是源自 <code>NSNumberFormatter</code> 其格式化规则。</p>
<h2 id="0x040C-POSIX"><a href="#0x040C-POSIX" class="headerlink" title="0x040C POSIX"></a>0x040C POSIX</h2><p>这一个实际上相当有趣 —— 不是大多数说英语的计算机用户可能已经思考过。</p>
<p>当 Unix 命令提示确认时，它们期望一个是或否的回答。在英语中，这非常清楚：<code>yes</code> &#x2F; <code>y</code> 或 <code>no</code> &#x2F; <code>n</code>。</p>
<p>但是其他语言呢？</p>
<p>在意大利语中，选项为 <code>sì</code> &#x2F; <code>si</code> &#x2F; <code>s</code> 或 <code>no</code> &#x2F; <code>n</code>。在俄语中，<code>да</code> &#x2F; <code>д</code> 或 <code>нет</code> &#x2F; <code>н</code> 是可接受的回答。</p>
<p>CLDR 对每种语言都有规则，让使用 ICU 的软件开发者简单地在所有的语言环境中制作出令人愉快的软件。</p>
<p>由于大多数 iOS 和 OS X app 喜欢 CLI 更喜欢 GUI，这不是预知的事情，因此，SDK 不支持。</p>
<h2 id="0x040D-Scripts"><a href="#0x040D-Scripts" class="headerlink" title="0x040D Scripts"></a>0x040D Scripts</h2><p>在脚本（scripts）和语言之间是一个多对多的关系。有些语言有多个脚本，大多数脚本被多种语言使用。</p>
<p>ISO 15924 是用于标识脚本的标准。每个脚本都被分配了 4 个字符和 1 个数字标识符。</p>
<p>例如，<code>Latn</code> 是 Latin 脚本，<code>Hira</code> 是日文平假名， &#96;Brai&#96;&#96; 是盲文。</p>
<p>对于 CLDR 中的每个语言环境，每个脚本都有其本地化的名称。<code>NSLocale</code> 可以通过 <code>NSLocaleScriptCode</code> key 来访问它。</p>
<h2 id="0x040E-Territories"><a href="#0x040E-Territories" class="headerlink" title="0x040E Territories"></a>0x040E Territories</h2><p>一个语言环境的 <code>territories</code> 文件包括根据其联合国（United Nations）地理编码 ID（geoscheme ID）的国家（根据 ISO 3166）和世界地区的名称。</p>
<p>这里的难点是争议的名称和地理如何政治上正确。一些国家可能不被其他国家承认，或可能有作为武装冲突一部分的领土吞并。</p>
<p>由于程序员在大多数地缘政治斗争中没有纠缠（don’t have a dog），采用 ICU 标准是一个聪明的选择，这最大限度地减少了无意中引发国际危机的可能性。</p>
<p><code>NSLocale</code> 只公开了国家&#x2F;地区代码，使用 <code>NSLocaleCountryCode</code> key。然而，AddressBook 和其他框架利用 CLDR 的数据库来在整个操作系统中本地化国家&#x2F;地区的名称。</p>
<h2 id="0x040F-Time-Zone-Names"><a href="#0x040F-Time-Zone-Names" class="headerlink" title="0x040F Time Zone Names"></a>0x040F Time Zone Names</h2><p>任何足够了解时区的程序员都知道他们不需要编写任何有关时区的代码。</p>
<p>时区范围从 UTC-12 到 UTC+14 —— 跨度总共 26 小时，这有点奇怪，一天只有 24 小时。有些时区遵守夏令时，而其他没有。在那些遵守中的有一些在有些情况下会使用 ±30 或 45 分钟的局部偏移。</p>
<p>某些跨越大范围经度的国家，像美国和加拿大，被分成许多不同的时区。其他国家，像中国，被标准化为只有一个单一的时区为一个同等跨度，这意味着，在早上8点当太阳升起在西部城市喀什，差不多是北京的中午。</p>
<p>这么多的边缘情况，就好像每个时区都是规则的例外。因此，每个 <code>timezones</code> 文件都有几千行长，并且包括世界上数百个地区，国家和城市列表。</p>
<p>幸运的是，<code>NSTimeZone</code> 都帮我们做好了。</p>
<h2 id="0x0410-Transform-Names"><a href="#0x0410-Transform-Names" class="headerlink" title="0x0410 Transform Names"></a>0x0410 Transform Names</h2><p>转换（Transform）是一个脚本或写作标准中的文本转换到另一个的过程。对于主脚本，有转换的标准化约定。<br>BNG 用于转换俄语（西里尔体，Cyrillic）为拉丁语。Jamo 用于转换韩文（Korean Hangul）为拉丁语，以及 Pinyin 用于转换中文为拉丁语。还有转换 CJK（Chinese, Japanese, Korean）字符在半宽和全宽之间表示。还有联合国地名专家组（United Nations Group of Experts on Geographical Names，UNGEGN）转换，使地名或音名的音译标准化。</p>
<p>这些标准变换中的每一个都有一个与它们相关联的名称，这些名称随着语言环境而变化。CLDR 具有每种语言的对应关系。</p>
<h2 id="0x0411-Units"><a href="#0x0411-Units" class="headerlink" title="0x0411 Units"></a>0x0411 Units</h2><p>有许多不同类型的单元（Units）， 每个都表示了一个特定的物理量（physical quantity），像加速度（acceleration），角度（angle），面积（area），持续时间（duration），长度（length），质量（mass），功率（power），压力（pressure），速度（speed），温度（temperature）或体积（volume）。由于一个语言环境对于如何格式化和表示这些单元可能有稍微不同的标准，因此 CLDR 为每个单元提供了模式（patterns）。</p>
<p>随着 HeathKit 的引入，Foundation 增加了能量（energy），质量和长度的格式化程序（formatters）。MapKit 也提供了用于以英里和公里为单位的格式化程序。每个都利用 CLDR 中的单元格式化规则。</p>
<h2 id="0x0412-Variants"><a href="#0x0412-Variants" class="headerlink" title="0x0412 Variants"></a>0x0412 Variants</h2><p>一个语言环境的 <code>variants</code> （变体）记录是 BCP 47 子标签的本地化名称的抓包，其包括方言，正文和音译方案。这些是对一个特定语言的可接受标准的重要替代，例如，对于汉语和日语的韦氏拼音（Wade-Giles）和赫本古罗马化策略（Hepburn romanization strategies），分别被拼音和 Rōmaji 淘汰。</p>
<h2 id="0x0413-Supplemental"><a href="#0x0413-Supplemental" class="headerlink" title="0x0413 Supplemental"></a>0x0413 Supplemental</h2><p>最后，在一个完全独立的顶层目录中存在一个补充的记录目录。在这里和在单个语言环境记录中几乎一样多，但是由于还没有通过 Objective-C API 提供的那么多，我们就浏览一下：</p>
<ul>
<li>日历数据：日历系统时代的时代（Epochs of calendar system eras），以及日历是否基于月球或太阳周期。</li>
<li>日历偏好数据：每个语言环境中支持的有序日历列表，按偏好排序。</li>
<li>字符回退（Character Fallbacks）：没有很好支持的字符的更简单的替代方案，比如 <code>(C)</code> 为 “©” 或 <code>1/2</code> 为 “½”，以及韩语和希伯来语（Hebrew）中的货币符号，连字和复合字符。</li>
<li>代码映射（Code Mappings）：顶级域代码映射。</li>
<li>货币数据：不同国家使用的货币历史，包括使用的开始和结束日期。</li>
<li>日期（Day Periods）：将一天的时间分割的各种方案，从简单的：“上午（a.m.） &#x2F; 下午（p.m.）”到极度精确的：“凌晨（wee hours）&#x2F; 清晨（early morning）&#x2F; 早上（morning）&#x2F; 上午晚些时候（late morning）&#x2F; 中午（noon）&#x2F; 正午（mid day）&#x2F; 下午（afternoon）&#x2F; 傍晚（evening）&#x2F; 午夜（late evening） &#x2F; 深夜（night）”。</li>
<li>性别的复数规则：如何性别复数的规则。</li>
<li>语言数据：语言列表及其各自的脚本和范围。</li>
<li>语言匹配：关于如何交换类似语言的规则，如哈萨克语和俄语。</li>
<li>可能的子标签：给定一个 BCP 47 语言标签，最有可能关联的子标签。</li>
<li>测量数据：哪些国家使用公制与英制单位，或 A4 与美国信纸的纸张尺寸。</li>
<li>Metazones：为地区建立一个区域层次结构的记录。</li>
<li>计数系统：替代编号系统的清单与规则，如阿拉伯语，罗马与，全角 CJK 和拼写的英语数字。</li>
<li>序数（Ordinals）：每种语言的规则或序数（即第一，第二，第三等）。</li>
<li>父语言环境：建立从地区到父语言环境的一个有向图关系。</li>
<li>多个规则：每种语言使用 6 中不同的 Unicode 计数规则中的任何一种：零，一，二，少，多和其他。</li>
<li>邮政编码数据：描述国家&#x2F;地区的邮政编码规则的正则表达式。</li>
<li>主区域：主时区。</li>
<li>参考文献：用于确定所有这些不同规则的来源的参考书目。</li>
<li>电话代码数据：每个国家的国际拨号代码。</li>
<li>区域控制：确定领土地理区域的空间关系。</li>
<li>区域信息：区域统计数据的细目，包括人口，GDP，识字率和语言人口。</li>
<li>时间数据：tl;dr <code>-&#123;&quot;_allowed&quot; : &quot;H h&quot;, &quot;_preferred&quot; : &quot;h&quot;&#125;</code>。</li>
<li>星期数据：对于每个语言环境，一周中的最少天数，以及哪一天是一周的开始。</li>
<li>Windows Zones：时区信息的旧映射。</li>
</ul>
<h1 id="0x05-Transform"><a href="#0x05-Transform" class="headerlink" title="0x05 Transform"></a>0x05 Transform</h1><p>最初设计为将一个脚本中的文本转换为另一个脚本，ICU 变换已经发展成为使用 Unicode 文本的有力工具，具有大小写和宽度转换，复合字符序列标准化和删除重音和变音符号。</p>
<p>ICU 变换通过 Core Foundation 中的 <code>CFStringTransform</code> 函数被暴露出来。大约十几个字符串常量定义为常用操作，比如 <code>CFStringTransformToLatin</code>，方便地将文本音译成其相应的拉丁字母表示。不幸运的是，这些常量具有不透明值，这最终掩盖了 <code>CFStringTransform</code> 将接受任何有效的 ICU 变换的事实。</p>
<p>一个 ICU 变换由一个或多个分号分隔的映射组成。每个映射在左手边和右手边值之间是单项或双向的。</p>
<p>例如，一个在一个版权符号和其 ASCII 表示之间的双向变换可以被表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(C) &lt;&gt; ©;</span><br></pre></td></tr></table></figure>

<p><code>&#125;</code> 操作数将规则约束到特定的上下文，比如在此单向映射中，只删除小写字母后的连字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[:lowercase letter:] &#125; &#x27;-&#x27; &gt; &#x27;&#x27;;</span><br></pre></td></tr></table></figure>

<p>每个映射按顺序评估，因此应从最具体的规则开始列出，并以最一般的规则结束。</p>
<p>ICU 为常见和有用的操作提供了许多内置的音译，可以与其他规则组合以完成几乎任何自动文本转换任务。</p>
<h2 id="0x0501-Text-Processing"><a href="#0x0501-Text-Processing" class="headerlink" title="0x0501 Text Processing"></a>0x0501 Text Processing</h2><p>ICU 有用于基本的文本处理任务的音译比如改变大小写或规范化：</p>
<p style="text-align: center;">Text Processing Transforms</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Any-Null</td>
<td align="left">没有影响；留下不没有变的输入文本。</td>
</tr>
<tr>
<td align="left">Any-Remove</td>
<td align="left">删除输入的字符。当与限制要删除的字符的过滤器组合时，这就有用了。</td>
</tr>
<tr>
<td align="left">Any-Lower, Any-Upper, Any-Title</td>
<td align="left">转换为指定的大小写。更多信息请看大小写映射（Case Mappings）。</td>
</tr>
<tr>
<td align="left">Any-NFD, Any-NFC, Any-NFKD, Any-NFKC, Any-FCD, Any-FCC</td>
<td align="left">转换为指定的标准化形式。</td>
</tr>
<tr>
<td align="left">Any-Publishing</td>
<td align="left">在真实标点符号与打字机标点符号之间转换。</td>
</tr>
</tbody></table>
<h2 id="0x0502-Accent-and-Diacritic-Stripping"><a href="#0x0502-Accent-and-Diacritic-Stripping" class="headerlink" title="0x0502 Accent and Diacritic Stripping"></a>0x0502 Accent and Diacritic Stripping</h2><p>最常见的规范化任务之一是去除重音和变音符号。ICU 变换提供了一个灵活的解决方案：</p>
<p style="text-align: center;">Normalization Transforms</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">“NFD; [:Mn:] Remove; NFC”</td>
<td align="left">移除所有重音和变音符号。</td>
</tr>
</tbody></table>
<p>使用这个变换，”Énġlišh långuãge läcks iñterêsţing diaçrïtičş” 变成 “English language lacks interesting diacritics”。</p>
<p><code>kCFStringTransformStripCombiningMarks</code> 常量也可以用于相同的效果。</p>
<h2 id="0x0503-Unicode-Symbol-Naming"><a href="#0x0503-Unicode-Symbol-Naming" class="headerlink" title="0x0503 Unicode Symbol Naming"></a>0x0503 Unicode Symbol Naming</h2><p>Unicode 标准中的每一个代码点都有一个官方名词，其可以使用 ICU 变换来检索：</p>
<p style="text-align: center;">Unicode Symbol Naming Transforms</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Any-Name</td>
<td align="left">将每个字符替换为其 Unicode 名称。</td>
</tr>
</tbody></table>
<p>将此变换应用与 “å” 产生 “{上面带有环的小写拉丁字母 A}”。</p>
<h2 id="0x0504-Script-Transliteration"><a href="#0x0504-Script-Transliteration" class="headerlink" title="0x0504 Script Transliteration"></a>0x0504 Script Transliteration</h2><p>不吹牛逼地说，脚本音译是 ICU 的一大杀手功能。对于世界上数十亿只能读懂或写作他们母语的人来说，将任何文本转换成可发音的能力本身就是对人类的变革。</p>
<p>ICU 包括以下几种音译：</p>
<ul>
<li>Latin &lt;-&gt; Arabic, Armenian, Bopomofo, Cyrillic, Georgian, Greek, Han, Hangul, Hebrew, Hiragana, Indic (Devanagari, Gujarati, Gurmukhi, Kannada, Malayalam, Oriya, Tamil, &amp; Telegu), Jamo, Katakana, Syriac, Thaana, &amp; Thai.</li>
<li>Indic &lt;-&gt; Indic</li>
<li>Hiragana &lt;-&gt; Katakana</li>
<li>Simpliﬁed Chinese (Hans) &lt;-&gt; Traditional Chinese (Hant)</li>
</ul>
<p>源和目标说明符可以是脚本标识符（”Latin” &#x2F; “Latn”），Unicode 语言标识符（<code>fr</code>，<code>en_US</code>，<code>zh_Hant</code>）或特殊标签（<code>Any</code>，<code>Hex</code>）。</p>
<p>以下是一些以有用的方式链接在一起的音译示例：</p>
<p style="text-align: center;">Script Transliteration Transforms</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Any-Latin</td>
<td align="left">将文本音译成拉丁脚本，也许是为了让英语为母语的人能够读。</td>
</tr>
<tr>
<td align="left">Any-Latin; Latin-Hangul</td>
<td align="left">将文本音译成韩文，使用拉丁文作为中间表示。</td>
</tr>
<tr>
<td align="left">Any-Latin; Latin-ASCII; [:^ASCII:] Remove</td>
<td align="left">将文本从中间拉丁表示音译为 ASCII，过程中去掉了任何非 ASCII 字符。</td>
</tr>
<tr>
<td align="left">[:Latin:]; NFKD; Lower; Latin-Katakana; Fillwidth-Halfwidth</td>
<td align="left">对于所有拉丁字符，根据标准化表单兼容性进行标准化分解，改为小写，音译为片假名，然后转换为半宽表示。</td>
</tr>
<tr>
<td align="left">Any-Latin; Latin-NumericPinyin</td>
<td align="left">将文本音译为拉丁，将拼音重音改为其等效的数字。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Unicode</tag>
        <tag>ICU</tag>
      </tags>
  </entry>
  <entry>
    <title>Dictionary Services</title>
    <url>/2016/11/05/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter13-Dictionary-Services/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac137334ba.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 13 Dictionary Services 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-Dictionary-Services"><a href="#0x01-Dictionary-Services" class="headerlink" title="0x01 Dictionary Services"></a>0x01 Dictionary Services</h1><p>虽然互联网广泛篡夺了它们“参考”状态，字典和词汇表在幕后扮演了重要的角色。大量的功能依赖于这些信息，从拼写检查，语法检查和自动更正到自动摘要和语义分析。</p>
<p>所以，作为参考，这里看看计算机在 Unix，OS X 和 iOS 中通过单词给世界带来意义的方式和方法。</p>
<h1 id="0x02-Unix"><a href="#0x02-Unix" class="headerlink" title="0x02 Unix"></a>0x02 Unix</h1><p>几乎所有的 Unix 发行版都包括一些小的新行分隔（newline-delimited）的单词列表。在 OS X 上，这些可以在 <code>/usr/share/dict</code> 中找到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /usr/share/dict</span><br><span class="line">    README</span><br><span class="line">    connectives</span><br><span class="line">    propernames</span><br><span class="line">    web2</span><br><span class="line">    web2a</span><br><span class="line">    words@ -&gt; web2</span><br></pre></td></tr></table></figure>

<p>符号链接 <code>words</code> 是 <code>web2</code> 单词列表，虽然不是很详尽，但仍然是一个相当大的语料库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> /usr/share/dict/words</span><br><span class="line">    235886   235886 2493109</span><br></pre></td></tr></table></figure>

<p>这里用 <code>head</code> 浏览一些有趣的东西。很少如此显而易见的是这些单词都是以 “a” 开头的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">head</span> /usr/share/dict/words</span><br><span class="line">    A</span><br><span class="line">    a</span><br><span class="line">    aa</span><br><span class="line">    aal</span><br><span class="line">    aalii</span><br><span class="line">    aam</span><br><span class="line">    Aani</span><br><span class="line">    aardvark</span><br><span class="line">    aardwolf</span><br><span class="line">    Aaron</span><br></pre></td></tr></table></figure>

<p>这些巨大的，系统提供的文本文件使其很容易 <code>grep</code> 纵横字谜的线索（crossword puzzle clues），生成记忆密码短语和种子数据库，但从用户角度来看，<code>/usr/share/dict</code> 的单语主义（monolingualism）和缺乏相关的意义使它相当无用。</p>
<p>OS X 使用自己的系统字典构建。</p>
<h1 id="0x03-OS-X"><a href="#0x03-OS-X" class="headerlink" title="0x03 OS X"></a>0x03 OS X</h1><p><code>/usr/share/dict</code> 的 OS X 模拟可以在 <code>/Library/Dictionaries</code> 中找到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /Library/Dictionaries/</span><br><span class="line">    Apple Dictionary.dictionary/</span><br><span class="line">    Diccionario General de la Lengua Española Vox.dictionary/</span><br><span class="line">    Duden Dictionary Data Set I.dictionary/</span><br><span class="line">    Dutch.dictionary/</span><br><span class="line">    Italian.dictionary/</span><br><span class="line">    Korean - English.dictionary/</span><br><span class="line">    Korean.dictionary/</span><br><span class="line">    Multidictionnaire de la langue francaise.dictionary/</span><br><span class="line">    New Oxford American Dictionary.dictionary/</span><br><span class="line">    Oxford American Writer<span class="string">&#x27;s Thesaurus.dictionary/</span></span><br><span class="line"><span class="string">    Oxford Dictionary of English.dictionary/</span></span><br><span class="line"><span class="string">    Oxford Thesaurus of English.dictionary/</span></span><br><span class="line"><span class="string">    Sanseido Super Daijirin.dictionary/</span></span><br><span class="line"><span class="string">    Sanseido The WISDOM English-Japanese Japanese-English Dictionary.dictionary/</span></span><br><span class="line"><span class="string">    Simplified Chinese - English.dictionary/</span></span><br><span class="line"><span class="string">    The Standard Dictionary of Contemporary Chinese.dictionary/</span></span><br></pre></td></tr></table></figure>

<p>OS X 附有中文，英文，法语，荷兰语，意大利语，日语和韩语的词典，以及一个英语同义词词典和一个 Apple 特定术语的特殊词典。</p>
<p>更深入一些，仔细看看 <code>.dictionary</code> bundles，看看他们真正是什么：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> <span class="string">&quot;/Library/Dictionaries/New Oxford American Dictionary.dictionary/Contents&quot;</span></span><br><span class="line"></span><br><span class="line">    Body.data</span><br><span class="line">    DefaultStyle.css</span><br><span class="line">    EntryID.data</span><br><span class="line">    EntryID.index</span><br><span class="line">    Images/</span><br><span class="line">    Info.plist</span><br><span class="line">    KeyText.data</span><br><span class="line">    KeyText.index</span><br><span class="line">    Resources/</span><br><span class="line">    _CodeSignature/</span><br><span class="line">    version.plist</span><br></pre></td></tr></table></figure>

<p>一个文件系统解剖展示了一些有趣的实现细节。特别是新牛津美国词典的情况下，内容包括：</p>
<ul>
<li><code>KeyText.data</code>，<code>KeyText.index</code> &amp; <code>Content.data</code> 二进制编码</li>
<li>CSS 样式条目</li>
<li>1207 张图片，从 A-Frame 到 Zither</li>
<li>在 US English Diacritical Pronunciation 和 International Phonetic Alphabet (IPA) 之间切换的偏好</li>
<li>词典内容的清单 &amp; 签名</li>
</ul>
<p>通常，专有二进制编码意味着可以合理处理数据的结束，但是幸运的是，Core Service 提供了读取这个信息的 API。</p>
<h2 id="0x0301-Gettting-Definition-of-Word"><a href="#0x0301-Gettting-Definition-of-Word" class="headerlink" title="0x0301 Gettting Definition of Word"></a>0x0301 Gettting Definition of Word</h2><p>在 OS X 上要获取一个字的定义，可以使用 <code>DCSCopyTextDefinition</code> 函数，在 Core Services 框架中能够找到：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;CoreServices/CoreServices.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *word = <span class="string">@&quot;apple&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *definition =</span><br><span class="line">    (__bridge_transfer <span class="built_in">NSString</span> *)DCSCopyTextDefinition(<span class="literal">NULL</span>,</span><br><span class="line">                                                        (__bridge <span class="built_in">CFStringRef</span>)word,</span><br><span class="line">                                                        <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, [word length]));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, difinition);</span><br></pre></td></tr></table></figure>

<p>等等，那些伟大的词典都去哪里了？</p>
<p>好吧，他们都消失在第一个 <code>NULL</code> 参数中。这里可以期望提供一个 <code>DCSCopyTextDefinition</code> 类型，如函数定义所规定的。然而，没有一个公共的函数去构造或复制这样一个类型，使 <code>NULL</code> 成为唯一一个可用的选项。文档也是清晰明确：</p>
<p><em>“This parameter is reserved for future use, so pass NULL. Dictionary Services searches in all active dictionaries.”</em></p>
<p>“Dictionary Services searches in all active dictionaries”，这样？听起来像是一个漏洞！</p>
<h2 id="0x0302-Setting-Active-Dictionaries"><a href="#0x0302-Setting-Active-Dictionaries" class="headerlink" title="0x0302 Setting Active Dictionaries"></a>0x0302 Setting Active Dictionaries</h2><p>利用漏洞来解决 Apple 平台限制的实践。一个完全易错的获取方法，比如说，同义词词典结果而不是在标准词典中第一个可用的定义：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dictionaryPreferences = [[userDefaults persistentDomainForName:<span class="string">@&quot;com.apple.DictionaryServices&quot;</span>] mutableCopy];</span><br><span class="line"><span class="built_in">NSArray</span> *activeDictionaries = [dictionaryPreferences objectForKey:<span class="string">@&quot;DCSActiveDictionaries&quot;</span>];</span><br><span class="line">dictionaryPreferences[<span class="string">@&quot;DCSActiveDictionaries&quot;</span>] = @[<span class="string">@&quot;/Library/Dictionaries/Oxford American Writer&#x27;s Thesaurus.dictionary&quot;</span>];</span><br><span class="line">[userDefaults setPersistentDomain:dictionaryPreferences forName:<span class="string">@&quot;com.apple.DictionaryServices&quot;</span>];</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *word = <span class="string">@&quot;apple&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *definition = (__bridge_transfer <span class="built_in">NSString</span> *)DCSCopyTextDefinition(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFStringRef</span>)word, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, [word length]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, definition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictionaryPreferences[<span class="string">@&quot;DCSActiveDictionaries&quot;</span>] = activeDictionaries;</span><br><span class="line">[userDefaults setPersistentDomain:dictionaryPreferences forName:<span class="string">@&quot;com.apple.DictionaryServices&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>“但是这是 OS X，一个平台，其宿命不能被来自 Cupertino 的贫乏的沙盒尝试（meager sandboxing attempts）所包含！”，你哭了。“难道没有一个更文明的方法吗？，比如说，私有 API？”</p>
<p>是的，有。</p>
<h2 id="0x0303-Private-APIs"><a href="#0x0303-Private-APIs" class="headerlink" title="0x0303 Private APIs"></a>0x0303 Private APIs</h2><p>没有公开地暴露，但是仍然可用通过 Core Services 使用一些函数，更接近我们渴望的词典服务（dictionary services）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">CFArrayRef</span> DCSCopyAvailableDictionaries();</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSDictionaryGetName(DCSDictionaryRef dictionary);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSDictionaryGetShortName(DCSDictionaryRef dictionary);</span><br><span class="line"><span class="keyword">extern</span> DCSDictionaryRef DCSDictionaryCreate(<span class="built_in">CFURLRef</span> url);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSDictionaryGetName(DCSDictionaryRef dictionary);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFArrayRef</span> DCSDopyRecordsForSearchString(DCSDictionaryRef dictionary, <span class="built_in">CFStringRef</span> string, <span class="type">void</span> * <span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFDictionaryRef</span> DCSCopyDefinitionMarkup(DCSDictionaryRef dictionary, <span class="built_in">CFStringRef</span> record);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSRecordCopyData(<span class="built_in">CFTypeRef</span> record);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSRecordCopyDataURL(<span class="built_in">CFTypeRef</span> record);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSRecordGetAnchor(<span class="built_in">CFTypeRef</span> record);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSRecordGetAssociatedObj(<span class="built_in">CFTypeRef</span> record);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSRecordGetHeadword(<span class="built_in">CFTypeRef</span> record);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSRecordGetRawHeadword(<span class="built_in">CFTypeRef</span> record);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSRecordGetString(<span class="built_in">CFTypeRef</span> record);</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFStringRef</span> DCSRecordGetTitle(<span class="built_in">CFTypeRef</span> record);</span><br><span class="line"><span class="keyword">extern</span> DCSDictionaryRef DCSRecordGetSubDictionary(<span class="built_in">CFTypeRef</span> record);</span><br></pre></td></tr></table></figure>

<p>这些函数并没有在文档中记录，所以来看看它们是怎么使用的。</p>
<h2 id="0x0304-Getting-Available-Dictionaries"><a href="#0x0304-Getting-Available-Dictionaries" class="headerlink" title="0x0304 Getting Available Dictionaries"></a>0x0304 Getting Available Dictionaries</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMapTable</span> *availableDictionariesKeyedByName =</span><br><span class="line">    [<span class="built_in">NSMapTable</span> mapTableWithKeyOptions:<span class="built_in">NSPointerFunctionsCopyIn</span></span><br><span class="line">                          valueOptions:<span class="built_in">NSPointerFunctionsObjectPointerPersonality</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">id</span> dictionary <span class="keyword">in</span> (__bridge_transfer <span class="built_in">NSArray</span> *)DCSCopyAvailableDictionaries()) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name = (__bridge <span class="built_in">NSString</span> *)DCSDictionaryGetName((__bridge DCSDictionaryRef)dictionary);</span><br><span class="line">    [availableDictionariesKeyedByName setObject:dictionary forKey:name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x0305-Getting-Definition-for-Word"><a href="#0x0305-Getting-Definition-for-Word" class="headerlink" title="0x0305 Getting Definition for Word"></a>0x0305 Getting Definition for Word</h2><p>有了可用的 <code>DCSDictionaryRef</code> 类型示例，我们现在可以看到所有的大惊小怪都是关于 <code>DCSCopyTextDefinition</code> 的第一个参数：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *word = <span class="string">@&quot;apple&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *name <span class="keyword">in</span> availableDictionariesKeyedByName) &#123;</span><br><span class="line">    <span class="type">id</span> dictionary = [availableDictionariesKeyedByName objectForKey:name];</span><br><span class="line">    <span class="built_in">CFRange</span> termRange = DCSGetTermRangeInString((__bridge DCSDictionaryRef)dictionary,</span><br><span class="line">                                                (__bridge <span class="built_in">CFStringRef</span>)word, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (termRange.location == kCFNotFound) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *term = [word substringWithRange:<span class="built_in">NSMakeRange</span>(termRange.location, termRange.length)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *records =</span><br><span class="line">        (__bridge_transfer <span class="built_in">NSArray</span> *)DCSCopyRecordsForSearchString(</span><br><span class="line">            (__bridge DCSDictionaryRef)dictionary,</span><br><span class="line">            (__bridge <span class="built_in">CFStringRef</span>)term, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (records) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span> record <span class="keyword">in</span> records) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *headword = (__bridge <span class="built_in">NSString</span> *)DCSRecordGetHeadword((__bridge <span class="built_in">CFTypeRef</span>)record);</span><br><span class="line">            <span class="keyword">if</span> (headword) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *definition =</span><br><span class="line">                    (__bridge_transfer <span class="built_in">NSString</span> *)DCSCopyTextDefinition(</span><br><span class="line">                        (__bridge DCSDictionaryRef)dictionary,</span><br><span class="line">                        (__bridge <span class="built_in">CFStringRef</span>)headword,</span><br><span class="line">                        <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, [headword length]));</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;%@: %@&quot;</span>, name, definition);</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">NSString</span> *HTML =</span><br><span class="line">                    (__bridge_transfer <span class="built_in">NSString</span> *)DCSRecordCopyData(</span><br><span class="line">                        (__bridge DSCDictionaryRef)dictionary,</span><br><span class="line">                        (__bridge <span class="built_in">CFStringRef</span>)headword,</span><br><span class="line">                        <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, [headword length]));</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;%@: %@&quot;</span>, name, definition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个实验最让人惊讶的是能够访问原始 HTML 的条目，结合字典捆绑的 CSS，产生 Dictionary.app 中显示的内容。</p>
<h1 id="0x04-iOS"><a href="#0x04-iOS" class="headerlink" title="0x04 iOS"></a>0x04 iOS</h1><p>iOS 开发显然是一个更按部就班的事情，所以试图对平台进行逆向工程将只是一个学术练习。幸运的是，通过晦涩的 UIKit 类 <code>UIReferenceLibraryViewController</code> 有大量的功能可用（从 iOS 5 开始）。</p>
<p><code>UIReferenceLibraryViewController</code> 跟 <code>MFMessageComposeViewController</code> 很像，其提供了一个围绕系统功能的最小可配置视图控制器，旨在以模态方式呈现。</p>
<p>只需用所需的 term 初始化并模态化显示：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIReferenceLibraryViewController</span> *referenceLibraryViewController =</span><br><span class="line">    [[<span class="built_in">UIReferenceLibraryViewController</span> alloc] initWithTerm:<span class="string">@&quot;apple&quot;</span>];</span><br><span class="line">[viewController presentViewController:referenceLibraryViewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p>这跟在 <code>UITextView</code> 中在高亮文字上点击 “Define” <code>UIMenuItem</code> 的行为很像。</p>
<p><code>UIReferenceLibraryViewController</code> 也提供了类方法 <code>dictionaryHasDefinitionForTerm:</code>。开发者最好在模态一个字典视图控制器前调用这个方法，不然可能啥都没有显示出来。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIReferenceLibraryViewController</span> dictionaryHasDefinitionForTerm:<span class="string">@&quot;apple&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>从 Unix 的词列表到在 OS X 上（也可能是 iOS）演化的 <code>.dictionary</code> 包，文字是对应用程序编程以及数学常量和 “Sosumi” 警告声至关重要的。思考如何将上述 API 集成到自己的 app 中，或创建一种你以前没有想过的 app。Apple 的平台中有大量的语言学技术，所以要利用它们。</p>
<p>虽然我们都来自不同的背景，有不同的观点，塑造我们的经历；虽然我们做带有各自动机，信念，偏见和意见的事情，使我们彼此分离，但是有一件事情我们是一样的：</p>
<p>我们都必须使用 Xcode。不管怎样，好的或坏的。</p>
<p>至于常见的原因，老实说，事情可以更绝望。也有几个明显的例外，Xcode 好像随着每个版本在变得更好。</p>
<p>但是当然，Xcode 并不真的只是一个应用程序。在 GUI 下是一个应用程序和命令行工具的联合。</p>
<h1 id="0x05-Xcode-Tools"><a href="#0x05-Xcode-Tools" class="headerlink" title="0x05 Xcode Tools"></a>0x05 Xcode Tools</h1><h2 id="0x0501-xcode-select"><a href="#0x0501-xcode-select" class="headerlink" title="0x0501 xcode-select"></a>0x0501 xcode-select</h2><p>任何人与 Xcode 的旅程始于一个选择。<code>xcode-select</code> 提供这个选择。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
        <tag>Objective-C</tag>
        <tag>Unix</tag>
        <tag>OS X</tag>
        <tag>Dictionary</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode Toolchain</title>
    <url>/2016/11/05/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter14-Xcode-Toolchain/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac14eb208f.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 14 Xcode Toolchain 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-Xcode-Toolchain"><a href="#0x01-Xcode-Toolchain" class="headerlink" title="0x01 Xcode Toolchain"></a>0x01 Xcode Toolchain</h1><p>从 Mavericks 开始，作为一个开发者在 Mac 上开始只需要一个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select -- install</span><br></pre></td></tr></table></figure>

<p>这将会安装命令行工具，这是编译 Objective-C 代码所必要的。</p>
<h1 id="0x02-xcrun"><a href="#0x02-xcrun" class="headerlink" title="0x02 xcrun"></a>0x02 xcrun</h1><p><code>xcrun</code> 是 Xcode 命令行工具的基础。有了它，所有其他的工具都可以被调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xcrun xcodebuild</span><br></pre></td></tr></table></figure>

<p>除了运行命令，<code>xcrun</code> 可以找到二进制文件并显示 SDK 的路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xcrun --find clang</span><br><span class="line">$ xcrun --sdk iphoneos --find pngcrush</span><br><span class="line">$ xcrun --sdk macosx --show-sdk-path</span><br></pre></td></tr></table></figure>

<p>由于 <code>xcrun</code> 是执行在活动的 Xcode 版本（由 <code>xcode-select</code> 设置）的上下文中，所以在单系统上很容易共存多个版本的 Xcode 工具链（toolchain）。</p>
<p>在脚本和其他外部工具中使用 <code>xcrun</code> 具有确保跨不同环境的统一性的优点。例如，Xcode 附带了一个 Git 的自定义分布（custom distribution）。通过调用 <code>$ xcrun git</code> 而不只是 <code>$ git</code>，构建系统可以保证运行正确的分布。</p>
<h1 id="0x03-xcodebuild"><a href="#0x03-xcodebuild" class="headerlink" title="0x03 xcodebuild"></a>0x03 xcodebuild</h1><p>第二个最重要的 Xcode 工具是 <code>xcodebuild</code>，顾名思义，构建 Xcode 项目（projects）和工作空间（workspaces）。</p>
<p>不需要传递任何构建设置，<code>xcodebuild</code> 默认使用 Xcode.app 最近使用的方案（scheme）和配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xcodebuild</span><br></pre></td></tr></table></figure>

<p>然而，从方案，targets，配置（configuration），目标地址（destination），SDK 和 derived data 位置的一切都可以配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xcodebuild -workspace NSHipster.xcworkspace \</span><br><span class="line">             -scheme <span class="string">&quot;NSHipster&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里有 7 个可以按照顺序被调用的构建动作：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">build</td>
<td align="left">在构建根目录（build root，<code>SYMROOT</code>）中构建目标（target）。这是默认的构建动作。</td>
</tr>
<tr>
<td align="left">analyze</td>
<td align="left">从构建根目录中构建并分析一个目标或方案。需要指定一个方案。</td>
</tr>
<tr>
<td align="left">archive</td>
<td align="left">从构建根目录中归档（Archive）一个方案。需要指定一个方案。</td>
</tr>
<tr>
<td align="left">test</td>
<td align="left">从构建根目录中测试一个方案。需要指定一个方案和可选的目标地址。</td>
</tr>
<tr>
<td align="left">installsrc</td>
<td align="left">复制项目的源到源根目录（source root，<code>SRCROOT</code>）。</td>
</tr>
<tr>
<td align="left">install</td>
<td align="left">构建目标并且安装到目标在分发根目录（distribution root，DSTROOT）的安装目录中。</td>
</tr>
<tr>
<td align="left">clean</td>
<td align="left">从构建根目录移除构建的产品（products）和中间文件。</td>
</tr>
</tbody></table>
<h1 id="0x04-genstrings"><a href="#0x04-genstrings" class="headerlink" title="0x04 genstrings"></a>0x04 genstrings</h1><p><code>genstrings</code> 工具从指定的 C 或 Objective-C 源文件生成一个 <code>.strings</code> 文件。<code>.strings</code> 文件用于在不同语言环境中本地化一个应用程序，在 Apple 的 Cocoa Core Competencies 中的 [“Internationalization”](<a href="https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/-">https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/-</a> Internationalization.html) 下有描述。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ genstrings -a \</span><br><span class="line">             /path/to/source/files/*.m</span><br></pre></td></tr></table></figure>

<p>对于在源文件中每次使用的 <code>NSLocalizedString</code> 宏，<code>genstrings</code> 都会将 key 和注释附加到目标文件中。然后由开发者为每个目标语言环境创建一个该文件的副本，并翻译该文件。</p>
<p>fr.lproj&#x2F;Localizable.strings</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* No comment provided by engineer. */</span><br><span class="line">&quot;Username&quot;=&quot;nom d&#x27;utilisateur&quot;;</span><br><span class="line">/* &#123;User First Name&#125;&#x27;s Profile */</span><br><span class="line">&quot;%@&#x27;s Profile&quot;=&quot;profil de %1$@&quot;;</span><br></pre></td></tr></table></figure>

<h1 id="0x05-ibtool"><a href="#0x05-ibtool" class="headerlink" title="0x05 ibtool"></a>0x05 ibtool</h1><p><code>genstrings</code> 是用于源代码，而 <code>ibtool</code> 是用于 XIB 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ibtool --generate-strings-file \</span><br><span class="line">         Localizable.strings \</span><br><span class="line">         en.lpoj/Interface.xib</span><br></pre></td></tr></table></figure>

<p>虽然本地化是它的主要用例，<code>ibtool</code> 有用于跟 Interface Builder 文档工作的几个其他功能。可以使用 <code>--convert</code> 标记来改变对一个类名的所有引用。可以使用 <code>--upgrade</code> 标记将一个文档升级到最新版本。甚至可以分别使用 <code>--enable-auto-layout</code>，<code>--update-frames</code> 和 <code>--update-constraints</code> 标记来启动 Auto Layout，以及更新 frames &amp; constraints（约束）。</p>
<h1 id="0x06-iprofiler"><a href="#0x06-iprofiler" class="headerlink" title="0x06 iprofiler"></a>0x06 iprofiler</h1><p><code>iprofiler</code> 不需要启动 Instruments.app 测算一个 app 的性能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iprofiler -allocations \</span><br><span class="line">            -leaks \</span><br><span class="line">            -T 15s \</span><br><span class="line">            -o perf \</span><br><span class="line">            -a NSHipster</span><br></pre></td></tr></table></figure>

<p>上面的命令将附加到 NSHipster.app 上，运行 15 秒，仪器分配和泄露，然后将结果写入 <code>pref</code> 中。然后这个输出可以通过 Instruments.app 读取和显示。</p>
<h1 id="0x07-xed"><a href="#0x07-xed" class="headerlink" title="0x07 xed"></a>0x07 xed</h1><p>这个命令简单地打开 Xcode。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xed NSHipster.xcworkspace</span><br></pre></td></tr></table></figure>

<p>通过传递 <code>-w</code> 标记，<code>xed</code> 会等待直到所有一打开的窗口都关闭。这个对于脚本化用户交互非常有用，例如提示用户编辑一个文件，一旦完成就继续。</p>
<h1 id="0x08-agvtool"><a href="#0x08-agvtool" class="headerlink" title="0x08 agvtool"></a>0x08 agvtool</h1><p>通过在 <code>Info.plist</code> 文件中读写一个适当的值， <code>agvtool</code> 可以用于修改 Xcode 项目的版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ agvtool what-version</span><br></pre></td></tr></table></figure>

<p>…返回当前项目的版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ agvtool next-version</span><br></pre></td></tr></table></figure>

<p>…增加 <strong>当前项目的版本</strong> 和 <strong>当前 DYLIB 的版本</strong>。传递 <code>-all</code> 选项也会更新 <code>Info.plist</code> 中的 <code>CFBundleVersion</code> key。</p>
<h1 id="0x09-Other-Tools"><a href="#0x09-Other-Tools" class="headerlink" title="0x09 Other Tools"></a>0x09 Other Tools</h1><p>除了上述的 Xcode tools，还有一些其他可执行文件可以被 <code>xcrun</code> 调用。</p>
<h2 id="0x0901-Compilation-amp-Assembly"><a href="#0x0901-Compilation-amp-Assembly" class="headerlink" title="0x0901 Compilation &amp; Assembly"></a>0x0901 Compilation &amp; Assembly</h2><ul>
<li>clang：Compiles C，C，Objective-C 和 Objective-C 源文件。</li>
<li>lldb：Debugs C，C，Objective-C 和 Objective-C 程序。</li>
<li>nasm：汇编文件。</li>
<li>ndisasm：反汇编文件。</li>
<li>symbols：显示一个文件或过程（process）的符号信息。</li>
<li>strip：删除或修改附加到汇编器和链接编辑器输出的符号表。</li>
<li>atos：将数字地址转换为二进制映像或进程的符号。</li>
</ul>
<h2 id="0x0902-Processors"><a href="#0x0902-Processors" class="headerlink" title="0x0902 Processors"></a>0x0902 Processors</h2><ul>
<li>unifdef：从代码中删除条件的 <code>#ifdef</code> 宏。</li>
<li>ifnames：在 C++ 文件中查找条件。</li>
</ul>
<h2 id="0x0903-Libraries"><a href="#0x0903-Libraries" class="headerlink" title="0x0903 Libraries"></a>0x0903 Libraries</h2><ul>
<li>ld：将对象文件和库组合到单个文件中。</li>
<li>otool：显示对象文件或库的指定部分。</li>
<li>ar：创建和维护库归档。</li>
<li>libtool：创建一个用于链接编辑器 <code>ld</code> 的库。</li>
<li>ranlib：更新归档库的内容目录。</li>
<li>mksdk：制作和更新 SDK。</li>
<li>lorder：列出对象文件的依赖关系。</li>
</ul>
<h2 id="0x0904-Scripting"><a href="#0x0904-Scripting" class="headerlink" title="0x0904 Scripting"></a>0x0904 Scripting</h2><ul>
<li>sdef：脚本定义提取器。</li>
<li>sdp：脚本定义处理器。</li>
<li>amlint：Checks Automator actions for problems.</li>
</ul>
<h2 id="0x0905-Packages"><a href="#0x0905-Packages" class="headerlink" title="0x0905 Packages"></a>0x0905 Packages</h2><ul>
<li>installer：安装 OS X 包（packages）。</li>
<li>pkgutil：读取和操作 OS X 包。</li>
<li>lsbom：列出一个 bom（Bill of Materials） 的内容。</li>
</ul>
<h2 id="0x0906-Documentation"><a href="#0x0906-Documentation" class="headerlink" title="0x0906 Documentation"></a>0x0906 Documentation</h2><ul>
<li>headerdoc：进程头文档。</li>
<li>gatherheaderdoc：编译和链接 <code>headerdoc</code> 输出。</li>
<li>headerdoc2html：从 <code>headerdoc</code> 输出生成 HTML。</li>
<li>hdxml2manxml：从 <code>headerdoc</code> XML 输出翻译为使用 <code>xml2man</code> 的文件。</li>
<li>xml2man：将 Man Page Generation Language（MPGL）XML 文件转换为 manual pages。</li>
</ul>
<h2 id="0x0907-Core-Data"><a href="#0x0907-Core-Data" class="headerlink" title="0x0907 Core Data"></a>0x0907 Core Data</h2><ul>
<li>momc：编译 Managed Object Model（.mom）文件</li>
<li>mapc：编译 Core Data Mapping Model（.xcmappingmodel）文件</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>Objective-C</tag>
        <tag>xcrun</tag>
        <tag>xcodebuild</tag>
      </tags>
  </entry>
  <entry>
    <title>Third Party Tools</title>
    <url>/2016/11/06/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter15-Third-Party-Tools/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac167a794e.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 15 Third Party Tools 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-appledoc"><a href="#0x01-appledoc" class="headerlink" title="0x01 appledoc"></a>0x01 appledoc</h1><p>Cocoa 开发者中有一句谚语，Objective-C 的冗长有助于自文档化（self-documenting）代码。在 <code>longMethodNamesWithNamedParameters:</code> 和这些参数的显式类型之间，Objective-C 方法不会留下太多的想象。</p>
<p>但是即使是自文档化代码可以通过文档来改进，只需少量的工作就能对他人产生显著的好处。</p>
<p>在 Objective-C 中，选择的文档工具是 <a href="http://gentlebytes.com/appledoc/"><code>appledoc</code></a>。<code>appledoc</code> 能够从 <code>.h</code> 文件中生成 HTML 和 Xcode 兼容的 <code>.docset</code> 文档，看起来跟 Apple 的官方文档几乎一样。</p>
<p>Objective-C 文档由任何 <code>@interface</code> 或 <code>@protocol</code>之前的 &#x2F;** *&#x2F; 注释块（注意额外的初始星号）以及任何方法或 <code>@property</code> 声明所指定。文档可能还包含系统字段的标签，如参数或返回值：</p>
<ul>
<li>@param [param] [Description]：描述了应该传递什么值或此参数</li>
<li>@return [Description]：描述了一个方法的返回值</li>
<li>@see [selector]：提供“参见”相关项目的参考</li>
<li>@discussion [Discussion]：提供额外的背景情况</li>
<li>@warning [description]：调出异常或潜在的危险的行为</li>
</ul>
<p><code>appledoc</code> 可以通过遵循项目页面上提供的最新的安装说明或使用 <a href="http://brew.sh/">Homebrew</a> 安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install appledoc</span><br></pre></td></tr></table></figure>

<p>要生成文档，可以在一个 Xcode 项目的根目录中执行 <code>appledoc</code>命令，传递元数据比如项目和公司名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ appledoc --project-name CFHipsterRef \</span><br><span class="line">           --project-company <span class="string">&quot;NSHipster&quot;</span> \</span><br><span class="line">           --company-id com.nshipster \</span><br><span class="line">           --output ~/Documents \</span><br><span class="line">           .</span><br></pre></td></tr></table></figure>

<p>这会从目标目录中找到的头文件中生成并安装一个 Xcode <code>.docset</code> 文件。</p>
<p>额外的配置选项，包括 HTML 输出，可以通过传递 <code>--help</code> 找到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ appledoc --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h1 id="0x02-xctool"><a href="#0x02-xctool" class="headerlink" title="0x02 xctool"></a>0x02 xctool</h1><p><code>xctool</code> 是 <code>xcodebuild</code> 的替代，<code>xcodebuild</code> 是 Xcode.app 下的工具。</p>
<p><code>xctool</code> 的优美不只是表面上的，构建进度也可以格式化报告，可以由其他工具读取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xctool -reporter plain:output.txt build</span><br></pre></td></tr></table></figure>

<ul>
<li>pretty：（ <em>默认</em> ）一个基于文本的报告器（reporter），其使用 ANSI 颜色和 unicode 符号来美化输出。</li>
<li>plain：如 <code>pretty</code>，但是没有带颜色或 Unicode。</li>
<li>phabricator：输出一个 JSON 数据的构建&#x2F;测试结果，可以输入到 Phabricator 代码 review 工具中。</li>
<li>junit：生成具有测试结果的 JUnit &#x2F; xUnit 兼容的 XML 文件。</li>
<li>json-stream：一个构建&#x2F;测试流作为 JSON 字典，一行（示例输出）。</li>
<li>json-compilation-database：输出构建事件的 JSON 编译数据库，其可以通过基于 Clang Tooling 的工具使用，例如 OCLint。</li>
</ul>
<p>对 <code>xcodebuild</code> 的另一个改进是 <code>xctool</code>  会以 Xcode.app 相同的方式在项目中运行应用程序测试。</p>
<p>仅仅因为这个原因，xctool 对 Objective-C 社区中持续集成测试的新兴学科具有重大含义。</p>
<p>要安装 <code>xctool</code>，运行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install xctool</span><br></pre></td></tr></table></figure>

<h1 id="0x03-OCLint"><a href="#0x03-OCLint" class="headerlink" title="0x03 OCLint"></a>0x03 OCLint</h1><p>OCLint 是一个静态代码分析器，用于检查 C 代码是否存在常见的问题源，想空的 <code>if/else/try/catch/finally</code> 语句，未使用的局部变量和参数，具有高 NCSS（非注释源语句，Non Commenting Source Statements）复杂代码，冗余代码和其他不良做法。</p>
<p>安装 OCLint 最佳的方式是使用 Homebrew <a href="http://caskroom.io/">Cask</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew cask install oclint</span><br></pre></td></tr></table></figure>

<p>还记得 xctool 的 <code>json-compilation-database</code> 报告器选项吗？与 <code>oclint-json-compilation-database</code> 一起使用来启动 OCLint：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xctool -workspace NSHipster.xcworkspace \</span><br><span class="line">         -scheme <span class="string">&quot;NSHipster&quot;</span> \</span><br><span class="line">         -reporter json-compilation-database \</span><br><span class="line">         build &gt; compile_commands.json</span><br><span class="line"></span><br><span class="line">$ oclint-json-compilation-database</span><br></pre></td></tr></table></figure>

<h1 id="0x04-xcpretty"><a href="#0x04-xcpretty" class="headerlink" title="0x04 xcpretty"></a>0x04 xcpretty</h1><p><code>xcpretty</code> 类似于 <code>xctool</code>，它改进了 <code>xcodebuild</code> 构建输出，但不是尝试替换 <code>xcodebuild</code>，而是扩展并改进它。</p>
<p>事实上，<code>xcpretty</code> 通过获取 <code>xcodebuild</code> 的管道输出，而不是直接调用来例证 Unix 可组合性的哲学：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xcodebuild [flags] | xcpretty -c</span><br></pre></td></tr></table></figure>

<p>这种方法的一个主要好处是它真的很快 —— 事实上，在某些情况下，<code>xcpretty</code> 实际上比直接调用 <code>xcodebuild</code> 还要快一点，因为它节省了打印到控制台的时间。</p>
<p>与 <code>xctool</code> 另一个共性是报告器功能，其特点是格式化输出为 jUnit 风格的 XML，HTML 或 上述 OCTool 兼容的 json-compilation-database 格式。</p>
<p><code>xcpretty</code> 可以使用 <a href="http://rubygems.org/">RubyGems</a> 安装，其在 OS X 中已经默认安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem install xcpretty</span><br></pre></td></tr></table></figure>

<h1 id="0x05-Nomad"><a href="#0x05-Nomad" class="headerlink" title="0x05 Nomad"></a>0x05 Nomad</h1><p>Nomad 是用于 iOS 和 OS X 开发的世界级命令行工具的集合。它自动化常见的管理任务，以便于开发者可以专注于构建软件。</p>
<p>每个工具都可以独立地安装，或者用一条命令一起安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem install nomad-cli</span><br></pre></td></tr></table></figure>

<h1 id="0x06-Cupertino"><a href="#0x06-Cupertino" class="headerlink" title="0x06 Cupertino"></a>0x06 Cupertino</h1><p>应用程序 provisioning 的过程被所有 Apple 开发者普遍厌恶。</p>
<p>除了整个过程是一个噩梦的开始到结束，许多操作需要通过 Web 界面进行交互。这不仅需要大量额外的点击，而且使其很难自动化。</p>
<p>Cupertino 提供了一个 CLI 用来管理设备，provisioning profiles，app IDs 和 证书（certificates）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ios devices:list</span><br><span class="line"></span><br><span class="line">+------------------------------+---------------------------------------+</span><br><span class="line">|      Listing 2 devices. You can register 98 additional devices.      |</span><br><span class="line">+---------------------------+------------------------------------------+</span><br><span class="line">| Device Name               | Device Identifier                        |</span><br><span class="line">+---------------------------+------------------------------------------+</span><br><span class="line">| Johnny Appleseed iPad     | 0123456789012345678901234567890123abcdef |</span><br><span class="line">| Johnny Appleseed iPhone   | abcdef0123456789012345678901234567890123 |</span><br><span class="line">+---------------------------+------------------------------------------+</span><br><span class="line"></span><br><span class="line">$ ios devices:add <span class="string">&quot;iPad 1&quot;</span>=abc123</span><br><span class="line">$ ios devices:add <span class="string">&quot;iPad 2&quot;</span>=def456 <span class="string">&quot;iPad 3&quot;</span>=ghi789 ...</span><br></pre></td></tr></table></figure>

<h1 id="0x07-Shenzhen"><a href="#0x07-Shenzhen" class="headerlink" title="0x07 Shenzhen"></a>0x07 Shenzhen</h1><p>有一件事 web 开发者相对于 iOS 是可以在几秒钟之内连续部署代码，与为 Cupertino 的批准（有时候拒绝！）一个更新而等待几天截然不同。</p>
<p>幸运的是，一个家庭手工业随着开发和企业分发而兴起。第三方像 HockeyApp，DeployGate 和 TestFlight 提供开发者一个更简单的方式去注册测试用户和发送最新的 QA 版本。</p>
<p>Shenzhen 是一个进一步自动化此过程的工具，通过构建 <code>.ipa</code> 文件然后分发到一个 FTP&#x2F;SFTP 服务器，S3 bucket 或任何上述第三方服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/iOS Project/</span><br><span class="line">$ ipa build</span><br><span class="line">$ ipa distribute:sftp --host HOST -u USER -p PASSWORD -P FTP_PATH</span><br></pre></td></tr></table></figure>

<h1 id="0x08-Houston"><a href="#0x08-Houston" class="headerlink" title="0x08 Houston"></a>0x08 Houston</h1><p>Houston 是一个用于发送 Apple Push Notifications 的简单工具。传递凭据，构造消息，并将其发送到设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apn push <span class="string">&quot;&lt;token&gt;&quot;</span> \</span><br><span class="line">    -c /path/to/apple_push_notification.pem \</span><br><span class="line">    -m <span class="string">&quot;Hello from the command line!&quot;</span></span><br></pre></td></tr></table></figure>

<p>此工具特别适合用于测试远程通知 —— 特别在一个新的 app 中实现功能。</p>
<h1 id="0x09-Venice"><a href="#0x09-Venice" class="headerlink" title="0x09 Venice"></a>0x09 Venice</h1><p>应用内购买（In-app Purchase）已经，或多或少，成为 app 开发者最有利的商业模式。</p>
<p>Venice 是一个用于验证 Apple 应用内购买收据的 CLI，并且用收据数据检索相关联的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iap verify /path/to/receipt</span><br><span class="line"></span><br><span class="line">+-----------------------------+-------------------------------+</span><br><span class="line">|                           Receipt                           |</span><br><span class="line">+-----------------------------+-------------------------------+</span><br><span class="line">| app_item_id                 |                               |</span><br><span class="line">| bid                         | com.foo.bar                   |</span><br><span class="line">| bvrs                        | 20120427                      |</span><br><span class="line">| original_purchase_date      | Sun, 01 Jan 2013 12:00:00 GMT |</span><br><span class="line">| original_transaction_id     | 1000000000000001              |</span><br><span class="line">| product_id                  | com.example.product           |</span><br><span class="line">| purchase_date               | Sun, 01 Jan 2013 12:00:00 GMT |</span><br><span class="line">| quantity                    | 1                             |</span><br><span class="line">| transaction_id              | 1000000000000001              |</span><br><span class="line">| version_external_identifier |                               |</span><br><span class="line">+-----------------------------+-------------------------------+</span><br></pre></td></tr></table></figure>

<p>就像 Houston，Venice 具有一个客户端库组件，允许它部署在一个 Rails 或 Sinatra 应用程序。验证服务器上的收据允许保留他们自己过去购买的记录，这对于最新的指标和历史分析是有用的。因此，关于 IAP，这是推荐的做法。</p>
<h1 id="0x0A-Dubai"><a href="#0x0A-Dubai" class="headerlink" title="0x0A Dubai"></a>0x0A Dubai</h1><p>Passbook 管理登机牌，电影票，零售优惠券和会员卡。使用 PassKit API，开发者可以注册 web services 以自动更新通信证上的内容，比如登机牌上的登机口更改或向会员卡添加积分。</p>
<p>Dubai 可以很容易地从脚本或命令行生成 <code>.pkpass</code> 文件，允许快速迭代你的 passes 的设计和内容，或生成一次性的动态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pk generate Example.pass -T boarding-pass</span><br></pre></td></tr></table></figure>

<p>一旦一个 pass 生成，它可以用 Dubai 通过 HTTP 开启一个本地服务，允许 passes 在 iOS 模拟器上动态地预览：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pk serve Example.pass -c /path/to/certificate.p12</span><br><span class="line">$ open http://localhost:4567/pass.pkpass</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods</title>
    <url>/2016/11/07/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter16-CocoaPods/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac17673fef.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 16 CocoaPods 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-Using-CocoaPods"><a href="#0x01-Using-CocoaPods" class="headerlink" title="0x01 Using CocoaPods"></a>0x01 Using CocoaPods</h1><p>作为使用者和一个库的作者，CocoaPods 都是非常容易上手的。安装只需要几分钟的时间。</p>
<h2 id="0x01-Installing-CocoaPods"><a href="#0x01-Installing-CocoaPods" class="headerlink" title="0x01 Installing CocoaPods"></a>0x01 Installing CocoaPods</h2><p>通过 RubyGems 安装 CocoaPods，RubyGems 是一个标准的 OS X 安装的 Ruby 包管理器，</p>
<p>打开 Terminal.app 并输入下面命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure>

<p>现在你应该就可以在终端中使用 <code>pod</code> 命令了。</p>
<h1 id="0x02-Managing-Dependencies"><a href="#0x02-Managing-Dependencies" class="headerlink" title="0x02 Managing Dependencies"></a>0x02 Managing Dependencies</h1><p>一个依赖管理器将软件需求列表解析为特定标签列表，以下载并集成到项目中。</p>
<h2 id="0x0201-Podfile"><a href="#0x0201-Podfile" class="headerlink" title="0x0201 Podfile"></a>0x0201 Podfile</h2><p><code>Podfile</code> 是列出项目的依赖项的地方。它相当于使用 Bundler 或 <code>package</code> 的 Ruby 项目的 <code>Gemfile</code>。<code>json</code> 用于使用 npm 的 JavaScript 项目。</p>
<p>要生成一个 Podfile，<code>cd</code> 到你的 <code>.xcodeproj</code> 文件所在的目录然后输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod init</span><br></pre></td></tr></table></figure>

<p>Podfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">platform :ios, &#x27;7.0&#x27;</span><br><span class="line"></span><br><span class="line">target &quot;AppName&quot; do</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>依赖项可以有不同级别的规范。对于大多数的库，将它们包括进你的项目中绑定到一个次版本或补丁版本是最安全和最简单的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod &#x27;X&#x27;, &#x27;~&gt; 1.1&#x27;</span><br></pre></td></tr></table></figure>

<p>要包括一个为包括到公共 specs 数据库的库，可以使用 Git，Mercurial 或 SVN 仓库，可以指定一个 <code>commit</code>，<code>branch</code> 或 <code>tag</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod &#x27;Y&#x27;, :git =&gt; &#x27;https://github.com/NSHipster/Y.git&#x27;, :commit =&gt; &#x27;b4dc0ffee&#x27;</span><br></pre></td></tr></table></figure>

<p>一旦指定了所有的依赖项，它们就使用以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure>

<p>当运行这个命令的时候，CocoaPods 将会递归分析每个项目的依赖关系，将它们解析为依赖图，并序列化为 <code>Podfile.lock</code> 文件。</p>
<p>CocoaPods 会创建一个新的 Xcode 项目，为每个依赖项创建静态库 target，然后将它们链接一起到一个 <code>libPods.a</code> target 中。这个静态库变成你原始项目的一个依赖项。一个 <code>xcworkspace</code> 文件被创建并且应该从此时开始使用。这允许原始的 <code>xcodeproj</code> 文件保持不变。</p>
<p>随后调用的 <code>pod install</code> 会根据锁定的依赖图添加新的 pods 或 删除旧的 pods。要更新一个项目单独的依赖项到最新的版本，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod update</span><br></pre></td></tr></table></figure>

<h1 id="0x03-Trying-Out-a-CocoaPod"><a href="#0x03-Trying-Out-a-CocoaPod" class="headerlink" title="0x03 Trying Out a CocoaPod"></a>0x03 Trying Out a CocoaPod</h1><p>一个很棒但是鲜为人知的 CocoaPods 的功能是 <code>try</code> 命令，其允许你在添加一个库到你的项目之前测试这个库。</p>
<p>使用在公共 specs 数据库中的一个项目的名称调用 <code>$ pod try</code> 打开库的任何示例项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod try Ono</span><br></pre></td></tr></table></figure>

<h1 id="0x04-Creating-a-CocoaPod"><a href="#0x04-Creating-a-CocoaPod" class="headerlink" title="0x04 Creating a CocoaPod"></a>0x04 Creating a CocoaPod</h1><p>作为 Objective-C 软件分发的事实标准，CocoaPods 是开源项目的一个要求，目的是被其他人使用。</p>
<p>花几分钟时间创建一个 <code>.podspec</code> 文件至少可以节省每个用户尝试将其集成到他们自己的项目中的时间。</p>
<p>记住：提高软件生态系统中的贡献标准降低了参与的标准。</p>
<h2 id="0x0401-Specification"><a href="#0x0401-Specification" class="headerlink" title="0x0401 Specification"></a>0x0401 Specification</h2><p><code>.podspec</code> 文件是 CocoaPods 依赖的原子单位。它指定了一个库的名称，版本，license 和源文件，以及其他元数据。</p>
<p>NSHipsterKit.podspec</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name     = &#x27;NSHipsterKit&#x27;</span><br><span class="line">  s.version  = &#x27;1.0.0&#x27;</span><br><span class="line">  s.license  = &#x27;MIT&#x27;</span><br><span class="line">  s.summary  = &quot;A pretty obscure library. You&#x27;ve probably never heard of it.&quot;</span><br><span class="line">  s.homepage = &#x27;http://nshipster.com&#x27;</span><br><span class="line">  s.authors  = &#123; &#x27;Mattt Thompson&#x27; =&gt;</span><br><span class="line">                &#x27;mattt@nshipster.com&#x27; &#125;</span><br><span class="line">  s.social_media_url = &quot;https://twitter.com/mattt&quot;</span><br><span class="line">  s.source = &#123; :git =&gt; &#x27;https://github.com/nshipster/NSHipsterKit.git&#x27;, :tag =&gt; &#x27;1.0.0&#x27; &#125;</span><br><span class="line">  s.source_files = &#x27;NSHipsterKit&#x27;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>一旦发布到公共 specs 数据库，任何人都可以将其添加到自己的项目中：</p>
<p>Podfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod &#x27;NSHipsterKit&#x27;, &#x27;~&gt; 1.0&#x27;</span><br></pre></td></tr></table></figure>

<p><code>.podspec</code> 文件也可以用于组织内置或私有依赖项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pod &#x27;Z&#x27;, :path =&gt; &#x27;path/to/directory/with/podspec&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="0x05-Publishing-a-CocoaPod"><a href="#0x05-Publishing-a-CocoaPod" class="headerlink" title="0x05 Publishing a CocoaPod"></a>0x05 Publishing a CocoaPod</h1><p>虽然它开始工作地非常出色，但在 GitHub 上使用 Pull Requests 管理新的 pods 的过程变得很琐碎，对于库的作者和 spec 组织者来说都是。有时 podspecs 会不传递 <code>$ pod lint</code> 而提交，导致 specs repo 构建失败。其他时候，来自原始库作者意外的人的劣质提交会意外地打乱事情。</p>
<p>CocoaPods Trunk 服务，在 CocoaPods 0.33 中引入，解决了很多问题，使这个过程的对所有参与者都很好。作为一个集中式服务，它还具有能够获取库使用分析以及其他指标的好处。</p>
<p>要开始使用，你必须先使用 Trunk 服务注册你的机器。这非常简单，只需要指定你的 email 地址（那个你用来提交库代码的）以及你的名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod trunk register mattt@nshipster.com <span class="string">&quot;Mattt Thompson&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在，将代码发布到 CocoaPods 只需要一个命令。同一个命令适用于创建新库或向现有库中添加新版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod trunk push NAME.podspec</span><br></pre></td></tr></table></figure>

<h1 id="0x06-A-Look-Forward"><a href="#0x06-A-Look-Forward" class="headerlink" title="0x06 A Look Forward"></a>0x06 A Look Forward</h1><p>CocoaPods 例证了社区基础设施的复合效应。在短短几年内，Objective-C 社区已经变成了我们可以成为一部分而感到自豪的东西。</p>
<p>CocoaPods 对于 Objective-C 是一个好东西。只会越来越好。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C Runtime</title>
    <url>/2016/10/27/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter2-Objective-C-Runtime/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac08f5ea2a.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 2 Objective-C Runtime 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-libobjc"><a href="#0x01-libobjc" class="headerlink" title="0x01 libobjc"></a>0x01 libobjc</h1><p><code>libobjc</code> 是 Objective-C 2.0 运行时的共享库。</p>
<p>要想使用 runtime，可以导入 <code>&lt;objc/runtime.h&gt;</code> 头文件。</p>
<h1 id="0x02-发送消息（Message-Sending）"><a href="#0x02-发送消息（Message-Sending）" class="headerlink" title="0x02 发送消息（Message Sending）"></a>0x02 发送消息（Message Sending）</h1><p>在 Objective-C 中，调用一个对象的某个方法，一般的写法是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[object message];</span><br></pre></td></tr></table></figure>

<p>然后编译器最后会将该语句翻译成：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">objc_msgSend(object, <span class="keyword">@selector</span>(message));</span><br></pre></td></tr></table></figure>

<p><code>objc_msgSend</code> 有几种形式：</p>
<ul>
<li><code>objc_msgSend</code>：向一个类发送简单返回值类型的消息</li>
<li><code>objc_msgSend_stret</code>：向一个类发送返回值类型为结构体的消息</li>
<li><code>objc_msgSendSuper</code>：向父类发送简单返回值类型的消息</li>
<li><code>objc_msgSendSuper_stert</code>：向父类发送返回值类型为结构体的消息</li>
</ul>
<h1 id="0x03-属性元编程（Metaprogramming-with-Properties）"><a href="#0x03-属性元编程（Metaprogramming-with-Properties）" class="headerlink" title="0x03 属性元编程（Metaprogramming with Properties）"></a>0x03 属性元编程（Metaprogramming with Properties）</h1><p>属性定义了对象状态的公共接口。</p>
<p>例如，访问一个对象的属性列表，我们可以通过属性元编程来避免手动实现 <code>NSCoding</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - NSCoding</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)decoder &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="keyword">in</span> count;</span><br><span class="line">        objc_property_t *properties = class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            objc_property_t property = properties[i];</span><br><span class="line">            <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:property_getName(property)];</span><br><span class="line">            [<span class="keyword">self</span> setValue:[decoder decodeObjectForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        free(properties);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)coder &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    objc_property_t *properties = class_getPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        objc_property_t property = properties[i];</span><br><span class="line">        <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:property_getName(property)];</span><br><span class="line">        [coder encodeObject:[<span class="keyword">self</span> valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x04-关联对象（Associated-Objects）"><a href="#0x04-关联对象（Associated-Objects）" class="headerlink" title="0x04 关联对象（Associated Objects）"></a>0x04 关联对象（Associated Objects）</h1><p>关联对象是 Objective-C 运行时的一个特性，允许开发者对已经存在的类在扩展中添加自定义的属性，这非常有用。</p>
<p>关联对象使用非常简单，用 <code>objc_setAssociatedObject</code> 存储一个关联值，用 <code>objc_getAssociatedObject</code> 获取这个关联值。</p>
<p>任何关联对象都是通过一个 key 来关联的，这个 key 可以是任何常量值。最简单的方法就是传入 getter 方法选择器（方法选择器在运行时保证是唯一且不变的）。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="type">id</span> associatedObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setAssociatedObject:(<span class="type">id</span>)object &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)associatedObject &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x05-动态添加方法（Dynamically-Adding-a-Method）"><a href="#0x05-动态添加方法（Dynamically-Adding-a-Method）" class="headerlink" title="0x05 动态添加方法（Dynamically Adding a Method）"></a>0x05 动态添加方法（Dynamically Adding a Method）</h1><p>正如属性描述了一个对象的状态，方法则构成了对象的行为。</p>
<p>在 Objective-C 中，方法以 <code>+</code> 或 <code>-</code> 前置声明，表示该方法是类方法还是实例方法（也就是说是通过类调用的还是类的对象来调用的）。</p>
<p>一个类可以通过创建一个 category 来添加新的方法，然后可以在包含了这个 category 的地方使用这些新的方法。</p>
<p>不过，方法也可以在运行时创建：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Class c = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line">IMP addingMethodIMP = imp_implementationWithBlock((<span class="built_in">NSString</span> *)^(<span class="type">id</span> <span class="keyword">self</span>, <span class="type">id</span> arg1) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;arg1 = %@&quot;</span>, arg1];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *addingMethodTypes = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%s%s%s&quot;</span>, <span class="keyword">@encode</span>(<span class="type">id</span>), <span class="keyword">@encode</span>(<span class="type">id</span>), <span class="keyword">@encode</span>(SEL)] UTF8String];</span><br><span class="line">class_addMethod(c, <span class="keyword">@selector</span>(addingMethodWithArg:), addingMethodIMP, addingMethodTypes);</span><br></pre></td></tr></table></figure>

<h1 id="0x06-Method-Swizzling"><a href="#0x06-Method-Swizzling" class="headerlink" title="0x06 Method Swizzling"></a>0x06 Method Swizzling</h1><p>Method Swizzling 是改变一个已存在的方法的实现的过程。这个技术是改变一个映射到一个类的调度表中的底层函数的方法，在运行时修改为调用自己定义的方法。</p>
<p>比如在某些时候想要跟踪一个应用里面的每个 ViewController 在一次生命周期内打开的次数。想要实现这个功能有几种方法：</p>
<ol>
<li>每个 ViewController 都添加跟踪代码到重载的 <code>viewDidAppear</code> 方法里面，但是这样会有很多重复的代码。</li>
<li>子类化 UIViewController，但是这样的话，还要子类化 <code>UITableViewController</code>、<code>UINavigationController</code> 等其他用到的 ViewController，还是要添加很多重复的代码。</li>
</ol>
<p>有了 Method Swizzling，解决办法就非常优雅了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewDidAppear:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewDidAppear:);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        <span class="type">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMthod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Method Swizzling</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)xxx_viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> xxx_viewDidAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;viewDidAppear: %@&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>现在，当任何 UIViewController 对象或者 它的子类对象调用 <code>viewDidAppear</code> 方法时，都会打印出一个 log。</p>
<p>因为 Method Swizzling 是影响全局状态的，所以尽可能减少竞态条件的可能性非常重要。</p>
<p><code>+ load</code> 方法保证在类初始化的时候执行，相比之下，<code>+ initialize</code> 不保证什么时候它会被执行（事实上，除非 app 直接对一个类发送消息，否则这个类的 <code>+ initialize</code> 方法不会被调用）。</p>
<h1 id="0x07-动态创建一个类（Dynamically-Creating-a-Class）"><a href="#0x07-动态创建一个类（Dynamically-Creating-a-Class）" class="headerlink" title="0x07 动态创建一个类（Dynamically Creating a Class）"></a>0x07 动态创建一个类（Dynamically Creating a Class）</h1><p>结合之前提到的动态属性和方法定义，<code>libobjc</code> 的终极大招是运行时创建一个类。</p>
<p>创建一个 <code>Product</code> 类，有两个属性：<code>name</code> 和 <code>price</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Product</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name price:(<span class="type">double</span>)price;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Product</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name price:(<span class="type">double</span>)price &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name;</span><br><span class="line">        <span class="keyword">self</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时创建：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Class c = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">&quot;Product&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(c, <span class="string">&quot;name&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">id</span>), log2(<span class="keyword">sizeof</span>(<span class="type">id</span>)), <span class="keyword">@encode</span>(<span class="type">id</span>));</span><br><span class="line">class_addIvar(c, <span class="string">&quot;price&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>), log2(<span class="keyword">sizeof</span>(<span class="type">double</span>)), <span class="keyword">@encode</span>(<span class="type">double</span>));</span><br><span class="line"></span><br><span class="line">Ivar nameIvar = class_getInstanceVariable(c, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">ptrdiff_t priceIvarOffset = ivar_getOffset(class_getInstanceVariable(c, <span class="string">&quot;price&quot;</span>));</span><br><span class="line"></span><br><span class="line">IMP initIMP = imp_implementationWithBlock(^(<span class="type">id</span> <span class="keyword">self</span>, <span class="built_in">NSString</span> *name, <span class="type">double</span> price) &#123;</span><br><span class="line">    object_setIvar(<span class="keyword">self</span>, nameIvar, name);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *ptr = ((<span class="type">char</span> *)(__bridge <span class="type">void</span> *)<span class="keyword">self</span>) + priceIvarOffset;</span><br><span class="line">    memcpy(ptr, &amp;price, <span class="keyword">sizeof</span>(price));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *initTypes = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%s%s%s%s%s%s&quot;</span>, <span class="keyword">@encode</span>(<span class="type">id</span>), <span class="keyword">@encode</span>(<span class="type">id</span>), <span class="keyword">@encode</span>(SEL), <span class="keyword">@encode</span>(<span class="type">id</span>), <span class="keyword">@encode</span>(<span class="type">id</span>), <span class="keyword">@encode</span>(<span class="built_in">NSUInteger</span>)] UTF8String];</span><br><span class="line">class_addMethod(c, <span class="keyword">@selector</span>(initWithFirstName:lastName:age), initIMP, initTypes);</span><br><span class="line"></span><br><span class="line">IMP nameIMP = imp_implementationWithBlock(^(<span class="type">id</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getIvar(<span class="keyword">self</span>, nameIvar);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *nameTypes = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%s%s%s&quot;</span>, <span class="keyword">@encode</span>(<span class="type">id</span>), <span class="keyword">@encode</span>(<span class="type">id</span>), <span class="keyword">@encode</span>(SEL)] UTF8String];</span><br><span class="line">class_addMethod(c, <span class="keyword">@selector</span>(name), nameIMP, nameTypes);</span><br><span class="line"></span><br><span class="line">IMP priceIMP = imp_implementationWithBlock(^(<span class="type">id</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="type">char</span> *ptr = ((<span class="type">char</span> *)(__bridge <span class="type">void</span> *)<span class="keyword">self</span>) + priceIvarOffset;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    memcpy(&amp;price, ptr, <span class="keyword">sizeof</span>(price));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *priceTypes = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%s%s%s&quot;</span>, <span class="keyword">@encode</span>(<span class="type">double</span>), <span class="keyword">@encode</span>(<span class="type">id</span>), <span class="keyword">@encode</span>(SEL)] UTF8String];</span><br><span class="line">class_addMethod(c, <span class="keyword">@selector</span>(age), priceIMP, priceTypes);</span><br><span class="line"></span><br><span class="line">objc_registerClassPair(c);</span><br></pre></td></tr></table></figure>

<p>这里代码很多，我们来一点一点说。</p>
<p>首先，一个类用 <code>objc_allocateClassPair</code> 被分配了内存空间，指定了这个类的父类和类名。</p>
<p>然后，使用 <code>class_addIvar</code> 给这个类添加了实例变量。第四个参数用于确定变量的最小对齐方式（variable’s minimum alignment），这取决于 ivar 的类型和目标平台架构。</p>
<p>接下来是用 <code>imp_implementationWithBlock:</code> 定义初始化函数（initializer）的实现。调用 <code>object_setIvar</code> 设置 <code>name</code>。<code>price</code> 是通过之前计算的 offset 执行 <code>memcpy</code> 来设置的。</p>
<p>为了添加初始化函数，需要计算每个参数的类型编码。<code>@encode</code> 和 字符串插值有点尴尬混乱，但是就是这样的。</p>
<p>添加 ivar 的 getter 方法类似。</p>
<p>最后，一旦所有的方法都被添加，类就被注册到运行时。从那时起，<code>Product</code> 就可以像其他任何 Objective-C 类一样交互了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Product *widget = [[Product alloc] initWithName:<span class="string">@&quot;Widget&quot;</span> price:<span class="number">50.00</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@: %g&quot;</span>, widget.name, widget,price);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>Grand Central Dispatch</title>
    <url>/2016/10/29/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter5-Grand-Central-Dispatch/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac0a966560.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 5 Grand Celtral Dispatch 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-Grand-Central-Dispatch"><a href="#0x01-Grand-Central-Dispatch" class="headerlink" title="0x01 Grand Central Dispatch"></a>0x01 Grand Central Dispatch</h1><p>关于过程控制（process control）的最引人注目的事情之一是如何接近现实匹配计算机的领域模型（reality matches the domain models of computers）。你不会走在街上偶然发现一个字符串（<code>String</code>），或者决定用 <code>socket</code> 来进行一个午餐对话。但是你会排队，等待一个过马路的信号。</p>
<p>确定如何最好地安排资源，以执行工作是直接适用于日常生活的编程。</p>
<p>也许是这个原因，并发性是程序员幽默的支柱。这的确是有一些幽默元素，因为，说实话，线程真的很难做正确。</p>
<p>抛开幽默的哲学，有一件事情是清楚的：对于并发编程，Grand Central Dispatch 是非常棒的。</p>
<p>Grand Central Dispatch (GCD) 是在多处理器系统上的性能优化技术。在 iOS 4 和 OS X 10.6 的 C 语言扩展中介绍的，GCD 可用于整个 Cocoa APIs，是程序变得更快更有效。</p>
<p>Apple 的 GCD 实现也是开源的，可以从 <a href="https://libdispatch.macosforge.org/">Mac OS Forge</a> 上下载。</p>
<h1 id="0x02-队列（Queues）"><a href="#0x02-队列（Queues）" class="headerlink" title="0x02 队列（Queues）"></a>0x02 队列（Queues）</h1><p>在 GCD 中，工作是被分成离散的块或函数，它们在调度队列（dispatch queues）上被调度（scheduled）。队列是从程序员的线程概念中抽象而来的。系统提供了一个主队列（main queue），用来执行一些在主线程（main thread）上的工作，另外提供了几个在不同优先级的后台线程上执行的全局队列，除此之外，用户还可以创建自己的队列。</p>
<p>自定义队列可以串行（serial）（同时只执行一个任务）或并行（concurrent）（同时执行多个任务）。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> customSerialQueue = dispatch_queue_create(<span class="string">&quot;com.example.serial&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> customConcurrentQueue = dispatch_queue_create(<span class="string">&quot;com.example.concurrent&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>

<p>工作被调度在一个队列中同步或者异步地执行。指定同步执行将会使队列等待直到 block 或者 函数结束，而异步则是直接执行下一个语句而不等待。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line"><span class="built_in">dispatch_sync</span>(mainQueue, ^&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Finished&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一个 GCD 常见的模式是将工作调度到后台队列（background queue）执行，然后将结果返回主队列。比如像更新 UI 这种特别重要的事情，是需要在主线程完成的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Finished&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>任务也可以被调度到一个指定延迟的队列上运行：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line">int64_t delay = <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, delay), mainQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Finished&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>GCD 队列一个鲜为人知但又有用的功能是在整数范围上应用一个 block。当在并发队列上运行时，<code>dispatch_apply</code> 提供了一个 <code>for</code> 循环的高并发替代方案：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">dispatch_queue_attr_t attributes = DISPATCH_QUEUE_CONCURRENT;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="literal">NULL</span>, attributes);</span><br><span class="line">dispatch_apply(<span class="number">1000</span>, queue, ^(size_t n) &#123;</span><br><span class="line">    size_t square = n * n;</span><br><span class="line">    printf(<span class="string">&quot;%zu: %zu\n&quot;</span>, square);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在前面章节中提到过的，GCD 可以用来实现强大的，线程安全的常用原子操作（common atomic operations）的实现。例如，<code>dispatch_once</code> 可以保证一个语句只执行一次 – 使其非常适合用来创建单例：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">id</span> _sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x03-组（Groups）"><a href="#0x03-组（Groups）" class="headerlink" title="0x03 组（Groups）"></a>0x03 组（Groups）</h1><p>任务也可以被调度到组中，提供了一个当这个组中全部任务执行结束的回调（callback）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="literal">NULL</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t n) &#123;</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        sleep((<span class="type">int</span>)n);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="0x04-信号量（Semaphores）"><a href="#0x04-信号量（Semaphores）" class="headerlink" title="0x04 信号量（Semaphores）"></a>0x04 信号量（Semaphores）</h1><p>信号量在 GCD 中扮演着至关重要的角色，通过允许异步代码等待或者阻塞执行，从而变得同步。对于很多应用程序而言，异步执行是完全优先的选择。然而在有些情况下，一个 API 必须同步运行。而在这些情况下，信号量就非常有用了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="literal">NULL</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>

<h1 id="0x05-Barrier"><a href="#0x05-Barrier" class="headerlink" title="0x05 Barrier"></a>0x05 Barrier</h1><p>Barrier 是前面章节探讨的另一个概念。在 GCD 中，barrier 通常用于同步对共享状态的访问。</p>
<p>不使用 Barrier：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="literal">NULL</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Finished&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 Barrier：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="literal">NULL</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个方法对于改变一个集合（比如数组或字典）非常有用：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSMutableDictionary</span> *mutableDictionary;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="type">id</span>)object forKey:(<span class="type">id</span>)key &#123;</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.mutableDictionary[key] = object;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x06-Sources"><a href="#0x06-Sources" class="headerlink" title="0x06 Sources"></a>0x06 Sources</h1><p>GCD 可以用来处理来自定时器（timers），进程（processes），Mach 端口（mach ports）和文件描述符（file descriptors）等事件。Dispatch sources 创建之后是挂起状态的，必须显示恢复（resumed）才能启动。</p>
<p>一个定时器的 dispatch event source 可以被认为是 <code>dispatch_after</code> 的一个更灵活的替代方法，具有被取消的能力，并且还提供最小化时间错位指令的性能影响的余地：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="literal">NULL</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line"></span><br><span class="line">int64_t delay = <span class="number">30</span> * <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line">int64_t leeway = <span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NEW, delay, leeway);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Ding Dong!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure>

<p>可以创建一个文件描述符的 dispatch event 来监听一个文件或文件夹的变化。无论何时触发了一个监视事件，事件 handler 都会被调度到指定的队列上：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> *fileURL = [[[<span class="built_in">NSFileManager</span> defaultManager] URLsForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomains:<span class="built_in">NSUserDomainMask</span>] firstObject];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fileDescriptor = open([fileURL fileSystemRepresentation], O_EVTONLY);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mask = DISPATCH_VNODE_EXTEND | DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE;</span><br><span class="line">__block dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fileDescriptor, mask, queue);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">    dispatch_source_vnode_flags_t flags = dispatch_source_get_date(source);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flags) &#123;</span><br><span class="line">        dispatch_source_cancel(source);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_cancel_handler(source, ^&#123;</span><br><span class="line">    close(fileDescriptor);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_resume(source);</span><br></pre></td></tr></table></figure>

<p>可以使用类似的方法从 STDIN 读取：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_source_t stdinReadSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, STDIN_FILEDO, <span class="number">0</span>, globalQueue);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler(stdinReadSource), ^&#123;</span><br><span class="line">    uint8_t buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> length = read(STDIN_FILENO, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithBytes:buffer length:length encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dispatch_resume(stdinReadSource);</span><br></pre></td></tr></table></figure>

<p>最后，一个 dispatch source 可以监听过程信号（process signals），例如 <code>SIGTERM</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">pid_t ppid = getppid();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, ppid, DISPATCH_PROC_EXIT, globalQueue);</span><br><span class="line"><span class="keyword">if</span> (source) &#123;</span><br><span class="line">    dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;pid: %d Exited&quot;</span>, ppid);</span><br><span class="line">        dispatch_source_cancel(source);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_resume(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x07-I-x2F-O"><a href="#0x07-I-x2F-O" class="headerlink" title="0x07 I&#x2F;O"></a>0x07 I&#x2F;O</h1><p>尽管 dispatch source 提供了与输入（input）和输出（output）非常方便的交互（interact），但它需要 API 调用者相当一部分的责任。GCD 的 I&#x2F;O APIs 允许开发者交出大部分的责任，这不仅减少了需要编写的代码，而且通过减少资源争用而大大提高了并发 I&#x2F;O 操作的总量。</p>
<p>Dispatch I&#x2F;O APIs 在通道上操作（operate on channels）。每个通道管理一个文件描述符，作为流读取数据或者允许内容的随机访问。当一个通道被创建时，它控制文件描述符直到以下情况之一发生：</p>
<ul>
<li>通道关闭</li>
<li>通道内所有的引用被释放</li>
<li>发生错误</li>
</ul>
<p>以下是如何为 STDIN 创建 dispatch channel：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_io_t stdinChannel = dispatch_io_create(DISPATCH_IO_STREAM, STDIN_FILENO, queue, ^(<span class="type">int</span> error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;stdin: (%d) %s&quot;</span>, error, strerror(error));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在从通道读取之前，重要的是根据所需的用例来调整它。使用 I&#x2F;O 的关键因素是确定处理数据的频率。你可以通过以下两种方式之一做到：</p>
<ul>
<li>累积等待一定量的数据</li>
<li>通过等待一定量的时间</li>
</ul>
<p>指定构成一定量有意义的数据可以通过设置一个低和高水位标记（low and high water mark） – 在调用 handler 之前收集的最小和最大的数据量实现。在读取 STDIN 的情况下，输入通常是交互式的，因此设置一个单字节的低水位是有意义的：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">dispatch_io_set_low_water(stdinChannel, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>虽然在此例中没有意义，但是相应的 <code>dispatch_io_set_low_water</code> 函数可以将其上限从默认的 <code>SIZE_MAX</code> 值降低到一个更合理的值，像解析通过 socket 大量数据的情况。</p>
<p>指定处理数据之间等待的时间间隔可以使用 <code>dispatch_io_set_interval</code> 函数来完成，它接收纳秒级分辨率的时间间隔。再一次，这不是一个来自 STDIN 非常合适的处理，但是这是一个非常好的方法，比如从外设捕获音频或者视频数据进行采样（Again, this isn’t a great ﬁt for processing from STDIN, but it would be a great approach for things like capturing audio or video data from a peripheral for sampling.）。</p>
<p>一旦一个通道配置完成，就可以开始读取数据：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">off_t offset = <span class="number">0</span>;          <span class="comment">// Ignored for stream</span></span><br><span class="line"><span class="built_in">UInt</span> length = SIZE_MAX;    <span class="comment">// Read until EOF</span></span><br><span class="line">dispatch_io_read(stdinChannel, offset, length, queue, ^(<span class="type">bool</span> done, dispatch_data_t date, <span class="type">int</span> error) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>数据也可以以类似的方式写入通道。使一个基本的 logging 工具为文件路径创建一个新的通道：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">dispatch_io_t fileChannel = dispatch_io_create_with_path(DISPATCH_IO_STREAM, <span class="string">&quot;/path/to/file&quot;</span>, O_RDONLY, <span class="number">0</span>, queue, ^(<span class="type">int</span> error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;file: (%d) %s&quot;</span>, error, strerror(error));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_io_read(stdinChannel, offset, length, queue, ^(<span class="type">bool</span> done, dispatch_data_t data, <span class="type">int</span> error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        dispatch_write(fileChannel, <span class="number">0</span>, data, queue, <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者，GCD 还提供 <code>dispatch_read</code> 和 <code>dispatch_write</code>，它们是为 <code>dispatch_io_read</code> 和 <code>dispatch_io_write</code> 构建的简便方法用于简单一次性的 I&#x2F;O 操作，</p>
<h1 id="0x08-Data"><a href="#0x08-Data" class="headerlink" title="0x08 Data"></a>0x08 Data</h1><p>第一次介绍时，dispatch 数据对象在 Apple 的 SDKs 中是唯一的，作为一个连续和非连续数据容器。主要的含义是两个数据对象可以在恒定的时间联系起来，而不必复制到单个连续段内。从 iOS 7 和 OS X 10.9 开始，<code>NSData</code> 添加了对非连续访问的支持，以及来自 <code>dispatch_data_t</code> 对象的单向转换。</p>
<p>也许最好理解 dispatch data 的方法是说它在底层 C 接口中具有所有 <code>NSData</code> 的简便性。</p>
<p><code>dispatch_data_create</code> 从一个缓冲区（buffer）构造了一个 dispatch data 对象：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">size_t length;</span><br><span class="line"><span class="type">void</span> *buffer = malloc(length);</span><br><span class="line">dispatch_data_t data = dispatch_data_create(buffer, length, <span class="literal">NULL</span>, DISPATCH_DATA_DESTRUCTOR_DEFAULT);</span><br><span class="line">free(buffer);</span><br></pre></td></tr></table></figure>

<p>它甚至能够通过传递析构函数 <code>DISPATCH_DATA_DESTRUCTOR_FREE</code> 来自动调用 <code>free</code> 函数。</p>
<p><code>dispatch_data_create_concat</code> 可以通过联系两个已存在的对象创建一个新的 dispatch data 对象：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">dispatch_data_t first, second;</span><br><span class="line">dispatch_data_t combined = dispatch_data_create_concat(first, second);</span><br></pre></td></tr></table></figure>

<p>使用这个，并利用 NSData 中新的 <code>enumerateByteRangesUsingBlock:</code> 方法，可以创建一个函数来从 <code>NSData</code> 构造一个 dispatch data 对象（然而框架提只提供了 <code>NSData</code> 的 <code>dispatch_data_t</code>）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">dispatch_data_t dispatch_data_create_with_nsdata(<span class="built_in">NSData</span> *data) &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    __block dispatch_data_t container;</span><br><span class="line">    [data enumerateByteRangesUsingBlock:^(<span class="keyword">const</span> <span class="type">void</span> *bytes, <span class="built_in">NSRange</span> byteRange, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (container) &#123;</span><br><span class="line">            dispatch_data_t region = dispatch_data_create(bytes, byteRange.length, queue, DISPATCH_DATA_DESTRUCTOR_DEFAULT);</span><br><span class="line">            container = dispatch_data_create_concat(container, region);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GCD 中相当于 <code>NSData</code> 的 <code>- enumerateByteRangesUsingBlock:</code> 是 <code>dispatch_data_apply</code>，它为 container 中包含的每个内存区域（memory region）执行一个 block：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">dispatch_data_apply(data, ^(dispatch_data_t region, size_t offset, <span class="keyword">const</span> <span class="type">void</span> *buffer, size_t size) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者，当与在单个连续缓冲区（a single, contiguous buffer）上操作的调用交互的时候，请使用 <code>dispatch_data_create_map</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *buffer;</span><br><span class="line">size_t length;</span><br><span class="line">dispatch_data_create_map(data, &amp;buffer, &amp;length);</span><br></pre></td></tr></table></figure>

<h1 id="0x09-Debugging"><a href="#0x09-Debugging" class="headerlink" title="0x09 Debugging"></a>0x09 Debugging</h1><p>从 iOS 6.0 和 OS X 10.8 开始，GCD 类型是完整的 NSObject 子类，响应 <code>- debugDescription</code> 方法。这意味着在 lldb 中执行 <code>po</code> 将会返回有用的诊断输出信息，例如：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&lt;OS_dispatch_queue_root:</span><br><span class="line">  com.apple.root.default-priority[<span class="number">0x2024100</span>] = &#123;</span><br><span class="line">      xrefcnt = <span class="number">0x80000000</span>,</span><br><span class="line">      refcnt = <span class="number">0x80000000</span>,</span><br><span class="line">      suspend_cnt = <span class="number">0x0</span>,</span><br><span class="line">      locked = <span class="number">1</span>,</span><br><span class="line">      target = [<span class="number">0x0</span>],</span><br><span class="line">      width = <span class="number">0x7fffffff</span>,</span><br><span class="line">      running = <span class="number">0x1</span>,</span><br><span class="line">      barrier = <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h1 id="0x0A-Benchmarking"><a href="#0x0A-Benchmarking" class="headerlink" title="0x0A Benchmarking"></a>0x0A Benchmarking</h1><p><code>dispatch_benchmark</code> 是 libdispatch 的一部分，但不是公开可用的。要想使用，必须重新声明：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">uint64_t dispatch_benchmark(size_t count, <span class="type">void</span> (^block)(<span class="type">void</span>));</span><br></pre></td></tr></table></figure>

<p><code>dispatch_benchmark</code> 执行一个指定次数的 block，然后返回执行的平均运行时间（以纳秒为单位）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">size_t <span class="keyword">const</span> objectCount = <span class="number">1000</span>;</span><br><span class="line">uint64_t n = dispatch_benchmark(<span class="number">10000</span>, ^&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        ib obj = @<span class="number">42</span>;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; objectCount; ++i) &#123;</span><br><span class="line">            [array addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;- [NSMutableArray addObject:] : %llu ns&quot;</span>, n);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>GCD</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Inter-Process Communication</title>
    <url>/2016/10/31/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter6-Inter-Process-Communication/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac0bb2ad13.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 6 Inter-Process Communication 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-进程间通信（Inter-Process-Communication）"><a href="#0x01-进程间通信（Inter-Process-Communication）" class="headerlink" title="0x01 进程间通信（Inter-Process Communication）"></a>0x01 进程间通信（Inter-Process Communication）</h1><p>指导叙事已经通过历史的幸运机遇将技术融合在一起，创造出比以往更好的东西。而且，虽然 Apple 的技术栈在很多方面都是如此，但是进程间通信是一个突出的反例。</p>
<p>不充分利用每个时刻可用的解决方案，而是有点堆积起来。结果，一小部分重叠，互相不兼容的 IPC 技术散步在各种抽象层上。</p>
<ul>
<li>Mach Ports</li>
<li>Distributed Notifications</li>
<li>Distribued Objects</li>
<li>AppleEvents &amp; AppleScript</li>
<li>Pasteboard</li>
<li>XPC</li>
</ul>
<p>从低级内核抽象到高级内核抽象，面向对象 APIs，他们都有特定的性能和安全特性。但从根本上来说，它们都是从上下文边界之外发送和接收数据的机制。</p>
<h1 id="0x02-Mach-Ports"><a href="#0x02-Mach-Ports" class="headerlink" title="0x02 Mach Ports"></a>0x02 Mach Ports</h1><p>所有的进程间通信最终都是依赖 Mach kernel APIs 提供的功能。</p>
<p>Mach ports 轻量，功能强大，但是文档很少（有多么少？最新的权威资源是一个 1990 年左右的 Mach 3.0 PostScript 文件，放在卡内基梅隆大学 FTP 服务器上），直接使用不方便（有多不方便？哦，请看下面的代码）。</p>
<p>通过给定的 Mach port（端口）发送一个消息实质上是一个 <code>mach_msg_send</code> 调用，但是它需要一些配置才能构建要发送的消息：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">natural_t data;</span><br><span class="line">mach_port_t port;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    mach_msg_header_t header;</span><br><span class="line">    mach_msg_body_t body;</span><br><span class="line">    mach_msg_type_descriptor_t type;</span><br><span class="line">&#125; message;</span><br><span class="line"></span><br><span class="line">message.header = (mach_msg_header_t) &#123;</span><br><span class="line">    .msgh_remote_port = port,</span><br><span class="line">    .msgh_local_port = MACH_PORT_NULL,</span><br><span class="line">    .msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>),</span><br><span class="line">    .msgh_size = <span class="keyword">sizeof</span>(message)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message.body = (mach_msg_body_t) &#123;</span><br><span class="line">    .msgh_descriptor_count = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message.type = (mach_msg_type_descriptor_t) &#123;</span><br><span class="line">    .pad1 = data,</span><br><span class="line">    .pad2 = <span class="keyword">sizeof</span>(data)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mach_msg_return_t error = mach_msg_send(&amp;message.header);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error = MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接收端的事情就更容易一点了，因为消息只需要被声明，而不需要初始化：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">mach_port_t port;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    mach_msg_header_t header;</span><br><span class="line">    mach_msg_body_t body;</span><br><span class="line">    mach_msg_type_descriptor_t type;</span><br><span class="line">    mach_msg_trailer_t trailer;</span><br><span class="line">&#125; message;</span><br><span class="line"></span><br><span class="line">mach_msg_return_t error = mach_msg_receive(&amp;message.header);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error == MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    natural_t data = messahe.type.pad1;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>幸运的是，Core Foundation 和 Foundation 提供了更高级的 Mach ports APIs。<code>CDMachPort / NSMachPort</code> 是在可以用作 runloop 源的内核 APIs 之上的封装器（wrappers），而 <code>CFMessagePort / NSMessagePort</code> 便于两个端口（ports）之间的同步通信。</p>
<p><code>CFMessagePort</code> 实际上对于简单的一对一通信是相当不错的。几行代码，一个本地命名端口就可以作为 runloop 源附加，以便于在每次接收到消息的时候都会有一个回调（callback）运行。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">CFDataRef</span> Callback(<span class="built_in">CFMessagePortRef</span> port,</span><br><span class="line">                          SInt32 messageID,</span><br><span class="line">                          <span class="built_in">CFDataRef</span> data,</span><br><span class="line">                          <span class="type">void</span> *info) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFMessagePortRef</span> localPort = <span class="built_in">CFMessagePortCreateLocal</span>(<span class="literal">nil</span>, <span class="built_in">CFSTR</span>(<span class="string">&quot;com.example.app.port.server&quot;</span>), Callback, <span class="literal">nil</span>, <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopSourceRef</span> runLoopSource = <span class="built_in">CFMessagePortCreateRunLoopSource</span>(<span class="literal">nil</span>, localPort, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), runLoopSource, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>

<p>发送数据也很简单。只需指定远程端口，消息 payload，发送和接收的超时时间。<code>CFMessagePortSendRequest</code> 负责其余部分：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFDataRef</span> data;</span><br><span class="line">SInt32 messageID = <span class="number">0x1111</span>; <span class="comment">// Arbitrary</span></span><br><span class="line"><span class="built_in">CFTimeInterval</span> timeout = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFMessagePortRef</span> remotePort = <span class="built_in">CFMessagePortCreateRemote</span>(<span class="literal">nil</span>, <span class="built_in">CFSTR</span>(<span class="string">&quot;com.example.app.port.client&quot;</span>));</span><br><span class="line"></span><br><span class="line">SInt32 status = <span class="built_in">CFMessagePortSendRequest</span>(remotePort, messageID, data, timeout, timeout, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status == kCFMessagePortSuccess) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x03-Distributed-Notifications"><a href="#0x03-Distributed-Notifications" class="headerlink" title="0x03 Distributed Notifications"></a>0x03 Distributed Notifications</h1><p>在 Cocoa 中有很多种对象相互通信的方式：</p>
<p>当然，直接发送消息。还有 target-action，delegate（委托）, callback（回调），它们都是解耦的，一对一的设计模式。KVO 允许多个对象订阅（subscribe）事件， 但是它并不是解耦的，而是强联系（strongly couples）。另一方面，通知（Notifications）允许消息被全局广播（broadcast），并且可以被已知的监听对象拦截。</p>
<p>每个应用管理其自己的用于基础应用程序发布与订阅（pub-sub）的 <code>NSNotificationCenter</code> 实例。但是也有一些鲜为人知的 Core Foundation API，<code>CFNotificationCenterGetDistributedCenter</code> 允许通知在系统范围内进行通信。</p>
<p>要监听通知，可以通过指定要监听的通知名称来为分布式通知中心（distributed nitification canter）添加一个观察者，还有一个每次收到通知的时候要执行的函数指针：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> Callback(<span class="built_in">CFNotificationCenterRef</span> center,</span><br><span class="line">                     <span class="type">void</span> *observer,</span><br><span class="line">                     <span class="built_in">CFStringRef</span> name,</span><br><span class="line">                     <span class="keyword">const</span> <span class="type">void</span> *object,</span><br><span class="line">                     <span class="built_in">CFDictionaryRef</span> userInfo) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFNotificationCenterRef</span> distributedCenter = <span class="built_in">CFNotificationCenterGetDistributedCenter</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFNotificationSuspensionBehavior</span> = <span class="built_in">CFNitificationSuspensionBehaviorDeliverImmediately</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFNotificationCenterAddObserver</span>(distributedCenter, <span class="literal">NULL</span>, Callback, <span class="built_in">CFSTR</span>(<span class="string">&quot;notification.identifier&quot;</span>), <span class="literal">NULL</span>, behavior);</span><br></pre></td></tr></table></figure>

<p>发送一个分布式的通知甚至更简单；只需发布（post）标识符（identifier），对象（object）和用户信息（user info）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *object;</span><br><span class="line"><span class="built_in">CFDictionaryRef</span> userInfo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFNotificationCenterRef</span> distributedCenter = <span class="built_in">CFNotificationCenterGetDistributedCenter</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFNotificationCenterPostNotification</span>(distributedCenter, <span class="built_in">CFSTR</span>(<span class="string">&quot;notification.identifier&quot;</span>), object, userInfo, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>在链接两个应用的所有方法中，分布式通知（distributed notifications）是目前为止最简单的。使用它们发送较大的 payloads 不是一个好的主意，但是对于简单的任务，比如同步偏好设置或者触发一个数据获取，分布式通知是完美的。</p>
<p><img src="https://i.loli.net/2019/01/12/5c39b7528b19d.jpg"></p>
<h1 id="0x04-Distributed-Objects"><a href="#0x04-Distributed-Objects" class="headerlink" title="0x04 Distributed Objects"></a>0x04 Distributed Objects</h1><p>分布式对象（Distributed Objects，DO）是 Cocoa 的一个远程消息传递功能，它与 NeXT 的鼎盛时期是在上世纪 90 年代中期。虽然它没有被广泛使用，但是完全无摩擦的 IPC 的梦想（the dream of totally frictionless IPC）在我们现代技术栈中仍然没有实现。</p>
<p>声明一个 DO 对象只需设置一个 <code>NSConnection</code> 并且给它注册一个特定的名字：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Protocol</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">id</span> &lt;Protocol&gt; vendedObject;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSConnection</span> *connection = [[<span class="built_in">NSConnection</span> alloc] init];</span><br><span class="line">[connection setRootObject:vendedObject];</span><br><span class="line">[connection registerName:<span class="string">@&quot;server&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>然后另一个应用将创建一个为该同一注册名称注册的 connection，并立即获取一个原子代理（atomic proxy），它的功能就像是原始对象：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> proxy = [<span class="built_in">NSConnection</span> rootProxyForConnectionWithRegisteredName:<span class="string">@&quot;server&quot;</span> host:<span class="literal">nil</span>];</span><br><span class="line">[proxy setProtocolForProxy:<span class="class"><span class="keyword">@protocol</span>(<span class="title">Protocol</span>)];</span></span><br></pre></td></tr></table></figure>

<p>每当一个分布式对象代理被消息传递时，将通过 <code>NSConnection</code> 创建一个远程程序调用（Remote Procedure Call, RPC），以针对被声明的对象来评估消息并将结果返回到 proxy（在幕后（Behind the scenes），一个有操作系统管理的共享 <code>NSPortNameServer</code> 实例负责连接（hooking up）已命名的连接（connections））。</p>
<p>分布式对象是简单的，透明和健壮的。</p>
<p>实际上，分布式对象不能像本地对象一样使用，要是因为发送到 proxy 的任何消息可能导致抛出异常就好了。不像其他的语言，Objective-C 不使用异常来控制流（control flow）。因此，在 <code>@try/@catch</code> 中包含的所有内容对于 Cocoa 的约定来说是不合适的。</p>
<p>DO 也因为其他一些原因很笨拙。当尝试在一个 connection 上编组值（marshal values）时，对象和原语（primitives）之间的分隔尤其明显。此外，connections 是完全未加密的，并且对于底层通信信道（underlying communication channels）的缺乏可扩展性使其成为一个使用非常严重的处理断路器（deal-breaker）。</p>
<p>所有这些实际上是通过 Distributed Objects 指定代理行为（proxying behavior）的属性和方法参数注释使用的痕迹：</p>
<ul>
<li><code>in</code>：参数只作输入用，不会引用（Argument is used as input, but not referenced later）</li>
<li><code>out</code>：参数通过引用用于返回一个值（Argument is used to return a value by reference）</li>
<li><code>inout</code>：参数通过引用用于输入和返回（Argument is used as input and returned by reference）</li>
<li><code>const</code>：参数是常量（Argument is constant）</li>
<li><code>oneway</code>：返回无阻塞结果（Return without blocking for result）</li>
<li><code>bycopy</code>：返回一个对象的副本（Return a copy of the object）</li>
<li><code>byref</code>：返回一个对象的 proxy（Return a proxy of the object）</li>
</ul>
<h1 id="0x05-AppleEvents-amp-AppleScript"><a href="#0x05-AppleEvents-amp-AppleScript" class="headerlink" title="0x05 AppleEvents &amp; AppleScript"></a>0x05 AppleEvents &amp; AppleScript</h1><p>AppleEvents 是经典的 Macintosh 操作系统中最久的遗产。在系统 7 中引入，AppleEvents 允许使用 AppleScript 本地控制 apps，或者使用一个功能叫 Program Linking 远程控制。到目前为止，使用 Cocoa 脚本桥（Cocoa Scripting Bridge）的 AppleScript 仍然是以程序方式与 OS X 应用程序交互的最直接的方式。</p>
<p>也就是说，这很容易成为最奇怪的技术之一。</p>
<p>AppleScript 使用自然语言语法，旨在使非程序员更容易使用。虽然它以人类可理解的方式成功传达了意图，但是它编写起来是一个噩梦。</p>
<p>为了更好地理解，下面介绍下如何让 Safari 在最前面的窗口的活动标签中打开一个 URL：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;Safari&quot;</span></span><br><span class="line">  <span class="keyword">set</span> <span class="keyword">the</span> URL <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">front</span> document <span class="keyword">to</span> <span class="string">&quot;http://nshipster.com&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br></pre></td></tr></table></figure>

<p>在许多方面，AppleScript 的自然语言语法比一个资产更负责任（more of a liability than an asset）。英语，就像任何其他口头语言，在正常构造中具有大量的冗余和歧义。虽然这对于人类来说是完全可以接受的，但是所有这些是计算机难以解决的。</p>
<p>即使对于一个经验丰富的 Objective-C 开发者，没有经常参考文档或者示例代码几乎是不可能编写 AppleScript 的。</p>
<p>幸运的是，Scripting Bridge 为 Cocoa 应用程序提供了一个适当编程接口。</p>
<h1 id="0x06-Cocoa-Scripting-Bridge"><a href="#0x06-Cocoa-Scripting-Bridge" class="headerlink" title="0x06 Cocoa Scripting Bridge"></a>0x06 Cocoa Scripting Bridge</h1><p>为了通过 Scripting Bridge 与一个应用程序交互，必须先生成编程接口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sdef /Applications/Safari.app | sdp -fh --<span class="built_in">basename</span> Safari</span><br></pre></td></tr></table></figure>

<p><code>sdef</code> 为应用程序生成脚本定义文件。这些文件然后可以通过管道传输到 <code>sdp</code> 以转换为另一种格式 —— 在这种情况下，一个 C 头文件（C header）。然后可以添加生成的 <code>.h</code> 文件并 <code>#import</code> 到一个项目里，以获得该应用程序的第一等（first-class）对象接口。</p>
<p>下面是和以前一样的例子，使用 Cocoa Scripting Bridge 表示：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Safari.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SafariApplication *safari = [SBApplication applicationWithBundleIdentifier:<span class="string">@&quot;com.appli.Safari&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (SafariWindow *window <span class="keyword">in</span> safari.windows) &#123;</span><br><span class="line">    <span class="keyword">if</span> (window.visible) &#123;</span><br><span class="line">        window.currentTab.URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;http://nshipster.com&quot;</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比 AppleScript，这个更冗长一点，但是这个更容易集成到现有的代码库里。也更清楚地了解同样的代码如何适应轻微的不同的行为（虽然这可能只是更熟悉 Objective-C 的效果）。</p>
<p>唉，AppleScript 的关注似乎在下降，因为发布的 OS X 和 iWork 应用程序极大地削弱了它们的脚本化（scriptability）。在这一点上，在你自己的应用程序中添加支持可能不太值得。</p>
<h1 id="0x07-Pasteboard"><a href="#0x07-Pasteboard" class="headerlink" title="0x07 Pasteboard"></a>0x07 Pasteboard</h1><p>粘贴板（Pasteboard）是 OS X 和 iOS 上最明显的进程间通信机制。每当用户在应用程序之间复制或粘贴一段文本，一张图像，或者一个文档时，通过 <code>com.apple.pboard</code> 服务来调解从一个进程到另一个进程的数据交换。</p>
<p>在 OS X 上有 <code>NSPasteBoard</code>，在 iOS 上有 <code>UIPasteboard</code>。他们几乎是一样的，虽然像大多数同行（counterparts），iOS 提供了一个更干净，更现代的 API，比 OS X 上功能略少。</p>
<p>以代码的方式写入 Pasteboard 几乎和在 GUI 应用程序中调用<code>编辑（Edit）&gt; 复制（Copy）</code> 一样简单：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSImage</span> *image;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSPasteboard</span> *pasteboard = [<span class="built_in">NSPasteboard</span> generalPasteboard];</span><br><span class="line">[pasteboard clearContents];</span><br><span class="line">[pasteboard writeObjects:@[image]];</span><br></pre></td></tr></table></figure>

<p>相互的粘贴操作更复杂一点，需要迭代 Pasteboard 的内容：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSPasteboard</span> *pasteboard = [<span class="built_in">NSPasteboard</span> generalPasteboard];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([pasteboard canReadObjectForClasses:@[[<span class="built_in">NSImage</span> <span class="keyword">class</span>]] options:<span class="literal">nil</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *contents = [pasteboard readObjectsForClasses:@[[<span class="built_in">NSImage</span> <span class="keyword">class</span>]] options:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSImage</span> *image = [contents firstObject];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么使得 Pasteboard 作为传输数据的机制特别引人注目的是同时提供了复制到粘贴板上的多个表示（representations）的内容的概念。例如，一段选择的文本可以被复制为富文本（rich text， RTF）和纯文本（TXT）两种，允许例如 WYSIWYG（所见即所得，What you see is what you get） 编辑器通过抓取富文本表示来保留样式信息，以及代码编辑器仅使用纯文本表示。</p>
<p>甚至可以通过遵循 <code>NSPasteboardItemDataProvider</code> 协议在按需的基础上提供这些表示。这允许仅在必要时生成诸如来自富文本的纯文本的派生表示。</p>
<p>每个表示都被一个唯一类型标识符（Unique Type Identifier, UTI）标识，该概念在下一章中更详细地讨论。</p>
<h1 id="0x08-XPC"><a href="#0x08-XPC" class="headerlink" title="0x08 XPC"></a>0x08 XPC</h1><p>XPC 是 SDK 中最先进的进程间通信。它的架构目标是避免长时间允许的进程，以适应可用的资源，并尽可能延迟地初始化。将 XPC 结合到应用程序里面的动机不是为了做不可能的事情，而是为进程间通信提供更好的特权分离和故障隔离。</p>
<p>它是 <code>NSTask</code> 的替代品，并且还有更多。</p>
<p>2011 年推出的 XPC 为 OS X 上的 App Sandbox，iOS 上的远程视图控制器（Remote View Controllers）和应用扩展提供基础架构。它也被系统框架和第一方应用（first-party）广泛使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find /Applications -name \*.xpc</span><br></pre></td></tr></table></figure>

<p>通过调查 XPC 服务，可以更好地理解在自己的应用程序中使用 XPC 的时机。在应用程序中经常出现的主题，像图像和视频转换服务，系统调用，webservice 集成和第三方认证。</p>
<p>XPC 负责进程间通信和 service 生命周期管理。从注册 service，运行它和与其他 service 通信的一切都由 <code>launchd</code> 处理。一个 XPC service 可以根据需要启动，或者如果它们崩溃则重新启动，又或者如果空闲则终止。因此，service 应该被设计为完全无状态的，以便允许在任何执行点都能突然终止。</p>
<p>作为 iOS 采用并移植到 OS X 的新安全模式的一部分，XPC 服务在默认的情况下允许在最受限制的环境中：没有文件系统访问，没有网络访问，没有 root 权限提升。任何功能必须由一个授权集列入白名单。</p>
<p>XPC 可以通过 <code>libxpc</code> C API 或者 <code>NSXPCConnection</code> Objective-C API 访问（虽然应该总是尝试使用可用于完成特定任务的最高级的 API，本书在标题中有 “Low-Level” 这个词，因此本节中的示例将使用 <code>libxpc</code>）。</p>
<p>XPC 服务驻留在一个应用程序 bundle 中，或者通过 launchd 在后台运行。</p>
<p>服务调用 <code>xpc_main</code> 和一个事件处理程序来接收新 XPC 连接：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> connection_handler(xpc_connection_t peer) &#123;</span><br><span class="line">    xpc_connection_set_event_handler(peer, ^(xpc_object_t event) &#123;</span><br><span class="line">        peer_event_handler(peer, event);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    xpc_connection_resume(peer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    xpc_main(connection_handler);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 XPC connection 是一对一的，这意味着这个 service 在不同的连接上运行，每次调用 <code>xpc_connection_create</code> 都会创建一个新的对等体（这类似于 BSD sockets API 中的 <code>accept</code>，服务器监听单个文件描述符（file descriptor），为每个入站连接创建额外的描述符）。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">xpc_connection_t c = xpc_connection_create(<span class="string">&quot;com.example.service&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">xpc_connection_set_event_handler(c, ^(xpc_object_t event) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">xpc_connection_resume(c);</span><br></pre></td></tr></table></figure>

<p>当通过一个 XPC connection 发送消息时，它会自动被派发（dispatched）到一个由 runtime 管理的队列上。一旦 connection 在远程端被打开，消息就出队（dequeued）并发送。</p>
<p>每个消息都是一个字典（dictionary），具有字符串键（keys）和强类型值（strongly-typed values）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">xpc_dictionary_t message = xpc_dictionary_create(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">xpc_dictionary_set_uint64(message, <span class="string">&quot;foo&quot;</span>, <span class="number">1</span>);</span><br><span class="line">xpc_connection_send_message(c, message);</span><br><span class="line">xpc_release(message);</span><br></pre></td></tr></table></figure>

<p>XPC 对象对一下基本类型进行操作：</p>
<ul>
<li>Data</li>
<li>Boolean</li>
<li>Double</li>
<li>String</li>
<li>Signed Integer</li>
<li>Unsigned Integer</li>
<li>Date</li>
<li>UUID</li>
<li>Array</li>
<li>Dictionary</li>
<li>Null</li>
</ul>
<p>XPC 提供了一个简便的方法从 <code>dispatch_data_t</code> 数据类型转换，这简化了从 GCD 到 XPC 的工作流：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *buffer;</span><br><span class="line">size_t length;</span><br><span class="line">dispatch_data_t ddata = dispatch_data_create(buffer, length, DISPATCH_TARGET_QUEUE_DEFAULT, DISPATCH_DATA_DESTRUCTOR_MUNMAP);</span><br><span class="line"></span><br><span class="line">xpc_object_t xdata = xpc_data_create_with_dispatch_data(ddata);</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line">xpc_connection_send_message_with_reply(c, message, queue, ^(xpc_object_t reply) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xpc_get_type(event) == XPC_TYPE_DICTIONARY) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="0x09-Registering-Services"><a href="#0x09-Registering-Services" class="headerlink" title="0x09 Registering Services"></a>0x09 Registering Services</h1><p>XPC 还可以注册为 launchd 来用，配置为匹配 IOKit 事件自动启动，BSD 通知或者 CFDistributedNotifications。这些标准在 service 的 <code>launchd.plist</code> 文件中指定：</p>
<p>launchd.plist</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>LaunchEvents<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.iokit.matching<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.example.device-attach<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>idProduct<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">integer</span>&gt;</span>2794<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>idVendor<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">integer</span>&gt;</span>725<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>IOProviderClass<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>IOUSBDevice<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>IOMatchLaunchStream<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProcessType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>Adaptive<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>launchd</code> 属性列表最近添加的是 <code>ProcessType</code> key，高级描述了启动代理（launch agent）的预期目的。基于规定的竞争行为，操作系统将相应地自动地调节 CPU 和 I&#x2F;O 带宽。</p>
<p style="text-align: center;">Process Types and Contention Behavior</p>

<table>
<thead>
<tr>
<th>Standart</th>
<th>Default value</th>
</tr>
</thead>
<tbody><tr>
<td>Adaptive</td>
<td>Contend with apps when doing work on their behalf</td>
</tr>
<tr>
<td>Background</td>
<td>Never contend with apps</td>
</tr>
<tr>
<td>Interactive</td>
<td>Always contend with apps</td>
</tr>
</tbody></table>
<p>要注册一个 service 去大约每 5 分钟运行一次（允许一个系统资源的宽限期在以更积极的优先级调度之前变得更可用），一组标准被传递到 <code>xpc_activity_register</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">xpc_object_t criteria = xpc_dictionary_create(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">xpc_dictionary_set_int64(criteria, XPC_ACTIVITY_INTERVAL, <span class="number">5</span> * <span class="number">60</span>);</span><br><span class="line">xpc_dictionary_set_int64(criteria, XPC_ACTIVITY_GRACE_PERIOD, <span class="number">10</span> * <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">xpc_activity_register(<span class="string">&quot;com.example.app.activity&quot;</span>, criteria, ^(xpc_activity_t activity) &#123;</span><br><span class="line">    <span class="comment">// Process Data</span></span><br><span class="line">    </span><br><span class="line">    xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_CONTINUE);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// Update UI</span></span><br><span class="line">        </span><br><span class="line">        xpc_activity_set_state(activity, XPC_ACTIVITY_STATE_DONE);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>IPC</tag>
        <tag>Pasteboard</tag>
        <tag>Service</tag>
        <tag>Connection</tag>
        <tag>XPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Core Services</title>
    <url>/2016/11/02/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter7-Core-Services/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac0d15f050.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 7 Core Services 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-Core-Services"><a href="#0x01-Core-Services" class="headerlink" title="0x01 Core Services"></a>0x01 Core Services</h1><p>让我们花一点时间来真正地思考一下一个文件是什么。</p>
<p>从根本上来说，文件是一个信息资源。它以这样一种方式持续存在，即它在最初创建它的程序的范围之外保持持久可用。文件本身通常被编码成一维字节数组（one-dimensional byte array），理想地，在存储介质连续的部分中。</p>
<p>文件本身是无意义的 0 和 1。只有通过程序读和写，它们才是有意义的。</p>
<p>交换格式（特别是图像编码，如 PNG，GIF 和 JPEG）的一种常见做法是在文件开头使用一个唯一值，也称为文件签名或者“魔术数字”。关于一个文件的信息，例如其名称，大小和其他属性由文件系统存储为元数据（metadata）。从文件读取的程序使用它来确定如何解析和解释文件的数据。</p>
<p>这种信息如何被结构化和编码是文件系统的主要不同因素之一。</p>
<h1 id="0x02-Data-amp-Resource-Forks"><a href="#0x02-Data-amp-Resource-Forks" class="headerlink" title="0x02 Data &amp; Resource Forks"></a>0x02 Data &amp; Resource Forks</h1><p>旧式的 Apple Macintosh Filesystem（MFS）为每一个文件条目关联（associated）了一个 data fork，resource fork 和多个 named forks。对于应用程序，data fork 将保存二进制可执行文件，而 resource fork 将包含图标位图和本地化字符串等内容。不是所有的文件都有 resource forks，但是它们对于将内容从表示（presentation）分离很有用，就像在字处理文档中一样。</p>
<p>在 Mac OS 上，文件类型和创建者代码（creator codes）由一个 <code>OSType</code> 表示，一个四字节标识符，最常被编码为四个 ASCII &#x2F; Macintosh 罗马字符。文件类型的常见示例如下所示：</p>
<p style="text-align: center;">OSType of Common File Types</p>

<table>
<thead>
<tr>
<th>CODE</th>
<th>Executable Binary</th>
</tr>
</thead>
<tbody><tr>
<td>Text</td>
<td>Plain Text</td>
</tr>
<tr>
<td>PICT</td>
<td>QuickDraw Image</td>
</tr>
<tr>
<td>SND</td>
<td>Sound</td>
</tr>
</tbody></table>
<p><code>OSType</code> 还用于表示粘贴板内容的类型，错误代码和 AppleEvents，System 7 中引入的进程间通信机制。</p>
<p>实际上，最后一点关于 <code>OSType</code> 被重用的任务（tasks），如处理应用程序之间复制-粘贴（copy-paste）引起的一个有趣的观点：文件只是数据传递的多种方式之一。</p>
<p>一个这样的例子是通过互联网下载的信息。</p>
<p>在如今的应用中完成的绝大多数网络都是通过 HTTP。虽然资源的类型有时候可能从 URI 的扩展中收集，但是规范标识符要在 <code>Content-Type</code> HTTP 头部字段（HTTP header field）中找到。此标头（header）的值使用 MIME 类型。MIME 类型是由中央管理机构定义的，互联网号码分配机构（The Internet Assigned Numbers Authority, IANA）也管理根名称服务器（root name servers）和 IP 地址块（IP address blocks）。</p>
<p>因此，任何取代 <code>OSType</code> 的系统都必须能够容纳互联网媒体以及现有的文件类型。</p>
<p>改系统是通用类型标识符（Universal Type Identifiers, UTI），并且它已被 OS X 引入。</p>
<h1 id="0x03-UTI"><a href="#0x03-UTI" class="headerlink" title="0x03 UTI"></a>0x03 UTI</h1><p>UTI 提供了一个可扩展的层次化分类系统，可以提供开发者在处理即使非常奇葩的文件类型时极大的灵活性。例如，一个 Ruby 源文件（.rb）被分类为 “Ruby Source Code &gt; Source Code &gt; Text &gt; Content &gt; Data”；一个 QuickTime 视频文件（.mov）被分类为 “Video &gt; Movie &gt; Audiovisual Content &gt; Content &gt; Data”。</p>
<p>不限于文件，UTI 可以用于识别一些不同的实体（entities）：</p>
<ul>
<li>文件（Files）</li>
<li>目录（Directories）</li>
<li>粘贴板数据（Pasteboard Data）</li>
<li>包（Bundles）</li>
<li>框架（Frameworks）</li>
<li>互联网媒体（Internet Media）</li>
<li>流数据（Streaming Data）</li>
<li>别名和符号链接（Aliases and Symbolic Links）</li>
</ul>
<h1 id="0x04-Type-Identifiers"><a href="#0x04-Type-Identifiers" class="headerlink" title="0x04 Type Identifiers"></a>0x04 Type Identifiers</h1><p>公共域（The public domain）保留对大多数应用程序通用的常用或标准类型，例如：</p>
<ul>
<li>public.text</li>
<li>public.plain-text</li>
<li>public.jpeg</li>
<li>public.html</li>
</ul>
<h1 id="0x05-Dynamic-Type-Identifiers"><a href="#0x05-Dynamic-Type-Identifiers" class="headerlink" title="0x05 Dynamic Type Identifiers"></a>0x05 Dynamic Type Identifiers</h1><p>有时一个数据类型没有为其声明 UTI。UTI 通过创建一个动态的标识符来透明地处理这种情况。动态标识符（Dynamic Identifiers）具有域 <code>dyn</code>（domain dyn），字符串后面其余部分是不透明的。它们可以被认为是一个 UTI 兼容封装器（UTI-compatible wrapper），有一个未知的文件名扩展，MIME 类型，OSType 等等。</p>
<h1 id="0x06-Custom-Type-Identifiers"><a href="#0x06-Custom-Type-Identifiers" class="headerlink" title="0x06 Custom Type Identifiers"></a>0x06 Custom Type Identifiers</h1><p>当创建一个自定义类型标识符时，目的是使 UTI 符合物理（a physical）和功能层次结构（functional hierarchy）：</p>
<ul>
<li>一个物理层次项目（item）的性质，例如它是一个文件还是一个目录。这应该继承自 <code>public.item</code>。</li>
<li>一个功能层次与如何使用项目（item）有关。这不应继承自 <code>public.item</code>，但是可以是像 <code>public</code> 这样的。<code>content</code> 或 <code>public.executable</code>。</li>
</ul>
<h1 id="0x07-Working-with-UTIs"><a href="#0x07-Working-with-UTIs" class="headerlink" title="0x07 Working with UTIs"></a>0x07 Working with UTIs</h1><p>OS X 上的 Core Services 框架和 iOS 上的 Mobile Core Services 框架提供了根据通用类型标识符通过文件扩展和 MIME 类型来识别和分类数据类型的功能。</p>
<h2 id="0x0701-Comparing"><a href="#0x0701-Comparing" class="headerlink" title="0x0701 Comparing"></a>0x0701 Comparing</h2><p>这里有两个比较 UTI 的方法。<code>UTTypeEqual</code> 执行相等判断，这相当于不区分大小的字符串比较。<code>UTTypeConforms</code> 则更深入一点，因为它查找功能和物理层次来找到一个匹配。这跟 <code>isMemberOfClass:</code> 和 <code>isKindOfClass:</code> 之间的区别一样。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">UTTypeConformsTo(<span class="built_in">CFSTR</span>(<span class="string">&quot;public.jpeg&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;public.item&quot;</span>)); <span class="comment">// YES</span></span><br><span class="line"></span><br><span class="line">UTTypeConformsTo(<span class="built_in">CFSTR</span>(<span class="string">&quot;public.jpeg&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;public.image&quot;</span>)); <span class="comment">// YES</span></span><br><span class="line"></span><br><span class="line">UTTypeEqual(<span class="built_in">CFSTR</span>(<span class="string">&quot;public.jpeg&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;public.image&quot;</span>)); <span class="comment">// NO</span></span><br><span class="line"></span><br><span class="line">UTTypeConformsTo(<span class="built_in">CFSTR</span>(<span class="string">&quot;public.jpeg&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;public.png&quot;</span>)); <span class="comment">// NO</span></span><br></pre></td></tr></table></figure>

<h2 id="0x0702-Copying-Declarations"><a href="#0x0702-Copying-Declarations" class="headerlink" title="0x0702 Copying Declarations"></a>0x0702 Copying Declarations</h2><p>除了其唯一标识符之外，每个 UTI 都注册了一个属性（attributes）的属性（property）列表。这些属性可以使用 <code>UTTypeCopyDeclaration</code> 来检索：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">UTTypeCopyDeclaration(<span class="built_in">CFSTR</span>(<span class="string">&quot;public.png&quot;</span>));</span><br><span class="line">&#123;</span><br><span class="line">    UTTypeConformsTo = <span class="string">&quot;public.image&quot;</span>;</span><br><span class="line">    UTTypeDescription = <span class="string">&quot;Portable Network Graphics image&quot;</span>;</span><br><span class="line">    UTTypeIdentifier = <span class="string">&quot;public.png&quot;</span>;</span><br><span class="line">    UTTypeTagSpecification = &#123;</span><br><span class="line">        <span class="string">&quot;com.apple.nspboard-type&quot;</span> = <span class="string">&quot;Apple PNG pasteboard type&quot;</span>;</span><br><span class="line">        <span class="string">&quot;com.apple.ostype&quot;</span> = PNGF;</span><br><span class="line">        <span class="string">&quot;public.filename-extension&quot;</span> = png;</span><br><span class="line">        <span class="string">&quot;public.mime-type&quot;</span> = <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x0703-Converting"><a href="#0x0703-Converting" class="headerlink" title="0x0703 Converting"></a>0x0703 Converting</h2><p>当使用 UTI 时，一个常见的任务是获取它们等效的 MIME 类型或者文件名扩展。这可以使用函数 <code>UTTypeCopyPreferredTagWithClass:</code> 来完成：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *contentType = (__bridge_transfer <span class="built_in">NSString</span> *)UTTypeCopyPreferredTagWithClass(<span class="built_in">CFSTR</span>(<span class="string">&quot;public.text&quot;</span>), kUTTagClassMIMEType);</span><br></pre></td></tr></table></figure>

<p> 相反，确定 UTI 的一个 MIME 类型，可以使用 <code>UTTypeCreatePreferredIdentifierForTag:</code> 来完成：</p>
 <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *UTI = (__bridge_transfer <span class="built_in">NSString</span> *)UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, <span class="built_in">CFSTR</span>(<span class="string">&quot;jpg&quot;</span>), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p><code>UTTypeCopyPreferredTagWithClass</code> &amp; <code>UTTypeCreatePreferredIdentifierForTag</code> 的 tag 类参数可以是以下任意字符串常量：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kUTTagClassFilenameExtension;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kUTTagClassMIMEType;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kUTTagClassNSPboardType; <span class="comment">// OS X</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kUTTagClassOSType; <span class="comment">// OS X</span></span><br></pre></td></tr></table></figure>

<p>作为调解数据和文件传输成长和发展格局的一种手段，UTI 做的非常好。从像 “魔法数字” 签名和 resource forks 的特定文件系统机制到提供应用程序极大的灵活性在如何处理数据形式化的类型层次结构的转变。</p>
<p>充分使用 UTI 将确保应用程序负责任地与文件交互，并与其他东西相处得好。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Core Service</tag>
        <tag>UTI</tag>
      </tags>
  </entry>
  <entry>
    <title>ImageIO</title>
    <url>/2016/11/02/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter8-ImageIO/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac0e0512af.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 8 ImageIO 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-ImageIO"><a href="#0x01-ImageIO" class="headerlink" title="0x01 ImageIO"></a>0x01 ImageIO</h1><p>Image I&#x2F;O 是一个强大的，虽然不太知名的图像处理框架。独立于 Core Graphics，它可以在许多不同格式之间读写，访问照片元数据，并执行常见的图像处理操作。这个框架提供了平台上最快的图像编码器和解码器，具有高级缓存机制，甚至能够增量地加载图像。</p>
<h1 id="0x02-Supported-Image-Types"><a href="#0x02-Supported-Image-Types" class="headerlink" title="0x02 Supported Image Types"></a>0x02 Supported Image Types</h1><p>根据官网文档，Image I&#x2F;O 支持 “大多数图像格式”。与其拿文档来看，还不如用代码的方式来获取。</p>
<p><code>CGImageSourceCopyTypeIdentifiers</code> 返回支持的图像类型的 UTI 列表：</p>
<p style="text-align: center;">Image I/O UTIs</p>

<table>
<thead>
<tr>
<th align="left">UTI</th>
<th align="center">iOS</th>
<th align="center">OS X</th>
</tr>
</thead>
<tbody><tr>
<td align="left">com.adobe.photoshop-image</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.adobe.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.apple.icns</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.apple.macpaint</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.apple.pict</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.apple.quicktime-image</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.canon.cr2-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.canon.crw-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.canon.tif-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.compuserve.gif</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.epson.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.fuji.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.hasselblad.3fr-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.hasselblad.fff-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.ilm.openexr-image</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.kodak.flashpix-image</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.kodak.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.konicaminolta.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.leafamerica.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.leica.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.leica.rwl-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.microsoft.bmp</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.microsoft.cur</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.microsoft.ico</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.nikon.nrw-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.nikon.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.olympus.or-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.olympus.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.olympus.sr-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.panasonic.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.panasonic.rw2-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.pentax.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.samsung.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.sgi.sgi-image</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.sony.arw-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.sony.raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.sony.sr2-raw-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">com.truevision.tga-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">public.jpeg</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">public.jpeg-2000</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">public.mpo-image</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">public.png</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">public.radiance</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">public.tiff</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="left">public.xbitmap-image</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
</tbody></table>
<p>事实证明，这似乎是 <em>大多数</em> 格式。至少是那些对现在应用程序重要的。普遍支持常见格式：TIFF，JPEG，GIF，PNG，RAW 和 Windows Bitmap，Icon 和 Cursor。另外，在 iOS 上支持多种供应商特定的 RAW 摄像机格式，不过 OS X 还支持其他几种格式。</p>
<h1 id="0x03-Writing-to-a-file"><a href="#0x03-Writing-to-a-file" class="headerlink" title="0x03 Writing to a file"></a>0x03 Writing to a file</h1><p>Image I&#x2F;O 提供了高级输出配置，不需要很多开销。</p>
<p>指定期望输出格式的 UTI 以及任何选项，如压缩质量，方向或是否忽略 Alpha 通道。为目标创建一个 <code>CGImageDestinationRef</code>，将 <code>CGImage</code> 添加到其中，然后进行最终化（finalized）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = ...;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@&quot;/path/to/output.jpg&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span> *UTI = <span class="string">@&quot;public.jpeg&quot;</span>;</span><br><span class="line"><span class="built_in">NSDictionary</span> *options = @&#123;</span><br><span class="line">    (__bridge <span class="type">id</span>)kCGImageDestinationLossyCompressionQuality : @(<span class="number">0.75</span>),</span><br><span class="line">    (__bridge <span class="type">id</span>)kCGImagePropertyOrientation : @(<span class="number">4</span>),</span><br><span class="line">    (__bridge <span class="type">id</span>)kCGImagePropertyHasAlpha : @(<span class="literal">NO</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageDestinationRef</span> imageDestinationRef = <span class="built_in">CGImageDestinationCreateWithURL</span>((__bridge <span class="built_in">CFURLRef</span>)fileURL, (__bridge <span class="built_in">CFStringRef</span>)UTI, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageDestinationAddImage</span>(imageDestinaRef, [image <span class="built_in">CGImage</span>], (__bridge <span class="built_in">CFDictionaryRef</span>)options);</span><br><span class="line"><span class="built_in">CGImageDestinationFinalize</span>(imageDestinationRef);</span><br><span class="line"><span class="built_in">CFRelease</span>(imageDestinationRef);</span><br></pre></td></tr></table></figure>

<h1 id="0x04-Reading-from-a-File"><a href="#0x04-Reading-from-a-File" class="headerlink" title="0x04 Reading from a File"></a>0x04 Reading from a File</h1><p>从一个文件中读取一张图像的过程也非常相似。</p>
<p>创建一个期望的输出文件的 file URL，并设置任何所需的缓存标记或图像类型提示。使用这个 URL 创建一个 <code>CGImageSourceRef</code>，然后调用 <code>CGImageSourceCreateImageAtIndex</code> 读取数据并创建一个 <code>CGImage</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@&quot;/path/to/input.jpg&quot;</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *options = @&#123;</span><br><span class="line">    (__bridge <span class="type">id</span>)kCGImageSourceTypeIdentifierHint : <span class="string">@&quot;public.jpeg&quot;</span>,</span><br><span class="line">    (__bridge <span class="type">id</span>)kCGImageSourceShouldCache : @(<span class="literal">YES</span>),</span><br><span class="line">    (__bridge <span class="type">id</span>)kCGImageSourceShouldAllowFloat : @(<span class="literal">YES</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageSourceRef</span> imageSourceRef = <span class="built_in">CGImageSourceCreateWithURL</span>((__bridge <span class="built_in">CFURLRef</span>)fileURL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGimageSourceCreateImageAtIndex</span>(imageSourceRef, <span class="number">0</span>, (__bridge <span class="built_in">CFDictionaryRef</span>)options);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRelease</span>(imageRef);</span><br><span class="line"><span class="built_in">CFRelease</span>(imageSourceRef);</span><br></pre></td></tr></table></figure>

<h1 id="0x05-Incrementally-Reading-an-Image"><a href="#0x05-Incrementally-Reading-an-Image" class="headerlink" title="0x05 Incrementally Reading an Image"></a>0x05 Incrementally Reading an Image</h1><p>前面的示例可以被扩展一下成为增量加载图像，这可以为加载特别大或远程图像提供一个更好的用户体验。</p>
<p>由于很多应用程序通过 HTTP 来加载图像，session task delegate 方法 <code>URLSession:dataTask:didReceiveData:</code> 是一个性能增益（performance gains）非常好的机会：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask disReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    [<span class="keyword">self</span>.mutableResponseData appendData:data];</span><br><span class="line">    <span class="built_in">CGImageSourceUpdateData</span>(<span class="keyword">self</span>.imageSourceRef, (__bridge <span class="built_in">CFDataRef</span>)<span class="keyword">self</span>.mutaleResponseData, [<span class="keyword">self</span>.mutableResponseData length][dataTask countOfBytesExoectedToReceive]); <span class="comment">// 原书这里的代码好像有点问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGSizeEqualToSize</span>(<span class="keyword">self</span>.imageSize, <span class="built_in">CGSizeZero</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *properties = (__bridge_transfer <span class="built_in">NSDictionary</span> *)<span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(<span class="keyword">self</span>.imageSourceRef, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span> *width = properties[(__bridge <span class="type">id</span>)kCGImagePropertyPixelWidth];</span><br><span class="line">            <span class="built_in">NSNumber</span> *height = properties[(__bridge <span class="type">id</span>)kCGImagePropertyPixelHeight];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (width &amp;&amp; height) &#123;</span><br><span class="line">                <span class="keyword">self</span>.imageSize = <span class="built_in">CGSizeMake</span>([width floatValue], [height floatValue]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(<span class="keyword">self</span>.imageSourceRef, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line">    <span class="built_in">CFRelease</span>(imageRef);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// delete or block callback to update with image</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定一个 <code>CGImageSourceRef</code>，它将会在请求开始加载时被初始化，这个 delegate 方法调用 <code>CGImageSourceUpdateData</code> 用响应数据缓冲区（response data buffer）更新。</p>
<p>如果已经加载了足够的数据来确定图像的最终尺寸，<code>CGImageSourceCopyPropertiesAtIndex</code> 可以检索该信息并对其进行高速缓存。从那时起，一个 delegate 或 block 回调将能够发送部分加载的图像以更新主线程上的 UI。</p>
<h1 id="0x06-Image-Metadata"><a href="#0x06-Image-Metadata" class="headerlink" title="0x06 Image Metadata"></a>0x06 Image Metadata</h1><p>在增量图像加载示例中，从其元数据中检索到图像的宽和高，以便可以正确地调整大小 – 即使在所有数据加载之前。</p>
<p>可以使用相同的方法检索图像元数据，诸如 GPS 数据（位置），相机 EXIF（透镜，曝光，快门速度等），或 IPTC（information suitable for publication，创作者和版权）。</p>
<p>元数据被分为几个不同的字典，可以用以下任意 key 来指定：</p>
<ul>
<li>kCGImagePropertyTIFFDictionary</li>
<li>kCGImagePropertyGIFDictionary</li>
<li>kCGImagePropertyJFIFDictionary</li>
<li>kCGImagePropertyExifDictionary</li>
<li>kCGImagePropertyPNGDictionary</li>
<li>kCGImagePropertyIPTCDitionary</li>
<li>kCGImagePropertyGPSDictionary</li>
<li>kCGImagePropertyCIFFDictionary</li>
<li>kCGImageProperty8BIMDictionary</li>
<li>kCGImagePropertyDNGDictionary</li>
<li>kCGImagePropertyExifAuxDictionary</li>
</ul>
<p>使用 Image I&#x2F;O 检索图像元数据属性是相当不言自明的：一个调用 <code>CGImageSourceCopyPropertiesAtIndex</code>，从此刻开始它是在 <code>CGImageProperty</code> keys 上所有标准 <code>NSDictionary</code> 访问（it’s all standard <code>NSDictionary</code> access on <code>CGImageProperty</code> keys from there on out）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *properties = (__bridge_transfer <span class="built_in">NSDictionary</span> *)<span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(<span class="keyword">self</span>.imageSourceRef, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *EXIF = properties[(__bridge <span class="type">id</span>)kCGImagePropertyExifDictionary];</span><br><span class="line"><span class="keyword">if</span> (EXIF) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *Fnumber = EXIF[(__bridge <span class="type">id</span>)kCGImagePropertyExifNumber];</span><br><span class="line">    <span class="built_in">NSString</span> *exposure = EXIF[(__bridge <span class="type">id</span>)kCGImagePropertyExifExposureTime];</span><br><span class="line">    <span class="built_in">NSString</span> *ISO = EXIF[(__bridge <span class="type">id</span>)kCGImagePropertyExifISOSpeedRatings];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Shot Information: %@ %@ %@&quot;</span>, Fnumber, exposure, ISO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *GPS = properties[(__bridge <span class="type">id</span>)kCGImagePropertyGPSDictionary];</span><br><span class="line"><span class="keyword">if</span> (GPS) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *latitude = GPS[(__bridge <span class="type">id</span>)kCGImagePropertyGPSLatitude];</span><br><span class="line">    <span class="built_in">NSString</span> *latitudeRef = GPS[(__bridge <span class="type">id</span>)kCGImagePropertyGPSLatitudeRef];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *longitude = GPS[(__bridge <span class="type">id</span>)kCGImagePropertyGPSLongitude];</span><br><span class="line">    <span class="built_in">NSString</span> *longitudeRef = GPS[(__bridge <span class="type">id</span>)kCGImagePropertyGPSLongitudeRef];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GPS: %@ %@ / %@ %@&quot;</span>, latitude, latitudeRef, longitude, longitudeRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerate</title>
    <url>/2016/11/03/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter9-Accelerate/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac0f1f3689.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> Chapter 9 Accelerate 时做的笔记。</p>
<span id="more"></span>

<h1 id="0x01-Accelerate"><a href="#0x01-Accelerate" class="headerlink" title="0x01 Accelerate"></a>0x01 Accelerate</h1><p>在过去的十年里，当涉及到硬件是，一直专注于以更少的方式做更多。</p>
<p>随着每一代微处理器推动着硅的物理极限，更多的重点放在以更少的方式做更多。摩尔定律，观察到可以安装到芯片上的晶体管的数量每 18 个月左右就翻一倍，会在某个时间停止，而且那个时间也很快接近。</p>
<p>与此同时，移动计算的崛起改变了其性能范式，强调电池寿命超过功率（over power）。</p>
<p>为了响应这两个新兴的现实，硬件制造商已经制造了多核 CPU，软件开发者已经学会了利用高并行和并发。</p>
<p>在 iOS 和 OS X 上，利用这些高级功能的最佳方法是 Accelerate 框架。</p>
<p>通过超过 2,000 个 API，Accelerate 很容易成为 iOS 和 OS X SDK 中最大的框架。但远不止大，它更像是一个伞框架（umbrella framework，使用苹果的术语，封装了其他框架的框架通常称为 umbrella framework），有几个互相关联的组件。</p>
<p>在顶层，Accelerate 可以在 vecLib &amp; vImage 之间分离。vecLib 包含用于数字信号处理（vDSP）以及矢量和矩阵运算的数据类型和 C 函数，包括线性代数包（Linear Algebra Package，LAPACK）和基础线性代数子程序（Basic Linear Algebra Subprograms，BLAS）标准涵盖的那些。vImage 包含一个广泛的图像操作功能，包括 alpha 合成，转换（conversion），卷积（convolution），形态（morphology），变换（transformation）和直方图（histogram）生成。</p>
<p>学习使用 Accelerate 只是在 API 数量方面可以是压倒性的。对于任何没有数学或高性能计算背景的人来说，仅概念理解就足够吓跑很多人。</p>
<h1 id="0x02-SIMD"><a href="#0x02-SIMD" class="headerlink" title="0x02 SIMD"></a>0x02 SIMD</h1><p>如果 Accelerate 有一个统一的概念，那就是 SIMD，或者说 “单指令，多数据”。SIMD 意味着一个计算机可以使用单个命令同时对多个数据点执行相同的操作。</p>
<p>例如，给定一个无符号的整型数组，其最大值可以是单个优化的硬件指令（例如，用于 SSE 的 <code>PMAXUB</code>）所能找到的最大值。</p>
<p>在 iPhone，iPad 和 Mac 中找到的硬件拥有令人印象深刻的功能。在 x86 架构（Mac）上，关键技术是 SSE，AVX 和 AVX2；对于 AMD（iPhone &amp; iPad），则是 NEON。</p>
<p>Acc 提供了单个统一的 API 集，适应在所有这些不同结构和硬件环境提供相同的行为，以确保最大的性能和稳定性，而无需任何编译标志或平台 hack。</p>
<h1 id="0x03-Benchmarking-Performance"><a href="#0x03-Benchmarking-Performance" class="headerlink" title="0x03 Benchmarking Performance"></a>0x03 Benchmarking Performance</h1><p>这些高级例程在实践中产生了多大的不同？考虑以下常见算术运算的基准（benchmarks）：</p>
<h2 id="0x0301-Populating-an-Array"><a href="#0x0301-Populating-an-Array" class="headerlink" title="0x0301 Populating an Array"></a>0x0301 Populating an Array</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> count = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">float</span> *array = malloc(count * <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br></pre></td></tr></table></figure>

<h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    array[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Accelerate"><a href="#Accelerate" class="headerlink" title="Accelerate"></a>Accelerate</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> initial = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">1</span>;</span><br><span class="line">vDSP_vramp(&amp;initial, &amp;increment, array, <span class="number">1</span>, count);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Baseline</th>
<th align="left">Accelerate</th>
<th align="left">△</th>
</tr>
</thead>
<tbody><tr>
<td align="left">20.664600 msec</td>
<td align="left">2.495000 msec</td>
<td align="left">10x</td>
</tr>
</tbody></table>
<h2 id="0x0302-Multiplying-an-Array"><a href="#0x0302-Multiplying-an-Array" class="headerlink" title="0x0302 Multiplying an Array"></a>0x0302 Multiplying an Array</h2><h3 id="Baseline-1"><a href="#Baseline-1" class="headerlink" title="Baseline"></a>Baseline</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    array[i] *= <span class="number">2.0</span>f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Accelerate-1"><a href="#Accelerate-1" class="headerlink" title="Accelerate"></a>Accelerate</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">cblassscal(count, <span class="number">2.0</span>f, array, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Baseline</th>
<th align="left">Accelerate</th>
<th align="left">△</th>
</tr>
</thead>
<tbody><tr>
<td align="left">19.969440 msec</td>
<td align="left">2.541220 msec</td>
<td align="left">10x</td>
</tr>
</tbody></table>
<h2 id="0x0303-Summing-an-Array"><a href="#0x0303-Summing-an-Array" class="headerlink" title="0x0303 Summing an Array"></a>0x0303 Summing an Array</h2><h3 id="Baseline-2"><a href="#Baseline-2" class="headerlink" title="Baseline"></a>Baseline</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    sum += array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Accelerate-2"><a href="#Accelerate-2" class="headerlink" title="Accelerate"></a>Accelerate</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sum = cblas_sasum(count, array, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Baseline</th>
<th align="left">Accelerate</th>
<th align="left">△</th>
</tr>
</thead>
<tbody><tr>
<td align="left">41.704483 msec</td>
<td align="left">2.165160 msec</td>
<td align="left">20x</td>
</tr>
</tbody></table>
<h2 id="0x0304-Searching"><a href="#0x0304-Searching" class="headerlink" title="0x0304 Searching"></a>0x0304 Searching</h2><h3 id="Create-random-array"><a href="#Create-random-array" class="headerlink" title="Create random array"></a>Create random array</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    array[i] = (<span class="type">float</span>)arc4random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Baseline-3"><a href="#Baseline-3" class="headerlink" title="Baseline"></a>Baseline</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> MaxLocation = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; array[maxLocation]) &#123;</span><br><span class="line">        maxLocation = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Accelerate-3"><a href="#Accelerate-3" class="headerlink" title="Accelerate"></a>Accelerate</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> maxLocation = cblas_isamax(count, array, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Baseline</th>
<th align="left">Accelerate</th>
<th align="left">△</th>
</tr>
</thead>
<tbody><tr>
<td align="left">22.339838 msec</td>
<td align="left">5.110880 msec</td>
<td align="left">4x</td>
</tr>
</tbody></table>
<p>从这些基准，很明显，对于大数据集，Accelerate 可以获得巨大的性能优势。当然，就像任何优化一样，并非所有情况都会同样受益。最好的方法是始终使用 Instruments 来发现代码中的瓶颈，并估算替代的实现。</p>
<p>为了理解和识别可能从 Accelerate 中获益的情况，不过，我们需要知道它能做什么。</p>
<h2 id="0x0305-vecLib"><a href="#0x0305-vecLib" class="headerlink" title="0x0305 vecLib"></a>0x0305 vecLib</h2><p>vecLib 是由以下 9 个头文件构成：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">cblas.h &#x2F; vBLAS.h</td>
<td align="left">Interface for BLAS functions</td>
</tr>
<tr>
<td align="left">clapack.h</td>
<td align="left">Interface for LAPACK functions</td>
</tr>
<tr>
<td align="left">vectorOps.h</td>
<td align="left">Vector implementations of the BLAS routines.</td>
</tr>
<tr>
<td align="left">vBasicOps.h</td>
<td align="left">Basic algebraic operations. 8-, 16-, 32-, 64-, 128-bit division, saturated addition &#x2F; subtraction, shift &#x2F; rotate, etc.</td>
</tr>
<tr>
<td align="left">vfp.h</td>
<td align="left">Transcendental operations (sin, cos, log, etc.) on single vector floating point quantities.</td>
</tr>
<tr>
<td align="left">vForce.h</td>
<td align="left">Transcendental operations on arrays of floating point quantities.</td>
</tr>
<tr>
<td align="left">vBigNum.h</td>
<td align="left">Operations on large numbers (128-, 256-, 512-, 1024-bit quantities)</td>
</tr>
<tr>
<td align="left">vDSP.h</td>
<td align="left">Digital signal processing algorithms including FFTs, signal clipping, filters, and type conversions.</td>
</tr>
</tbody></table>
<h3 id="xDSP-h"><a href="#xDSP-h" class="headerlink" title="xDSP.h"></a>xDSP.h</h3><p>快速傅里叶变换（Fast-Fourier Transform, FFT）是基本数字信号处理算法。它将一系列值分解成具有不同频率（different frequencies）的分量（components）。</p>
<p>尽管它们在数学和工程方面具有广泛的应用，但是大多数应用程序开发者遇到用于音频或视频处理的 FFT，作为一种确定噪声信号中的临界值的方式。</p>
<p>快速傅里叶变换</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dimensions = x * y;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> log2_x = (<span class="type">int</span>)log2((<span class="type">double</span>)x);</span><br><span class="line"><span class="type">int</span> log2_y = (<span class="type">int</span>)log2((<span class="type">double</span>)y);</span><br><span class="line"></span><br><span class="line">DSPComplex *data = (DSPComplex *)malloc(<span class="keyword">sizeof</span>(DSPComplex) * dimensions);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; dimensions; i++) &#123;</span><br><span class="line">   data[i].real = (<span class="type">float</span>)i;</span><br><span class="line">   data[i].imag = (<span class="type">float</span>)(dimensions - i) - <span class="number">1.0</span>f; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DSPSplitComplex input = &#123;</span><br><span class="line">   .realp = (<span class="type">float</span> *)malloc(<span class="keyword">sizeof</span>(<span class="type">float</span>) * dimensions),</span><br><span class="line">   .imagp = (<span class="type">float</span> *)malloc(<span class="keyword">sizeof</span>(<span class="type">float</span>) * dimensions),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vDSP_ctoz(data, <span class="number">2</span>, &amp;input, <span class="number">1</span>, dimensions);</span><br><span class="line"></span><br><span class="line">FFTSetup weights = vDSP_create_fftsetup(fmax(log2_x, log2_y), kFFTRadix2);</span><br><span class="line">vDSP_fft2d_zip(weights, &amp;<span class="keyword">inout</span>, <span class="number">1</span>, <span class="number">0</span>, log2_x, log2_y, FFT_FORWARD);</span><br><span class="line">vDSP_destroy_fftsetup(fft_weights);</span><br><span class="line"></span><br><span class="line">vDSP_ztoc(&amp;input, <span class="number">1</span>, data, <span class="number">2</span>, dimensions);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; dimensions; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%g %g&quot;</span>, data[i].real, data[i].imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">free(input.realp);</span><br><span class="line">free(input.imagp);</span><br><span class="line">free(data);</span><br></pre></td></tr></table></figure>

<h3 id="vImage"><a href="#vImage" class="headerlink" title="vImage"></a>vImage</h3><p>vImage 是由 6 个头文件组成：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alpha.h</td>
<td align="left">Alpha 合成方法（Alpha compositing functions）</td>
</tr>
<tr>
<td align="left">Conversion.h</td>
<td align="left">图像之间转换（Converting between image format）（e.g. <code>Planar8</code> to <code>PlanarF</code>, <code>ARGB8888</code> to <code>Planar8</code>）</td>
</tr>
<tr>
<td align="left">Convolution.h</td>
<td align="left">Image convolution routines (e.g. blurring and edge detection).</td>
</tr>
<tr>
<td align="left">Geometry.h</td>
<td align="left">几何变换（Geometric transformations）（e.g. rotate, scale, shear, affine warp）</td>
</tr>
<tr>
<td align="left">Histogram.h</td>
<td align="left">用于计算图像直方图和图像归一化的函数（Functions for calculating image histograms and image normalization）</td>
</tr>
<tr>
<td align="left">Morphology.h</td>
<td align="left">图像形态程序（Image morphology procedures）（e.g. feature detection, dilation, erosion）</td>
</tr>
<tr>
<td align="left">Tranform.h</td>
<td align="left">图像变换操作（Image transformation operations）（e.g. gamma correction, colorspace conversion）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Planar8</td>
<td align="left">图像是单个通道（一种颜色或 alpha 值）。每个像素是 8 位无符号整型值。此图像格式的数据类型为 Pixel_8。</td>
</tr>
<tr>
<td align="left">PlanarF</td>
<td align="left">图像是单个通道（一种颜色）。每个像素是 32 位浮点数值。此图像格式的数据类型是 Pixel_F。</td>
</tr>
<tr>
<td align="left">ARGB8888</td>
<td align="left">图像有 4 个交错的通道，alpha，red，green 和 blue，以该顺序。每个像素是 32 位，由 4 个 8 位无符号整型组成的数组。此图像格式的数据类型是 Pixel_8888。</td>
</tr>
<tr>
<td align="left">ARGBFFFF</td>
<td align="left">图像有 4 个交错的通道，alpha，red，green 和 blue，以该顺序。每个像素是 由 4 个浮点数组成的数组。此图像格式的数据类型是 Pixel_FFFF。</td>
</tr>
<tr>
<td align="left">RGBA8888</td>
<td align="left">图像有 4 个交错的通道，alpha，red，green 和 blue，以该顺序。每个像素是 32 位，由 4 个 8 位无符号整型组成的数组。此图像格式的数据类型是 Pixel_8888。</td>
</tr>
<tr>
<td align="left">RGBAFFFF</td>
<td align="left">图像有 4 个交错的通道，alpha，red，green 和 blue，以该顺序。每个像素是 由 4 个浮点数组成的数组。此图像格式的数据类型是 Pixel_FFFF。</td>
</tr>
</tbody></table>
<h4 id="Alpha-h"><a href="#Alpha-h" class="headerlink" title="Alpha.h"></a>Alpha.h</h4><p>Alpha 合成是根据其 alpha 分量（components）组合多个图像的过程。对于一个图像的每一个像素，用 alpha 或 透明度的值来确定有多少图像将在下方显示。</p>
<p>vImage 方法可用于混合或剪切。最常见的操作是将一个顶部图像合成到底部图像上：</p>
<h5 id="Compositing-Two-Images"><a href="#Compositing-Two-Images" class="headerlink" title="Compositing Two Images"></a>Compositing Two Images</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *topImage, bottomImage = ...;</span><br><span class="line"><span class="built_in">CGImageRef</span> topImageRef = [topImage <span class="built_in">CGImage</span>];</span><br><span class="line"><span class="built_in">CGImageRef</span> bottomImageRef = [bottomImage <span class="built_in">CGImage</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGDataProviderRef</span> topRrovider = <span class="built_in">CGImageGetDataProvider</span>(topImageRef);</span><br><span class="line"><span class="built_in">CFDataRef</span> topBitmapData = <span class="built_in">CGDataProviderCopyData</span>(topProvider);</span><br><span class="line"></span><br><span class="line">size_t width = <span class="built_in">CGImageGeiWidth</span>(topImageRef);</span><br><span class="line">size_t height = <span class="built_in">CGImageGeiHeight</span>(topImageRef);</span><br><span class="line">size_t bytesPerRow = <span class="built_in">CGImageGetBytesPerRow</span>(topImageRef);</span><br><span class="line"></span><br><span class="line">vImage_Buffer topBuffer = &#123;</span><br><span class="line">    .data = (<span class="type">void</span> *)<span class="built_in">CFDataGetBytePtr</span>(topBitmapData),</span><br><span class="line">    .width = width,</span><br><span class="line">    .height = height,</span><br><span class="line">    .rowBytes = bytesPerRow,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGDataProviderRef</span> bottomProvider = <span class="built_in">CGImageGetDataProvider</span>(bottomImageRef);</span><br><span class="line"><span class="built_in">CFDataRef</span> bottomBitmapData = <span class="built_in">CGDataProviderCopyData</span>(bottomProvider);</span><br><span class="line"></span><br><span class="line">vImage_Buffer bottomBuffer = &#123;</span><br><span class="line">    .data = (<span class="type">void</span> *)<span class="built_in">CFDataGetBytePtr</span>(bottomBitmapData),</span><br><span class="line">    .width = width,</span><br><span class="line">    .height = height,</span><br><span class="line">    .rowBytes = bytesPerRow,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *outBytes = malloc(height * bytesPerRow);</span><br><span class="line">vImage_Buffer outBuffer = &#123;</span><br><span class="line">    .data = outBytes,</span><br><span class="line">    .width = width,</span><br><span class="line">    .height = height,</span><br><span class="line">    .rowBytes = bytesPerRow,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vImage_Error error = vImagePremultipliedAlphaBlend_ARGB8888(&amp;topBuffer, &amp;buttomBuffer, &amp;outBuffer, kvImageDoNotTile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %ld&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Conversion-h"><a href="#Conversion-h" class="headerlink" title="Conversion.h"></a>Conversion.h</h4><p>图像由像素组成，每个像素具有一个红色，绿色和蓝色强度的离散值的组合表示的颜色。总之，这些强度值构成每个颜色的一个通道，以及一个 alpha 通道，代表透明度。</p>
<p>有两种图像对该信息进行编码的方式： <em>交错</em> （interleaved），这样每个像素有共同表示的红，绿，蓝和 alpha 值，或 <em>平面</em> （planar），其中设置了一个通道中的所有值，然后是下一个通道中的值，以此类推。</p>
<p>对于给定图像格式，vImage 提供了用于将强度从一个通道交换到另一个通道的方法：</p>
<h5 id="Permuting-Color-Channels"><a href="#Permuting-Color-Channels" class="headerlink" title="Permuting Color Channels"></a>Permuting Color Channels</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = ...;</span><br><span class="line"><span class="built_in">CGImageRef</span> imageRef = [image <span class="built_in">CGImage</span>];</span><br><span class="line"></span><br><span class="line">size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">size_t bitsPerComponent = <span class="built_in">CGImageGetBitsPerComponent</span>(imageRef);</span><br><span class="line">size_t bytesPerRow = <span class="built_in">CGImageGetBytesPerRow</span>(imageRef);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGDataProviderRef</span> sourceImageDataProvider = <span class="built_in">CGImageGetDataProvider</span>(imageRef);</span><br><span class="line"><span class="built_in">CFDataRef</span> sourceImageData = <span class="built_in">CGDataProviderCopyData</span>(sourceImageDataProvider);</span><br><span class="line">vImage_Buffer sourceImageBuffer = &#123;</span><br><span class="line">    .data = (<span class="type">void</span> *)<span class="built_in">CFDataGetBytePtr</span>(sourceImageData),</span><br><span class="line">    .width = width,</span><br><span class="line">    .height = height,</span><br><span class="line">    .rowBytes = bytesPerRow,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8_t *destinationBuffer = malloc(<span class="built_in">CFDataGetLength</span>(sourceImageData));</span><br><span class="line">vImage_Buffer destinationImageBuffer = &#123;</span><br><span class="line">    .data = destinationBuffer,</span><br><span class="line">    .width = width,</span><br><span class="line">    .height = height,</span><br><span class="line">    .rowBytes = bytesPerRow,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uint8_t channels[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;; <span class="comment">// ARGB -&gt; ABGR</span></span><br><span class="line">vImagePermuteChannels_ARGB8888(&amp;sourceImageBuffer, &amp;destinationImageBuffer, channels, kvImageNoFlags);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"><span class="built_in">CGContextRef</span> destinationContext =</span><br><span class="line">    <span class="built_in">CGBitmapContextCreateWithData</span>(destinationBuffer,</span><br><span class="line">                                  width,</span><br><span class="line">                                  height,</span><br><span class="line">                                  bitsPerComponent,</span><br><span class="line">                                  bytesPerRow,</span><br><span class="line">                                  colorSpaceRef,</span><br><span class="line">                                  kCGBitmapByteOrderDefault |</span><br><span class="line">                                  kCGImageAlphaPermultipliedFirst,</span><br><span class="line">                                  <span class="literal">NULL</span>,</span><br><span class="line">                                  <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageRef</span> permutedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(destinationContext);</span><br><span class="line"><span class="built_in">UIImage</span> *permutedImage = [<span class="built_in">UIImage</span> imageWithCGImage:permutedImageRef];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageRelease</span>(permutedImageRef);</span><br><span class="line"><span class="built_in">CGContextRelease</span>(destinationContext);</span><br><span class="line"><span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br></pre></td></tr></table></figure>

<h4 id="Convolution-h"><a href="#Convolution-h" class="headerlink" title="Convolution.h"></a>Convolution.h</h4><p>图像卷积（Image convolution）是将每个像素及其相邻的像素乘以 <em>内核</em> （kernel），或用和为 1 的正方形矩阵。取决于这个内核，一个卷积操作可以是模糊（blur），锐化（sharpen），浮雕（emboss）或边缘检测（detect edges）。</p>
<p>除了需要一个定制内核的特殊情况，利用 GPU，卷积操作通过 Core Image 框架将被更好地服务（better-served）。然而，对于一个直接基于 GPU 的解决方案，vImage 提供了：</p>
<h5 id="Blurring-an-Image"><a href="#Blurring-an-Image" class="headerlink" title="Blurring an Image"></a>Blurring an Image</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *inImage = ...;</span><br><span class="line"><span class="built_in">CGImageRef</span> = inImageRef = [inImage <span class="built_in">CGImage</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGDataProviderRef</span> inProvider = <span class="built_in">CGImageGetDataProvider</span>(inImageRef);</span><br><span class="line"><span class="built_in">CFDataRef</span> inBitmapData = <span class="built_in">CGDataProviderCopyData</span>(inProvider);</span><br><span class="line"></span><br><span class="line">vImage_Buffer inBuffer = &#123;</span><br><span class="line">    .data = (<span class="type">void</span> *)<span class="built_in">CFDataGetBytePtr</span>(inBitmapData),</span><br><span class="line">    .width = <span class="built_in">CGImageGetWidth</span>(inImageRef),</span><br><span class="line">    .height = <span class="built_in">CGImageGetHeight</span>(inImageRef),</span><br><span class="line">    .rowBytes = <span class="built_in">CGImageGetBytesPerRow</span>(inImageRef),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *outBytes = malloc(<span class="built_in">CGImageGetBytesPerRow</span>(inImageRef) * <span class="built_in">CGImageGetHeight</span>(inImageRef));</span><br><span class="line">vImage_Buffer outBuffer = &#123;</span><br><span class="line">    .data = outBuffer,</span><br><span class="line">    .width = inBuffer.width,</span><br><span class="line">    .height = inBuffer.height,</span><br><span class="line">    .rowBytes = inBuffer.rowBytes,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint32_t length = <span class="number">5</span>; <span class="comment">// Size of convolution</span></span><br><span class="line">vImage_Error error = vImageBoxConvolve_ARGB8888(&amp;inBuffer, &amp;outBuffer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, length, length, <span class="literal">NULL</span>, kvImageEdgeExtend);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %ld&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"><span class="built_in">CGContextRef</span> c = <span class="built_in">CGBitmapContextCreate</span>(outBuffer.data, outBuffer.width, outBuffer.height, <span class="number">8</span>, outBuffer.rowBytes, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line"><span class="built_in">CGImageRef</span> outImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(c);</span><br><span class="line"><span class="built_in">UIImage</span> *outImage = [<span class="built_in">UIImage</span> imageWithCGImage:outImageRef];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageRelease</span>(outImageRef);</span><br><span class="line"><span class="built_in">CGContextRelease</span>(c);</span><br><span class="line"><span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line"><span class="built_in">CFRelease</span>(inBitmapData);</span><br></pre></td></tr></table></figure>

<h4 id="Geometry-h"><a href="#Geometry-h" class="headerlink" title="Geometry.h"></a>Geometry.h</h4><p>调整一个图像大小是另一种操作，可能更适合于另一个基于 GPU 的框架，如 Image I&#x2F;O。对于一个给定的 vImage buffer，使用 Accelerate 的 <code>vImageScale_*</code> 可能性能更高，而不是在 <code>CGImageRef</code> 之间来回转换：</p>
<h5 id="Resizing-an-Image"><a href="#Resizing-an-Image" class="headerlink" title="Resizing an Image"></a>Resizing an Image</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> scaleFactor = <span class="number">1.0</span> / <span class="number">5.0</span>;</span><br><span class="line"><span class="type">void</span> *outBytes = malloc(trunc(inBuffer.height * scaleFactor) * inBuffer.rowBytes);</span><br><span class="line">vImage_Buffer outBuffer = &#123;</span><br><span class="line">    .data = outBytes,</span><br><span class="line">    .width = trunc(inBuffer.width * scaleFactor),</span><br><span class="line">    .height = trunc(inBuffer.height * scaleFactor),</span><br><span class="line">    .rowBytes = inBuffer.rowBytes,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vImage_Error error = vImageScale_ARGB8888(&amp;inBuffer, &amp;outBuffer, <span class="literal">NULL</span>, kvImageHighQualityResampling);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %ld&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Histogram-h"><a href="#Histogram-h" class="headerlink" title="Histogram.h"></a>Histogram.h</h4><p>检测一个图像是否包含透明度</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image;</span><br><span class="line"><span class="built_in">CGImage</span> imageRef = [image <span class="built_in">CGImage</span>];</span><br><span class="line"><span class="built_in">CGDataProviderRef</span> dataProvider = <span class="built_in">CGImageGetDataProvider</span>(imageRef);</span><br><span class="line"><span class="built_in">CFDataRef</span> = bitmapData = <span class="built_in">CGDataProviderCopyData</span>(dataProvider);</span><br><span class="line"></span><br><span class="line">vImagePixelCount a[<span class="number">256</span>], r[<span class="number">256</span>], g[<span class="number">256</span>], b[<span class="number">256</span>];</span><br><span class="line">vImagePixelCount *histogram[<span class="number">4</span>] = &#123;a, r, g, b&#125;;</span><br><span class="line">vImage_Buffer buffer = &#123;</span><br><span class="line">    .data = (<span class="type">void</span> *)<span class="built_in">CFDataGetBytePtr</span>(bitmapData),</span><br><span class="line">    .width = <span class="built_in">CGImageGetWidth</span>(imageRef),</span><br><span class="line">    .height = <span class="built_in">CGImageGetHeight</span>(imageRef),</span><br><span class="line">    .rowBytes = <span class="built_in">CGImageGetByesPerRow</span>(imageRef),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vImage_Error error = vImageHistogramCalculation_ARGB8888(&amp;buffer, histogram, kvImageNoFlags);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %ld&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">BOOL</span> hasTransparency = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; !hasTransparency &amp;&amp; i &lt; <span class="number">255</span>; i++) &#123;</span><br><span class="line">    hasTransparency = histogram[<span class="number">3</span>][i] == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGDataProviderRelease</span>(dataProvider);</span><br><span class="line"><span class="built_in">CFRelease</span>(bitmapData);</span><br></pre></td></tr></table></figure>

<h4 id="Morphology-h"><a href="#Morphology-h" class="headerlink" title="Morphology.h"></a>Morphology.h</h4><p>扩大图像（Dilating an Image）</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">size_t width = image.size.width;</span><br><span class="line">size_t height = image.size.height;</span><br><span class="line">size_t bitsPerComponent = <span class="number">8</span>;</span><br><span class="line">size_t bytesPerRow = <span class="built_in">CGImageGetBytesPerRow</span>([image <span class="built_in">CGImage</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"><span class="built_in">CGContextRef</span> sourceContext =</span><br><span class="line">    <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                          width,</span><br><span class="line">                          height,</span><br><span class="line">                          bitsPerComponent,</span><br><span class="line">                          bytesPerRow,</span><br><span class="line">                          colorSpaceRef,</span><br><span class="line">                          kCGBitmapByteOrderDefault |</span><br><span class="line">                          kCGImageAlphaPremultipliedFirst);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGContextDrawImage</span>(sourceContext, <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, width, height), [image <span class="built_in">CGImage</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *sourceData = <span class="built_in">CGBitmapContextGetData</span>(sourceContext);</span><br><span class="line">vImage_Buffer sourceBuffer = &#123;</span><br><span class="line">    .data = sourceData,</span><br><span class="line">    .width = width,</span><br><span class="line">    .height = height,</span><br><span class="line">    .rowBytes = bytesPerRow,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">size_t length = height * bytesPerRow;</span><br><span class="line"><span class="type">void</span> *destinationData = malloc(length);</span><br><span class="line">vImage_Buffer destinationBuffer = &#123;</span><br><span class="line">    .data = destinationData,</span><br><span class="line">    .width = width,</span><br><span class="line">    .height = height,</span><br><span class="line">    .rowBytes = bytesPerRow,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">unsigned</span> <span class="type">char</span> kernel[<span class="number">9</span>] = &#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vImageDilate_ARGB8888(&amp;sourceBuffer, &amp;destinationBuffer, <span class="number">0</span>, <span class="number">0</span>, kernel, <span class="number">9</span>, <span class="number">9</span>, kvImageCopyInPlace);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGContextRef</span> destinationContext =</span><br><span class="line">    <span class="built_in">CGBitmapContextCreateWithData</span>(destinationData,</span><br><span class="line">                                  width,</span><br><span class="line">                                  height,</span><br><span class="line">                                  bitsPerComponent,</span><br><span class="line">                                  bytesPerRow,</span><br><span class="line">                                  colorSpaceRef,</span><br><span class="line">                                  kCGBitmapByteOrderDefault |</span><br><span class="line">                                  kCGImageAlphaPremultipliedFirst,</span><br><span class="line">                                  <span class="literal">NULL</span>,</span><br><span class="line">                                  <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageRef</span> dilatedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(destinationContext);</span><br><span class="line"><span class="built_in">UIImage</span> *dilatedImage = [<span class="built_in">UIImage</span> imageWithCGImage:dilatedImageRef];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageRelease</span>(dilatedImageRef);</span><br><span class="line"><span class="built_in">CGContextRelease</span>(destinationContext);</span><br><span class="line"><span class="built_in">CGContextRelease</span>(sourceContext);</span><br><span class="line"><span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br></pre></td></tr></table></figure>

<p>在这个广泛监视，减少隐私和无处不在的连接的时代，安全不再是偏执狂的宠物主题 —— 这是每个人都能很好理解的东西。</p>
<p>安全框架可以分为 Keychain Services，Cryptographic Message Syntax，Security Transform Services 和 CommonCrypto。</p>
<h1 id="0x04-Keychain-Services"><a href="#0x04-Keychain-Services" class="headerlink" title="0x04 Keychain Services"></a>0x04 Keychain Services</h1><p>Keychain 是 iOS 和 OS X 上的密码管理系统。它存储证书和私钥，以及网站，服务器，无线网络和其他加密卷（encrypted volumes）的密码。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Accelerate</tag>
      </tags>
  </entry>
  <entry>
    <title>CFHipsterRef 学习笔记目录</title>
    <url>/2016/11/07/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Table-of-Contents/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2018/11/01/5bdac193ceb39.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是自己在学习 <a href="https://gum.co/cfhipsterref">CFHipsterRef</a> 时做的笔记，与其说是笔记，不如说是翻译，但是并不是完全翻译。</p>
<span id="more"></span>

<h1 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h1><ul>
<li>Chapter 1 Kernel</li>
<li>Chapter 2 <a href="https://meilbn.com/2016/10/27/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter2-Objective-C-Runtime/">Objective-C Runtime</a></li>
<li>Chapter 3 Clang</li>
<li>Chapter 4 OSAtomic</li>
<li>Chapter 5 <a href="https://meilbn.com/2016/10/29/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter5-Grand-Central-Dispatch/">Grand Central Dispatch</a></li>
<li>Chapter 6 <a href="https://meilbn.com/2016/10/31/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter6-Inter-Process-Communication/">Inter-Process Communication</a></li>
<li>Chapter 7 <a href="https://meilbn.com/2016/11/02/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter7-Core-Services/">CoreServices</a></li>
<li>Chapter 8 <a href="https://meilbn.com/2016/11/02/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter8-ImageIO/">Image I&#x2F;O</a></li>
<li>Chapter 9 <a href="https://meilbn.com/2016/11/03/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter9-Accelerate/">Accelerate</a></li>
<li>Chapter 10 <a href="https://meilbn.com/2016/11/03/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter10-Security/">Security</a></li>
<li>Chapter 11 <a href="https://meilbn.com/2016/11/04/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter11-System-Configuration/">System Configuration</a></li>
<li>Chapter 12 <a href="https://meilbn.com/2016/11/05/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter12-International-Components-for-Unicode/">International Components for Unicode</a></li>
<li>Chapter 13 <a href="https://meilbn.com/2016/11/05/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter13-Dictionary-Services/">Dictionary Services</a></li>
<li>Chapter 14 <a href="https://meilbn.com/2016/11/05/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter14-Xcode-Toolchain/">Xcode Toolchain</a></li>
<li>Chapter 15 <a href="https://meilbn.com/2016/11/06/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter15-Third-Party-Tools/">Tird Party Tools</a></li>
<li>Chapter 16 <a href="https://meilbn.com/2016/11/07/CFHipsterRef-Low-Level-Programming-on-iOS-OSX-Chapter16-CocoaPods/">CocoaPods</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>CFHipsterRef</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Making a CocoaPod</title>
    <url>/2017/08/24/How-to-making-a-CocoaPod/</url>
    <content><![CDATA[<p><strong>这里我们先只讨论创建公开的 Pod，因为我还没有需求使用私用 Pod。</strong><br><strong>这里使用 GitHub 来托管代码库</strong></p>
<h1 id="0x00-准备工作"><a href="#0x00-准备工作" class="headerlink" title="0x00 准备工作"></a>0x00 准备工作</h1><p>如果想要创建一个 Pod，说明你的库的代码也敲的差不多了，可以发布出来让其他人使用了。<br>如果还没有一个对应的 GitHub repo，就先创建一个，然后你可以：</p>
<ol start="0">
<li><code>git clone</code> 到本地，然后把代码拖进去</li>
<li>在原来的项目的目录下，添加一个 remote，如果原来的项目不是一个 Git 仓库，则先 init，然后添加 remote，具体步骤如下：</li>
</ol>
<p><img src="https://i.loli.net/2018/11/01/5bdac1cf0c87e.png"></p>
<span id="more"></span>

<h1 id="0x01-创建和编辑-podspec"><a href="#0x01-创建和编辑-podspec" class="headerlink" title="0x01 创建和编辑 podspec"></a>0x01 创建和编辑 podspec</h1><p>每个 Pod 都对应一个 podspec 文件，描述 Pod 的信息及依赖。<br>使用命令 <code>pod spec create</code> 来创建 podspec：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdac1de726d1.png"></p>
<p>然后编辑 podspec 文件，里面的说明都非常详细，这里就放一下我自己这个项目的 podspec 了：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  s.<span class="attr">name</span>         = <span class="string">&quot;Sandboxer&quot;</span></span><br><span class="line">  s.<span class="attr">version</span>      = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  s.<span class="attr">summary</span>      = <span class="string">&quot;iOS file browser written in Objective-C.&quot;</span></span><br><span class="line"></span><br><span class="line">  s.<span class="attr">description</span>  = &lt;&lt;-DESC</span><br><span class="line">                    - iOS file browser written <span class="keyword">in</span> Objective-C.</span><br><span class="line">                    - Use for browse sandbox files <span class="literal">and</span> directories, <span class="literal">or</span> manage them, like delete.</span><br><span class="line">                    - iOS <span class="number">7</span>+.</span><br><span class="line">                   DESC</span><br><span class="line"></span><br><span class="line">  s.<span class="attr">homepage</span>     = <span class="string">&quot;https://github.com/meilbn/Sandboxer-Objc&quot;</span></span><br><span class="line">  <span class="comment"># s.screenshots  = &quot;www.example.com/screenshots_1.gif&quot;, &quot;www.example.com/screenshots_2.gif&quot;</span></span><br><span class="line"></span><br><span class="line">  s.<span class="attr">license</span>      = <span class="string">&quot;MIT&quot;</span></span><br><span class="line"></span><br><span class="line">  s.<span class="attr">author</span>             = &#123; <span class="string">&quot;meilbn&quot;</span> =&gt; <span class="string">&quot;codingallnight@gmail.com&quot;</span> &#125;</span><br><span class="line">  s.<span class="attr">social_media_url</span>   = <span class="string">&quot;https://twitter.com/meilbn&quot;</span></span><br><span class="line"></span><br><span class="line">  s.<span class="attr">platform</span>     = :ios, <span class="string">&quot;7.0&quot;</span></span><br><span class="line"></span><br><span class="line">  s.<span class="attr">source</span>       = &#123; :<span class="attr">git</span> =&gt; <span class="string">&quot;https://github.com/meilbn/Sandboxer-Objc.git&quot;</span>, :<span class="attr">tag</span> =&gt; <span class="string">&quot;#&#123;s.version&#125;&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  s.<span class="attr">source_files</span>  = <span class="string">&quot;Sandboxer&quot;</span>, <span class="string">&quot;Sandboxer/**/*.&#123;h,m&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">  s.<span class="attr">resources</span> = <span class="string">&quot;Sandboxer/SandboxerResources.bundle&quot;</span></span><br><span class="line"></span><br><span class="line">  s.<span class="attr">frameworks</span> = <span class="string">&quot;QuickLook&quot;</span>, <span class="string">&quot;WebKit&quot;</span></span><br><span class="line"></span><br><span class="line">  s.<span class="attr">requires_arc</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h1 id="0x02-Push-到-GitHub"><a href="#0x02-Push-到-GitHub" class="headerlink" title="0x02 Push 到 GitHub"></a>0x02 Push 到 GitHub</h1><p>编辑完 podspec 文件，就可以将项目的文件都提交到 GitHub 了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>还可以打上 tag：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -a 1.0.0 -m <span class="string">&quot;v1.0.0&quot;</span></span><br><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure>

<p>然后 GitHub 上的仓库就能看到刚刚上传的代码了。</p>
<h1 id="0x03-验证-Pod"><a href="#0x03-验证-Pod" class="headerlink" title="0x03 验证 Pod"></a>0x03 验证 Pod</h1><p>既然代码都上传到 GitHub 了，接下来就是验证 Pod 了。<br>使用命令 <code>pod spec lint Sandboxer.podspec</code> 来验证，但是有一个问题是，如果你的代码有警告的话，验证就会失败，如果你想忽略这些警告，可以加上 <code>--allow-warnings</code> 来忽略这些警告：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdac1ebab401.png"></p>
<p>这样，就说明 Pod 验证成功了</p>
<h1 id="0x04-上传-Pod-到-CocoaPods"><a href="#0x04-上传-Pod-到-CocoaPods" class="headerlink" title="0x04 上传 Pod 到 CocoaPods"></a>0x04 上传 Pod 到 CocoaPods</h1><p>既然 Pod 验证成功了，最后一步就是将它上传到 CocoaPods，自己能用，别人也能用了。<br>如果是第一次上传 Pod，则需要注册一下（可能需要翻下墙），已有的请略过。</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod trunk register your_email <span class="string">&#x27;your_name&#x27;</span> --description=<span class="string">&#x27;macbook air&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果想要查看该命令执行的一些详细信息，可以加上 <code>--verbose</code>。</p>
<p><strong>完成之后需要到填写的邮箱里面验证一下，才能继续下面的操作。</strong></p>
<p>注册成功以后，可以使用命令 <code>pod trunk me</code> 来查看自己的信息，发布过哪些 Pod，还有登录记录：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdac20e237af.png"></p>
<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>终于到了上传这一步了，命令如下（如果之前验证加过忽略警告的，还是需要再加上）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod trunk push Sandboxer.podspec --allow-warnings</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2018/11/01/5bdac21bd3b9b.png"></p>
<p>这条命令会：</p>
<ul>
<li>验证本地的 Podspec，就如上面的验证步骤</li>
<li>上传 podspec 到 Trunk 或者你的私有 specs 仓库</li>
<li>Trunk 会发布一个代表你的 podspec 的 JSON 文件</li>
</ul>
<p>成功了之后，CocoaPods 的 <a href="https://github.com/CocoaPods/Specs">Specs repo</a> 也会有上传操作：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdac22aeac87.png"></p>
<p>如果这条命令顺利执行完的话，就没什么问题了，Pod 就发布成功了。然后就可以通过命令 <code>pod search Sandboxer</code> 来看看是否能够找到（如果找不到，需要更新一下本地的 specs，最简单的就是在一个已有 Podfile 的项目上运行命令：<code>pod update</code>）。</p>
<h1 id="0x05-关于-Pod-里面添加了资源文件-Bundle-之后找不到-Bundle-的问题"><a href="#0x05-关于-Pod-里面添加了资源文件-Bundle-之后找不到-Bundle-的问题" class="headerlink" title="0x05 关于 Pod 里面添加了资源文件 Bundle 之后找不到 Bundle 的问题"></a>0x05 关于 Pod 里面添加了资源文件 Bundle 之后找不到 Bundle 的问题</h1><p>在测试自己的 Pod 的时候，发现图标和国际化文字都出不来，发现使用 <code>[[NSBundle mainBundle] pathForResource:@&quot;SandboxerResources&quot; ofType:@&quot;bundle&quot;]</code> 获取的 <code>path</code> 是 <code>nil</code> 的，就找了下原因，在 CocoaPods 0.36 以前，Pod 资源最后都会被直接拷贝到 client target 的 <code>[NSBundle mainBundle]</code> 里。你可以用访问 <code>mainBundle</code> 里资源的方式访问它们。比如用 <code>+ (UIImage *)imageNamed:(NSString *)name</code> 来访问 Pod 的图片。</p>
<p>但是在 CocoaPods 0.36 之后，这件事情发生了一些变化。由于 iOS 8 Dynamic Frameworks 特性的引入，CocoaPods 能帮你打包 framework 了。<a href="http://blog.cocoapods.org/CocoaPods-0.36/">0.36 版的 release note</a> 很详细地说明了加入 framework 特性所带来的变化。一个显著区别就是当你的 Pod 库以 framework 形式被使用时，你的资源不是被拷贝到 mainBundle 下，而是被放到 Pod 的最终产物 —— framework 里。此时，你必须保证自己在访问这个 framework 的 bundle，而不是 client target 的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSBundle</span> bundleForClass:&lt;#ClassFromPodspec#&gt;]</span><br></pre></td></tr></table></figure>

<p>上面这段代码可以返回某个 class 对应的 bundle 对象。具体的，</p>
<ul>
<li>如果你的 Pod 以 framework 形式被链接，那么返回这个 framework 的 bundle。</li>
<li>如果以静态库（.a）的形式被链接，那么返回 client target 的 bundle，即 mainBundle。</li>
</ul>
<p>所以我就将获取 Bundle 的方法改成了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSBundle</span> *bundle = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (!bundle) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;SandboxerResources&quot;</span> ofType:<span class="string">@&quot;bundle&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (MLBIsStringEmpty(path)) &#123;</span><br><span class="line">        <span class="built_in">NSBundle</span> *bd = [<span class="built_in">NSBundle</span> bundleForClass:[Sandboxer <span class="keyword">class</span>]];</span><br><span class="line">        <span class="keyword">if</span> (bd) &#123;</span><br><span class="line">            path = [bd pathForResource:<span class="string">@&quot;SandboxerResources&quot;</span> ofType:<span class="string">@&quot;bundle&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bundle = [<span class="built_in">NSBundle</span> bundleWithPath:path];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，bundle 就可以正确获取了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://cocoapods.org/">CocoaPods</a></li>
<li><a href="https://guides.cocoapods.org/making/getting-setup-with-trunk.html">Pod to the CocoaPods Trunk</a></li>
<li><a href="https://guides.cocoapods.org/syntax/podspec.html">Podspec Syntax Reference</a></li>
<li><a href="http://blog.xianqu.org/2015/08/pod-resources/">给 Pod 添加资源文件</a></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>在 iOS 开发中遇到的问题（零）</title>
    <url>/2015/08/18/The-problems-encountered-in-the-development-of-iOS-00/</url>
    <content><![CDATA[<ul>
<li>界面返回之后刷新 UITableView 数据，或者刷新指定行的数据，列表出现滚动，原因是重写了 UITableView 的下面这个方法，去掉就OK了。<a href="https://stackoverflow.com/questions/24767665/uitableview-bouncing-back-to-the-top-of-a-section-when-calling-reloadrowsatindex">Stack Overflow</a>：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br></pre></td></tr></table></figure>

<ul>
<li>UISearchBar 的结果列表，想要高度和 UITableView 的 Cell 高度一致的话，这样设置就行了：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.searchDisplayController.searchResultsTableView.rowHeight = <span class="keyword">self</span>.tableView.rowHeight;</span><br></pre></td></tr></table></figure>

<ul>
<li>出现 Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘Could not find a storyboard named ‘Main’ in bundle NSBundle &lt;*.app&gt; (loaded)’，原因是删掉了 Main.storyboard，但是还需要从 Info.plst 里面点掉对应的字段：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remove the &quot;Main storyboard file base name&quot; or &quot;UIMainStoryboardFile&quot; Key from your info.plist file.</span><br></pre></td></tr></table></figure>

<ul>
<li>去掉 UITableviewCell 的点击效果。<a href="https://stackoverflow.com/questions/190908/how-can-i-disable-the-uitableview-selection-highlighting">Stack Overflow</a></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">cell.selectionStyle = <span class="built_in">UITableViewCellSelectionStyleNone</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>UIlabel layer.cornerRadius not working in iOS 7.1，解决办法：Set the property clipsToBounds to YES。<a href="https://stackoverflow.com/questions/22316836/uilabel-layer-cornerradius-not-working-in-ios-7-1">Stack Overflow</a></p>
</li>
<li><p>隐藏导航栏上的返回按钮。<a href="https://stackoverflow.com/questions/614212/how-to-hide-back-button-on-navigation-bar-on-iphone">Stack Overflow</a></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationItem.hidesBackButton = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 UITextField 的 placeholder 的字体颜色。<a href="https://stackoverflow.com/questions/1340224/iphone-uitextfield-change-placeholder-text-color">Stack Overflow</a></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> lightTextColor];</span><br><span class="line">YOURTEXTFIELD.attributedPlaceholder = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:<span class="string">@&quot;PlaceHolder Text&quot;</span> attributes:@&#123;<span class="built_in">NSForegroundColorAttributeName</span>: color&#125;];</span><br></pre></td></tr></table></figure>

<ul>
<li>获取键盘的高度。<a href="https://stackoverflow.com/questions/3546571/how-to-get-uikeyboard-size-with-apple-iphone-sdk">Stack Overflow</a></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)someMethodWhereYouSetUpYourObserver &#123;</span><br><span class="line">	<span class="comment">// This could be in an init method.</span></span><br><span class="line">	[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(myNotificationMethod:) name:<span class="built_in">UIKeyboardDidShowNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)myNotificationMethod:(<span class="built_in">NSNotification</span>*)notification &#123;</span><br><span class="line">	<span class="built_in">NSDictionary</span>* keyboardInfo = [notification userInfo];</span><br><span class="line">	<span class="built_in">NSValue</span>* keyboardFrameBegin = [keyboardInfo valueForKey:<span class="built_in">UIKeyboardFrameBeginUserInfoKey</span>];</span><br><span class="line">	<span class="built_in">CGRect</span> keyboardFrameBeginRect = [keyboardFrameBegin <span class="built_in">CGRectValue</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要忘记在 viewWillDisappear 方法里面移除观察：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 SearchBar TextField 颜色：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UITextField</span> *searchField = [<span class="keyword">self</span>.searchBar valueForKey:<span class="string">@&quot;_searchField&quot;</span>];</span><br><span class="line">searchField.textColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">[searchField setValue:[<span class="built_in">UIColor</span> whiteColor] forKeyPath:<span class="string">@&quot;_placeholderLabel.textColor&quot;</span>];</span><br><span class="line">[<span class="keyword">self</span>.searchBar setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;nav_search_btn_bg&quot;</span>] forSearchBarIcon:<span class="built_in">UISearchBarIconSearch</span> state:<span class="built_in">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>高亮 UITableView 选中的那一行的颜色。<a href="https://stackoverflow.com/questions/5841056/uitableviewcell-selected-rows-text-color-change">Stack Overflow</a></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">cell.textLabel.highlightedTextColor = [<span class="built_in">UIColor</span> redColor];</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 UItableView 的某一行高亮。<a href="https://stackoverflow.com/questions/4518723/how-to-highlight-a-row-in-a-uitableview">Stack Overflow</a></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[cell.textLabel setHighlighted:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>在头文件中使用 @property 定义了一个可变对象，如下，通过上一个界面传过来，在使用的时候，当改变其值的时候，会出现崩溃，原因是 copy 这个属性，将这个属性去掉行OK了。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableDictionary</span> *userRegisterInfo;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Creating a UISearchDisplayController programmatically。<a href="https://stackoverflow.com/questions/8696260/creating-a-uisearchdisplaycontroller-programmatically">Stack Overflow</a></p>
</li>
<li><p>UITextView 获取键盘 return 按钮事件。<a href="https://stackoverflow.com/questions/10423142/uitextfield-uitextview-i-need-to-be-able-to-detect-user-return-key-and-i-n">Stack Overflow</a></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)textView:(<span class="built_in">UITextView</span> *)textView shouldChangeTextInRange:(<span class="built_in">NSRange</span>)range replacementText:(<span class="built_in">NSString</span> *)text; &#123;</span><br><span class="line">	<span class="keyword">if</span> ([text isEqualToString:<span class="string">@&quot;\n&quot;</span>]) &#123;</span><br><span class="line">		<span class="comment">//Do whatever you want</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>UITableView 多自定义 Cell 类型。<a href="https://stackoverflow.com/questions/14303832/uitableview-with-two-custom-cells-multiple-identifiers">Stack Overflow</a></p>
</li>
<li><p>在 Storyboard 中设置 Tab Bar Item 的 Selected Image 没有用，提示：CUICatalog: Invalid asset name supplied: (null)。<a href="https://stackoverflow.com/questions/22011106/error-cuicatalog-invalid-asset-name-supplied-null-or-invalid-scale-factor">Stack Overflow</a></p>
</li>
<li><p>iOS UITableView first section header not show。<a href="https://stackoverflow.com/questions/21088428/ios-why-is-my-first-section-header-in-table-not-showing">Stack Overflow</a>，原因：It wasn’t showing because i hadn’t implemented heightForHeaderInSection</p>
</li>
<li><p>设置 UITabBar shadow backgroundimage。<a href="https://stackoverflow.com/questions/14371343/ios-uitabbar-remove-top-shadow-gradient-line">Stack Overflow</a></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">UITabBar</span> appearance] setBackgroundImage:[[<span class="built_in">UIImage</span> alloc] init]];</span><br><span class="line">[[<span class="built_in">UITabBar</span> appearance] setShadowImage:[[<span class="built_in">UIImage</span> alloc] init]];</span><br></pre></td></tr></table></figure>

<ul>
<li>设置导航栏 left Bar Button Item，如果是想要干掉返回按钮，并且使右滑返回失效，就直接设置 leftBarButtonItem。如果是想增加一个按钮，则：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationItem.leftItemsSupplementBackButton = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">self</span>.navigationItem.leftBarButtonItem = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithTitle:<span class="string">@&quot;Title&quot;</span> style:<span class="built_in">UIBarButtonItemStylePlain</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(action)];</span><br></pre></td></tr></table></figure>

<p>Google 搜索关键字：ios set navigation bar left button item back button disappear<br><a href="https://stackoverflow.com/questions/18760677/add-a-button-next-to-the-back-button">Stack Overflow</a></p>
<ul>
<li>比较 <strong>版本号</strong> 字符串时，普通的比较在某些情况下是有问题的，因为默认是一个一个字符比较的，所以在比较版本号的字符串时，需要指定一下 option：NSNumericSearch，如下：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[str0 compare:str1 options:<span class="built_in">NSNumericSearch</span>]</span><br></pre></td></tr></table></figure>

<p>比如当 <code>1.1.1</code> 和 <code>1.1.12</code> 比较的时候，默认的方法是返回降序的，如果是用上面的方法，返回是升序。</p>
<ul>
<li>离线推送的 DeviceToken 转字符串</li>
</ul>
<p>Google 搜索关键字：ios device token to string<br><a href="https://stackoverflow.com/a/16411517/4318339">Stack Overflow</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 学习笔记</title>
    <url>/2015/08/14/Objective-C-Learning-Notes/</url>
    <content><![CDATA[<p>可能比较杂乱，可以按照关键字来搜索快速查找定位。</p>
<p>可能会遇到的问题：</p>
<ol>
<li>如果是复制进去的文件，Linker、编译的时候报错，说文件没有找到，可能是文件没有添加到 Compile Sources 列表里面，选择 <strong>项目根 -&gt; Build Phases -&gt; Compile Sources</strong></li>
</ol>
<p>.h 文件只是用来声明一个类有哪些成员变量和方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> ： <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量要定义在大括号中</span></span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这里声明的所有方法都是公共的</span></span><br><span class="line"><span class="comment">// _age 的 get 方法</span></span><br><span class="line"><span class="comment">// - 代表动态方法  + 代表静态方法</span></span><br><span class="line">- (<span class="type">int</span>)getAge;</span><br><span class="line"><span class="comment">// _age 的 set 方法</span></span><br><span class="line">- (<span class="type">void</span>)setAge:(<span class="type">int</span>)age;<span class="comment">// 一个 : 代表一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><code>@interface</code> 代表声明一个类，最后接 <code>@end</code><br>“：” 代表继承</p>
<p>.m 文件是用来实现类的一些方法的</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">int</span>)getAge &#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setAge:(<span class="type">int</span>)age &#123;</span><br><span class="line">    _age = age;</span><br><span class="line">    <span class="comment">// 错误写法，会导致死循环，无限调用 set 方法</span></span><br><span class="line">    <span class="comment">// self.age = newAge; // [self setAge:newAge];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>创建一个 Student 对象：<br>1、调用一个静态方法 alloc 来分配内存</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Student *stu = [Student alloc];</span><br></pre></td></tr></table></figure>

<p>2、调用一个动态方法 init 进行初始化</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">stu = [stu init];</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line"></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">person.age = <span class="number">10</span>;<span class="comment">// 等效于 [peson setAgeL:10]; 调用的 set 方法</span></span><br><span class="line"><span class="type">int</span> age = person.age;<span class="comment">// 等效于 [person getAge]; 调用的 get 方法</span></span><br></pre></td></tr></table></figure>

<p>在 OC 当中，使用 <code>%@</code> 来打印一个对象(内存地址)，重写 <code>description</code> 方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, stu);</span><br></pre></td></tr></table></figure>
<p>在 OC 当中格式化字符串：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;age is %i and no is %i&quot;</span>, _age, _no];</span><br></pre></td></tr></table></figure>

<p>如果直接把方法写在 .m 文件中，没有在 .h 文件中进行声明，那么这个方法就是私有的</p>
<p>.h 文件中，当编译器遇到 <code>@property</code> 时，会自动展开成 getter 和 setter 的声明，用在 <code>@interface</code> 里面</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;</span><br><span class="line">- (<span class="type">int</span>)age;</span><br><span class="line">- (<span class="type">void</span>)setAge:(<span class="type">int</span>)newAge;</span><br></pre></td></tr></table></figure>

<p>.m 文件中，@synthesize age; 相当于：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setAge:(<span class="type">int</span>)newAge &#123;</span><br><span class="line">    age = newAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">int</span>)age &#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以写成：<code>@synthesize age, no, height;</code> 用在 <code>@implementation</code> 里面<br><code>@synthesize</code> 会自动生成 getter 和 setter 的实现方法。<br><code>@synthesize</code> 默认会去访问跟 age 同名的变量，如果找不到，会在类的内部自动生成一个同名的变量，所以在 .h 文件中可以不用再声明该变量。<br><code>age = _age</code> 代表 getter 和 setter 会去访问 _age 这个成员变量，自动生成的 age 就不会再存在了</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@synthesize</span> age = _age;</span><br></pre></td></tr></table></figure>

<p>在 Xcode 4.5 之后，如果在 .h 文件中使用 <code>@property</code> 声明了变量 age 或者 _age，在 .m 文件中没有使用 <code>@synthesize</code> 实现这个变量，编译器会自动帮我们创建一个变量 _age。</p>
<p>如果在 getter 或者 setter 方法里面需要做一些操作的话，就不能依赖于 <code>@synthesize</code> 了。<br>如果你实现了 <code>@synthesize</code> 和 getter&#x2F;setter 方法，<code>@synthesize</code> 就作废，不会再帮你创建 getter&#x2F;setter 方法了。</p>
<p>内存管理</p>
<ol>
<li>范围：任何继承了 <code>NSObject</code> 的对象，对基本数据类型无效</li>
<li>原理：<ul>
<li>每个对象内部都保存了一个与之相关联的整数，称为引用计数器</li>
<li>当使用 alloc、new 或者 copy 创建一个对象时，对象的引用计数器被设置为 1</li>
<li>给对象发送一条 retain 消息，可以使引用计数器 +1</li>
<li>给对象发送一条 release 消息，可以使引用计数器 -1</li>
<li>当一个对象的引用计数器值为 0 时，那么它将被销毁，其占用的内存被系统回收，OC 也会自动向对象发送一条 dealloc 消息。一般会重写 dealloc 方法，在这里释放相关资源。一定不要直接调用 dealloc 方法</li>
<li>可以给对象发送 retainCount 消息获得当前的引用计数器值</li>
</ul>
</li>
</ol>
<p>每个OC对象都有自己的引用计数器，是一个整数，表示“对象被引用的此数”，即有多少人正在使用这个OC对象<br>每个OC对象内部都专门有4个字节的存储空间来存储引用计数器</p>
<p>重写dealloc方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">// 自己要做的一些事情</span></span><br><span class="line">    <span class="comment">// 一定要调用super的dealloc方法，而且最好放在最后面调用</span></span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存管理法则</p>
<ol>
<li>谁创建，谁释放(“谁污染，谁治理”)。如果你通过 alloc、new 或 (mutable)copy 来创建一个对象，那么你必须调用 release 或 autorelease。换句话说，不是你创建的，就不用你去释放</li>
<li>一般来说，除了 alloc、new 或 copy 之外的方法创建的对象都被声明了 autorelease</li>
<li>谁 retain，谁 release。只要你调用了 retain，无论这个对象时如何生成的，你都要调用 release</li>
</ol>
<p>方法注释：</p>
<ul>
<li>给方法分组：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 生命周期方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>给方法注释：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark 方法单独注释</span></span><br></pre></td></tr></table></figure>

<p>@class 关键字：</p>
<p><code>@class</code> 用来声明一个类，在 .h 文件中，可以不需要 import 进来某个类的 .h 文件，用<code>@class</code> 类名 代替，在 .m 文件中，因为要实现方法，需要用到类的一些东西，所以需要 <code>import</code> 进来这个类的 .h 文件</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">retain</span>) Book *book;</span><br></pre></td></tr></table></figure>

<p>这里的 retain 代表：在 setter 方法中，release 旧值，retain 新值<br>在 <code>@property</code> 后面加上 <code>(retain)</code> ，在实现文件 .m 中，会自动生成管理内存的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setBook:(Book *)book &#123;</span><br><span class="line">    <span class="keyword">if</span>(_book != book) &#123;</span><br><span class="line">        [_book release];</span><br><span class="line">        _book = [book <span class="keyword">retain</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age; <span class="comment">// 默认是 @property (readwrite) int age;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="type">int</span> age; <span class="comment">// 代表只生成 getter 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="type">int</span> age; <span class="comment">// 代表直接赋值</span></span><br></pre></td></tr></table></figure>

<p><code>@property</code> 属性默认为 atomic，提供多线程安全<br>在多线程环境下，原子操作时必要的，否则有可能引起错误的结果<br>加了 atomic，setter&#x2F;getter 是一个原子操作，如果有多个线程同时调用 setter 的话，不会出现某一个线程执行 setter 全部语句之前，另一个线程开始执行 setter 的情况，相当于函数头尾加了锁一样</p>
<p>如果是 nonatomic，代表方法不需要考虑线程安全问题<br>禁止多线程，变量保护，提高性能<br>atomic 是 OC 使用的一种线程保护技术，防止在写入未完成的时候被另外一个线程读取，造成数据错误。而这种机制是耗费系统资源的，所以在 iPhone 这种小型设备上，如果没有使用多线程间的通讯，那么 nonatomic 是一个非常好的选择<br>如果不需要多线程支持的话，用 nonatomic 就够了，另外由于不涉及锁操作，所以它执行相对快点</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isRich) Bool rich;</span><br></pre></td></tr></table></figure>

<p>getter 是用来指定 get 方法的方法名</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @autoreleasepool 代表创建一个自动释放池</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    Student *stu = [[[Student alloc] init] autorelease];<span class="comment">// 最好写成这样，下面的方式可能会忘记写 [stu autorelease];</span></span><br><span class="line">    <span class="comment">// Student *stu = [[Student alloc] init];</span></span><br><span class="line">    <span class="comment">// [stu autorelease]; // 代表将 stu 放入上面创建的自动释放池当中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当自动释放池被销毁了，池子里面的所有对象都会调用释放方法</p>
<p>使用静态方法快速创建一个 autorelease 的对象：</p>
<ul>
<li>在 Student.m 文件中创建一个创建对象的静态方法：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">id</span>)student &#123;</span><br><span class="line">    Student *stu = [[[Student alloc] init] autorelease];</span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">    <span class="comment">// 也可以这样写：return [[[Student alloc] init] autorelease]; 省略了中间变量 stu</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Student *stu = [Student student];</span><br></pre></td></tr></table></figure>

<p>在静态方法中，不能访问成员变量</p>
<p>autoreleasepool 注意事项：</p>
<ol>
<li>在 ARC 下，不能使用 <code>[[NSAutoreleasePool alloc] init]</code>，而应当使用 @autoreleasepool</li>
<li>不要把大量循环操作放到同一个 NSAutoreleasePool 之间，这样会造成内存峰值的上升</li>
<li>尽量避免对大内存使用该方法，对于这种延迟释放机制，还是尽量少用</li>
<li>SDK 中一般利用静态方法创建并返回的对象都是已经 autorelease 的，不需要再进行 release 操作。如 <code>[NSNumber numberWithInt:10];</code> 返回的对象是不需要再 release 的。但是通过 <code>[[NSNumber alloc] initWithInt:10]</code> 创建的对象需要 release</li>
</ol>
<p>Category:</p>
<ol>
<li>OC 提供了一种与众不同的方式—— Category，可以动态地为已经存在的类添加新的行为(方法)</li>
<li>这样可以保证类的原始设计规模较小，功能增加时再逐步扩展</li>
<li>使用 Category 对类进行扩展时，不需要创建子类</li>
<li>Category 使用简单的方式，实现了类的相关方法的模块化，把不同的类方法分配到不同的分类文件中</li>
</ol>
<p>创建一个 Category 也很简单， <strong>File -&gt; New -&gt; File…</strong> ，选择 Source 下的 Objective-C File，点击 Next，File 取名为你要分类的名称，比如写 Test，File Type 选择为 Category，Class 输入你要扩展的类，然后就一直点击 Next，创建好了 Category，文件名为 Student+Test.h 和 Student+Test.m，Student+Test.h 内容大致如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Student+Test.m 内容大致如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><code>()</code> 代表这是一个分类，括号中的 Test 代表分类的名称，在 Student+Test.h 中添加一个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test2;</span><br></pre></td></tr></table></figure>

<p>这样就将 Student 类扩展了一个 test2 的方法了，test2 的实现写在 Student+Test.m 中</p>
<p>Category 的作用：在不改变原来类内容的基础上，可以为类增加一些方法<br>Category 只能扩展方法，不能增加成员变量<br>Category 方法实现中可以访问原来类中声明的成员变量<br>Category 也能给系统的类扩展方法<br>Category 可以重新实现原来类中的方法，但是会覆盖掉原来的方法，导致原来的方法不能再使用<br>方法调用的优先级： <strong>分类（最后编译的优先） -&gt; 原来类 -&gt; 父类</strong><br>如果多个 Category 重复定义了同名的方法，会执行最后编译的 Category 的方法</p>
<p>Protocol：</p>
<ol>
<li>简单来说就是一系列方法的列表，其中声明的方法可以被任何类实现。这种模式一般称为代理 (delegation) 模式</li>
<li>在 iOS 和 OS X 开发中，Apple 采用了大量的代理模式来实现 MVC 中的 View(UI 控件) 和 Conroller(控制器) 的解耦</li>
</ol>
<ul>
<li>协议的定义</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> 协议名称 &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">    <span class="comment">// 方法声明列表</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如何遵守协议<ol>
<li>类遵守协议<br> @interface 类名 :  父类名 &lt;协议名称1, 协议名称2&gt;<br> @end</li>
<li>协议遵守协议<br> @protocol 协议名称 &lt;其他协议名称1, 其他协议名称2&gt;<br> @end</li>
<li>协议中方法声明的关键字<ol>
<li>@required（默认），要求时限，如果没有实现，会发出警告</li>
<li>@optional，不要求实现，不会有警告</li>
</ol>
</li>
<li>定义一个变量的时候，限制这个变量保存的对象遵守某个协议<br> 类名&lt;协议名称&gt; *变量名;<br> id&lt;协议名称&gt; 变量名;<br> NSObject<MyProtocol> *obj;<br> id<MyProtocol> obj2;<br> 如果没有遵守对应的协议，编译器会警告</li>
<li>@property 中声明的属性也可用做一个遵守协议的限制<br> @property (nonatomic, strong) 类名&lt;协议名称&gt; *属性名;<br> @property (nonatomic, strong) id&lt;协议名称&gt; 属性名;<br> @property (nonatomic, strong) Dog<MyProtocol> *dog;<br> @property (nonatomic, strong) id<MyProtocol> dog2;</li>
<li>协议可以定义在单独的 .h 文件中，也可以定义在某个类中<ol>
<li>如果这个协议只用在某个类中，应该把这个协议定义在该类中</li>
<li>如果这个协议用在很多类中，应该把这个协议定义在单独的文件中</li>
</ol>
</li>
<li>分类可以定义在单独 .h 文件和 .m 文件中，也可以定义在原来的类中<ol>
<li>一般情况下，都是定义在单独 .h 文件中</li>
<li>定义在原来的类中的分类，只要求能看懂语法</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>Button.h 主要代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;&gt;代表实现某个协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ButtonDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="type">void</span>)onClick;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Button</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate 就是按钮的监听器</span></span><br><span class="line">@portocol (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="type">id</span>&lt;ButtonDelegate&gt; delagate;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)click;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Button.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Button</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [_delegate release];</span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)click &#123;</span><br><span class="line">    <span class="comment">// 按钮被点击了，就应该通知监听器</span></span><br><span class="line">    [_delegate onclick];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>ButtonListener.h：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Button.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ButtonListener</span> : <span class="title">NSObject</span> &lt;<span class="title">ButtonDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>ButtonListener.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ButtonListener</span></span></span><br><span class="line">- (<span class="type">void</span>)onClick&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;按钮被点击了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>main.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Button.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;ButtonListener.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化一个按钮</span></span><br><span class="line">        Button *button = [[[Button alloc] init] autorelease];</span><br><span class="line">        <span class="comment">// 初始化一个按钮的监听器</span></span><br><span class="line">        ButtonListener *listener = [[[ButtonListener alloc] init] autorelease];</span><br><span class="line">        <span class="comment">// 设置按钮的监听器</span></span><br><span class="line">        button.delegate = listener;</span><br><span class="line">        <span class="comment">// 点击按钮</span></span><br><span class="line">        [button click];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Study</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">// @required 表示此方法是必须实现的</span></span><br><span class="line"><span class="comment">// 虽然字面上说是必须实现，但是编译器并不强求某个类实现</span></span><br><span class="line"><span class="comment">// 默认就是 @required</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="type">void</span>)test;</span><br><span class="line"><span class="comment">// @optional 表示此方法是可选实现的</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="type">void</span>)test2;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>判断某个对象是否有遵守某个 protocol：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([stu confirmsToProtocl:<span class="class"><span class="keyword">@protocol</span>(<span class="title">protocol</span> <span class="title">name</span>)]) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否实现了某个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(onClick:)]) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Block：</p>
<ol>
<li>Block 封装了一段代码，可以在任何时候执行</li>
<li>Block 可以作为函数参数或者函数的返回值，而其本身又可以带输入参数或返回值。它和传统的函数指针很类似，但是有区别：block 是 inline(内联函数) 的，并且默认情况下它对局部变量时只读的</li>
<li>苹果官方建议尽量多用 block。在多线程、异步任务、集合遍历、集合排序、动画转场用的很多</li>
</ol>
<p>例如定义一个 a + b 的 Block：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (^Sum) (<span class="type">int</span>, <span class="type">int</span>) = ^(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s = Sum(<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>

<p>或者这样定义也行：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> (^MySum) (<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> test() &#123;</span><br><span class="line">    MySum sum = ^(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用也和之前一样：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s = sum(<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>Block 可以访问外部定义的局部变量，但是不能修改：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> test() &#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">15</span>;</span><br><span class="line">    MySum sum = ^(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;c = %i&quot;</span>, c);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要修改  c的值的话，将 c 声明为： <code>__block int c = 15;</code> 前面有两个下划线 <code>_</code></p>
<p>直接访问成员变量，该变量的声明必须是 @public：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Student *stu = [[[Student alloc] init] autorelease];</span><br><span class="line">stu-&gt;age = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>指向函数的指针</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = sum;</span><br><span class="line"><span class="type">int</span> d = p(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>方法和函数的区别：<br>方法：</p>
<ol>
<li>对象方法都是以减号 - 开头，类方法都是以 + 开头</li>
<li>对象方法的声明必须写在 @interface 和 @end 之间，对象方法的实现必须写在 @implementation 和 @end 之间</li>
<li>对象方法只能由对象来调用，类方法只能由类来调用</li>
<li>对象方法归类&#x2F;对象所有</li>
<li>对象方法中能访问当前对象的成员变量（实例变量）；类方法中不能访问成员变量（实例变量）</li>
</ol>
<p>函数：</p>
<ol>
<li>函数能写在文件中的任意位置（@interface 和 @end 之间），函数归文件所有</li>
<li>函数调用不依赖于对象</li>
<li>函数内部不能直接通过成员变量名访问某个对象的成员变量</li>
</ol>
<p>继承的使用场合：</p>
<ol>
<li>当两个类拥有相同的属性和方法，就可以将相同的东西抽取到一个父类中</li>
<li>当 A 类完全拥有和 B 类中的部分属性和方法时，可以考虑让 B 类继承 A 类</li>
</ol>
<p>多态：</p>
<ol>
<li>没有继承就没有多态</li>
<li>代码的体现：父类类型的指针指向子类对象</li>
<li>好处：如果函数&#x2F;方法参数中使用的是父类类型，可以传入父类、子类对象</li>
<li>局限性：<ol>
<li>父类类型的变量不能调用子类特有的方法，必须强制类型转换为子类类型的变量之后才能调用<br>强制类型转换</li>
</ol>
</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Animal *a = [Dog new];</span><br><span class="line">Dog *d = (Dog *)a;</span><br></pre></td></tr></table></figure>

<p>成员变量的作用域：</p>
<ul>
<li>@public：在任何地方都能直接访问对象的成员变量</li>
<li>@private：只能在当前类的对象中直接访问（@implementation 中默认就是 @private）</li>
<li>@protected：可以再当前类及子类的对象方法中直接访问（@interface 中默认就是 @protected）</li>
<li>@package：只要处在同一个框架中，就能直接访问对象的成员变量</li>
</ul>
<p>@implementation 中不能定义和 @interface 中同名的成员变量</p>
<p>NSString 是不可变的</p>
<ul>
<li>NSString 的创建：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种方式创建出来的字符串是不需要释放的</span></span><br><span class="line"><span class="built_in">NSString</span> *str1 = <span class="string">@&quot;A String!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *str2 = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line">str2 = <span class="string">@&quot;A String!&quot;</span>;</span><br><span class="line">[str2 release];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *str3 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@&quot;A String!&quot;</span>];</span><br><span class="line">[str3 release];</span><br><span class="line"><span class="comment">// 不需要管理内存</span></span><br><span class="line">str3 = [<span class="built_in">NSString</span> stringWithString:<span class="string">@&quot;A String!&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *str4 = [[<span class="built_in">NSString</span> alloc] initWithUTF8String:<span class="string">@&quot;A String!&quot;</span>];</span><br><span class="line">[str4 release];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *str5 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;My nameis %s and age is %i&quot;</span>, <span class="string">&quot;mlb&quot;</span>, <span class="number">21</span>];</span><br><span class="line"><span class="comment">// 这行代码放在中间会造成2个错误</span></span><br><span class="line"><span class="comment">// 1、前面创建的字符串没有被释放</span></span><br><span class="line"><span class="comment">// 2、后面创建的字符串会释放2次，造成野指针错误</span></span><br><span class="line"><span class="comment">// *str5 = [[NSString alloc] stringWithFormat:@&quot;My nameis %s and age is %i&quot;, &quot;mlb&quot;, 21];</span></span><br><span class="line">[str5 release];</span><br><span class="line">*str5 = [[<span class="built_in">NSString</span> alloc] stringWithFormat:<span class="string">@&quot;My nameis %s and age is %i&quot;</span>, <span class="string">&quot;mlb&quot;</span>, <span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取文本</span></span><br><span class="line"><span class="built_in">NSString</span> *path = <span class="string">@&quot;/Users/HelloWorld/Desktop/test.txt&quot;</span>;</span><br><span class="line"><span class="comment">// 这个方法已经过期，不能解析中文</span></span><br><span class="line"><span class="comment">// NSString *str1 = [NSString stringWithContentsOfFile:path];</span></span><br><span class="line"><span class="comment">// 定义一个 NSError 变量</span></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="comment">// 指定字符串编码为 UTF-8：NSUTF8StringEncoding</span></span><br><span class="line"><span class="built_in">NSString</span> *str1 = [<span class="built_in">NSString</span> stringWithContentsOfFile:path encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, str1);</span><br><span class="line"><span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;读取文件成功：%@&quot;</span>, str1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;读取文件失败：@error&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的导出：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;123456&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *path = <span class="string">@&quot;/Users/HelloWorld/Desktop/test.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="comment">// 编码指定错误也会报错</span></span><br><span class="line"><span class="comment">// YES 代表要进行原子性操作，也就是会创建一个中间的临时文件</span></span><br><span class="line">[str writeToFile:path atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;写入失败：%@&quot;</span>, error); <span class="comment">// error 写成 [error localizedDescription] 可以返回主要的报错信息</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;写入成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NSString 的常用方法：</p>
<ul>
<li>字符串的大小写处理：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;HelloWorld&quot;</span>;</span><br><span class="line"><span class="comment">// 转成大写</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;大写：%@&quot;</span>, [str uppercaseString]);</span><br><span class="line"><span class="comment">// 转成小写</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;小写：%@&quot;</span>, [str lowercaseString]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;helloWorld 首字母变大写：%@&quot;</span>, [<span class="string">@&quot;helloWorld&quot;</span> capitalizedString]);</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的比较：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测字符串的内容是否相同</span></span><br><span class="line"><span class="type">BOOL</span> result = [<span class="string">@&quot;abc&quot;</span> isEqualToString:<span class="string">@&quot;abc&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%i&quot;</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSOrderedAscending 右边的字符串比左边的大</span></span><br><span class="line"><span class="comment">// NSOrderedSame 两个字符串的内容相同</span></span><br><span class="line"><span class="comment">// NSOrderDescending 左边的字符串比右边的大</span></span><br><span class="line"><span class="comment">// 忽略大小写比较：[@&quot;abc&quot; caseInsensitiveCompare:@&quot;Abc&quot;];</span></span><br><span class="line"><span class="built_in">NSComparisonResult</span> result2 = [<span class="string">@&quot;abc&quot;</span> compare:<span class="string">@&quot;Abc&quot;</span>];</span><br><span class="line"><span class="keyword">if</span> (result2 == <span class="built_in">NSOrderedSame</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;两个字符串的内容&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result2 == <span class="built_in">NSOrderedAscending</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;右边 &gt; 左边&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result2 == <span class="built_in">NSOrderDescending</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;右边 &lt; 左边&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的搜索：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;123456456.txt&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;是否以12开头：%i&quot;</span>, [str hasPrefix:<span class="string">@&quot;12&quot;</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;是否以txt结尾：%i&quot;</span>, [str hasSuffix:<span class="string">@&quot;txt&quot;</span>]);</span><br><span class="line"><span class="comment">// 从头开始搜索</span></span><br><span class="line"><span class="built_in">NSRange</span> range = [str rangeOfString:<span class="string">@&quot;345&quot;</span>];</span><br><span class="line"><span class="comment">// range.length == 0</span></span><br><span class="line"><span class="keyword">if</span> (range.location == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;没有找到&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;找到，范围是：%@&quot;</span>, <span class="built_in">NSStringFromRange</span>(range));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从尾部开始搜索</span></span><br><span class="line">range = [str rangeOfString:<span class="string">@&quot;456&quot;</span> options:<span class="built_in">NSBackwardsSearch</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;从尾部开始搜索，找到，范围是：%@&quot;</span>, <span class="built_in">NSStringFromRange</span>(range));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定范围开始搜索字符串方法</span></span><br><span class="line">[str rangeOfString:<span class="string">@&quot;456&quot;</span> options:<span class="built_in">NSBackwardsSearch</span> range:(<span class="built_in">NSRange</span>)];</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的截取：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;123456&quot;</span>;</span><br><span class="line"><span class="comment">// 从索引3开始截取到尾部（包括3）</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str substringFromIndex:<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 从头部开始截取到索引3之前（不包括3）</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str substringToIndex:<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 指定范围进行截取</span></span><br><span class="line"><span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str substringWithRange:range]);</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的拆分：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str2 = <span class="string">@&quot;1,2,3,4,5,6&quot;</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *array = [str2 componentsSeparatedByString:<span class="string">@&quot;,&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, array);</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串与路径：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速创建一个自动释放的数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *components = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">[components addObject:<span class="string">@&quot;Users&quot;</span>];</span><br><span class="line">[components addObject:<span class="string">@&quot;HelloWorld&quot;</span>];</span><br><span class="line">[components addObject:<span class="string">@&quot;Desktop&quot;</span>];</span><br><span class="line"><span class="comment">// 将数组中的所有字符串拼接成一个路径</span></span><br><span class="line"><span class="built_in">NSString</span> *path = [<span class="built_in">NSString</span> pathWithComponents:components];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, path);</span><br><span class="line"><span class="comment">// 将路径分解成数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *cmps = [path pathConponents];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, cmps);</span><br><span class="line"><span class="comment">// 判断是否为绝对路径</span></span><br><span class="line">path = <span class="string">@&quot;/Users/HelloWorld/test/test.txt&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%i&quot;</span>, [path isAbsolutePath]);</span><br><span class="line"><span class="comment">// 返回路径的最后一个文件夹</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;最后一个目录：%@&quot;</span>, [path lastPathComponent]);</span><br><span class="line"><span class="comment">// 删除最后一个文件夹目录并返回一个新的路径</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [path stringByDeletingLastPathComponent]);</span><br><span class="line"><span class="comment">// 在最后面拼接一个目录</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [path stringByAppandingPathComponent:<span class="string">@&quot;abc&quot;</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>扩展名处理：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = <span class="string">@&quot;/Users/HelloWorld/test/test.txt&quot;</span>;</span><br><span class="line"><span class="comment">// 获取扩展名</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;扩展名：%@&quot;</span>, [path pathExtension]);</span><br><span class="line"><span class="comment">// 删除扩展名</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [path stringByDeletingPathExtension]);</span><br><span class="line"><span class="comment">// 拼接扩展名，只是在尾部添加了扩展名字符串，并不会检测原先是否有扩展名</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [<span class="string">@&quot;abc&quot;</span> stringByAppendingPathExtension:<span class="string">@&quot;mp3&quot;</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>其他用法：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串转成int类型</span></span><br><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;12&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = [str intValue];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%i&quot;</span>, a);</span><br><span class="line"><span class="comment">// 求字符串的长度，是字数而不是字符数</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;length = %zi&quot;</span>, [<span class="string">@&quot;我是字符串&quot;</span>, length]);</span><br><span class="line"><span class="comment">// 取出指定下标的字符</span></span><br><span class="line"><span class="type">unichar</span> c = [<span class="string">@&quot;abcd&quot;</span> characterAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%c&quot;</span>, c);</span><br><span class="line"><span class="comment">// 将 OC 字符串转成 C 语言中的字符串（char *）</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *s = [<span class="string">@&quot;abc&quot;</span>, UTF8String];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>NSMutableString</p>
<ol>
<li>NSString 是不可变的，不能删除字符或者添加字符。NSString 有一个子类 NSMutableString，称为“可变字符串”</li>
<li>创建可变字符串的常用方法：<ol>
<li><code>- (id)initWithCapacity:(NSUInteger)capacity</code></li>
<li><code>+ (id)stringWithCapacity:(NSUInteger)capacity</code></li>
</ol>
</li>
<li>capacity 只是一个最优值，字符串的大小并不仅限于所提供的容量，设置了 capacity，可以预分配一块内存来存储它，操作速度会快很多</li>
<li>当然，也可以使用创建 NSString 的方法来创建 NSMutableString，因为 NSMutableString 是 NSString 的子类，NSString 能用的方法，NSMutableString 都能使用</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变字符串的创建</span></span><br><span class="line"><span class="comment">// 预先分配10个字数的空间</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *str = [[<span class="built_in">NSMutableString</span> alloc] initWithCapacity:<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 设置字符串内容</span></span><br><span class="line">[str setString:<span class="string">@&quot;1234&quot;</span>];</span><br><span class="line"><span class="comment">// 拼接字符串</span></span><br><span class="line">[str appendString:<span class="string">@&quot;567&quot;</span>];</span><br><span class="line">[str appendFormat:<span class="string">@&quot;age is %i and name is %s&quot;</span>, <span class="number">21</span>, <span class="string">&quot;mlb&quot;</span>];</span><br><span class="line"><span class="comment">// 替换字符串</span></span><br><span class="line"><span class="comment">// 先找到要替换的字符串的范围</span></span><br><span class="line"><span class="built_in">NSRange</span> range = [str rangeOfString:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">[str replaceCharactersinRange:range withString:<span class="string">@&quot;years&quot;</span>];</span><br><span class="line"><span class="comment">// 插入字符串</span></span><br><span class="line">[str insertString:<span class="string">@&quot;abc&quot;</span> atIndex:<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 删除字符串</span></span><br><span class="line">range = [str rangeOfString:<span class="string">@&quot;567&quot;</span>];</span><br><span class="line">[str deleteCharactersInRange:range];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, str);</span><br><span class="line">[str release];</span><br></pre></td></tr></table></figure>

<p>NSArray</p>
<ol>
<li>用来存储对象的有序列表，它是不可变的</li>
<li>不能存储C语言中的基本数据类型，如 int、float、enum、struct，也不能存储 nil</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> array];</span><br><span class="line"><span class="comment">// 创建一个有一个元素的数组</span></span><br><span class="line">array = [<span class="built_in">NSArray</span> arrayWithObject:<span class="string">@&quot;123&quot;</span>];</span><br><span class="line"><span class="comment">// 创建有多个元素的数组，nil代表创建结束</span></span><br><span class="line">array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;a&quot;</span>, <span class="string">@&quot;b&quot;</span>, <span class="string">@&quot;c&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 获取数组长度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count = [array count];</span><br><span class="line"><span class="comment">// count = array.count;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%zi&quot;</span>, count);</span><br></pre></td></tr></table></figure>

<ul>
<li>数组的简单使用：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;a&quot;</span>, <span class="string">@&quot;b&quot;</span>, <span class="string">@&quot;c&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 判断是否包含了某个元素</span></span><br><span class="line"><span class="keyword">if</span> ([array containsObject:<span class="string">@&quot;bc&quot;</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;包含了字符串bc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回数组最后一个元素</span></span><br><span class="line"><span class="built_in">NSString</span> *last = [array lastObject];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;last = %@&quot;</span>, last);</span><br><span class="line"><span class="comment">// 返回指定下标的元素</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [array objectAtIndex:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;str = %@&quot;</span>, str);</span><br><span class="line"><span class="comment">// 查询某个元素的下标</span></span><br><span class="line"><span class="type">int</span> index = [array indexOfObject:<span class="string">@&quot;c&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;index  = %i&quot;</span>, index);</span><br></pre></td></tr></table></figure>

<ul>
<li>数组的内存管理：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Student *stu1 = [[Student alloc] init];</span><br><span class="line">Student *stu2 = [[Student alloc] init];</span><br><span class="line">Student *stu3 = [[Student alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;stu1:%zi&quot;</span>, [stu1 retainCount]);</span><br><span class="line"><span class="comment">// 当把一个对象添加进数组中时，这个对象的引用计数器会加1，也就是说数组会对它做一个 retain 操作</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [[<span class="built_in">NSArray</span> alloc] initWithObjects:stu1, stu2, stu3, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;stu1:%zi&quot;</span>, [stu1 retainCount]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;count = %zi&quot;</span>, array.count);</span><br><span class="line"><span class="comment">// 数组被销毁的时候，会对内部的所有元素做一次 release 操作</span></span><br><span class="line">[array release];</span><br><span class="line">[stu1 release];</span><br><span class="line">[stu2 release];</span><br><span class="line">[stu3 release];</span><br></pre></td></tr></table></figure>

<p>NSArray 的比较：</p>
<ol>
<li>比较两个集合内容是否相同<br><code>- (BOOL)isEqualToArray:(NSArray *)otherArray</code></li>
<li>返回两个集合中第一个相同的对象元素<br><code>- (id)firstObjectCommonWithArray:(NSArray *)otherArray</code></li>
</ol>
<ul>
<li>给数组里面的元素发送消息：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让数组里面的所有对象都调用某个方法</span></span><br><span class="line">[array makeObjectsPerformSelector:<span class="keyword">@selector</span>(function name)];</span><br><span class="line"><span class="comment">// 也可以传入参数</span></span><br><span class="line">[array makeObjectsPerformSelector:<span class="keyword">@selector</span>(function name:) withObject:<span class="string">@&quot;123&quot;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历数组</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;a&quot;</span>, <span class="string">@&quot;b&quot;</span>, <span class="string">@&quot;c&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count = array.count;</span><br><span class="line"><span class="comment">// 第一种方法：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="comment">// id == void *</span></span><br><span class="line">    <span class="type">id</span> obj = [array objectAtIndex:i];</span><br><span class="line">    <span class="built_in">NSlog</span>(<span class="string">@&quot;%i - %@&quot;</span>, i, obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种方法：</span></span><br><span class="line"><span class="comment">// 快速遍历</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">id</span> obj <span class="keyword">in</span> array) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%i - %@&quot;</span>, i, obj);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种方法：</span></span><br><span class="line">[array enumerateObjectsUsingBlock:</span><br><span class="line">    ^(<span class="type">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%zi - %@&quot;</span>, idx, obj);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用指针修改外部 BOOL 变量的值</span></span><br><span class="line">            *stop = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 第四种方法：</span></span><br><span class="line"><span class="comment">// 获取数组的迭代器</span></span><br><span class="line"><span class="built_in">NSEnumerator</span> *enumerator = [array objectEnumerator];</span><br><span class="line"><span class="comment">// 获取下一个需要遍历的元素</span></span><br><span class="line"><span class="type">id</span> obj = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">while</span> (obj = [enumerator nextObject]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;obj = %@&quot;</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序迭代器</span></span><br><span class="line"><span class="built_in">NSEnumerator</span> *reverseEnumerator = [array reverseObjectEnumerator];</span><br><span class="line"></span><br><span class="line"><span class="comment">// allObjects 是取出没有被遍历过的对象</span></span><br><span class="line"><span class="built_in">NSArray</span> *arr = [enumerator allObjects];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;arr: %@&quot;</span>, arr);</span><br></pre></td></tr></table></figure>

<ul>
<li>派生出新的数组</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;a&quot;</span>, <span class="string">@&quot;b&quot;</span>, <span class="string">@&quot;c&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *array2 = [array arrayByAddingObject:<span class="string">@&quot;d&quot;</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *array3 = [array arrayByAddingObjectsFromArray:[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;e&quot;</span>, <span class="string">@&quot;f&quot;</span>, <span class="literal">nil</span>]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array = %@&quot;</span>, array);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array2 = %@&quot;</span>, array2);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array3 = %@&quot;</span>, array3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *array4 = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;1&quot;</span>, <span class="string">@&quot;2&quot;</span>, <span class="string">@&quot;3&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 截取某个数组中的元素并返回一个新的数组</span></span><br><span class="line"><span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">NSArray</span> *array5 = [array4 subarrayWithRange:range];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array5 = %@&quot;</span>, array5);</span><br></pre></td></tr></table></figure>

<ul>
<li>NSArray其他用法：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;a&quot;</span>, <span class="string">@&quot;b&quot;</span>, <span class="string">@&quot;c&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 利用 separator 作为拼接符将数组元素拼接成一个字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [array componentsJoinedByString:<span class="string">@&quot;-&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;str = %@&quot;</span>, str);</span><br><span class="line"><span class="comment">// 把数组写入文件中，生成的是 XML 格式的文件</span></span><br><span class="line"><span class="built_in">NSString</span> *path = <span class="string">@&quot;/Users/HelloWorld/test/array.xml&quot;</span>;</span><br><span class="line">[array writeToFile:path atomically:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取数组内容（文件内容有严格的格式要求）</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:path];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array = %@&quot;</span>, array);</span><br></pre></td></tr></table></figure>

<ul>
<li>NSArray排序</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;2&quot;</span>, <span class="string">@&quot;3&quot;</span>, <span class="string">@&quot;1&quot;</span>, <span class="string">@&quot;4&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 没有排序输出</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array = %@&quot;</span>, array);</span><br><span class="line"><span class="comment">// 返回一个排好序的数组，原来的数组的元素顺序不会改变</span></span><br><span class="line"><span class="comment">// 指定元素的比较方法，默认从小到大排序</span></span><br><span class="line"><span class="built_in">NSArray</span> *sortArray = [array sortedArrayUsingSelector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;sortArray = %@&quot;</span>, sortArray);</span><br></pre></td></tr></table></figure>

<ul>
<li>对象的比较排序：</li>
</ul>
<p>Book.h：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)bookWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Book.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">+ (<span class="type">id</span>)bookWithName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    Book *book = [[[Book alloc] init] autorelease];</span><br><span class="line">    book.name = name;</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [_name release];</span><br><span class="line">    [<span class="variable language_">super</span> release];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Student.h：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Book</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) Book *book;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)studentWithFirstName:(<span class="built_in">NSString</span> *)firstname lastname:(<span class="built_in">NSString</span> *)lastname;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)studentWithFirstName:(<span class="built_in">NSString</span> *)firstname lastname:(<span class="built_in">NSString</span> *)lastname bookName:(<span class="built_in">NSString</span> *)bookName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值类型为 NSComparisonResult</span></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)compareStudent:(Student *)stu;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Student.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)studentWithFirstName:(<span class="built_in">NSString</span> *)firstname lastname:(<span class="built_in">NSString</span> *)lastname &#123;</span><br><span class="line">    Student *stu = [[[Student alloc] init] autorelease];</span><br><span class="line">    stu.firstName = firstname;</span><br><span class="line">    stu.lastName = lastname;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)studentWithFirstName:(<span class="built_in">NSString</span> *)firstname lastname:(<span class="built_in">NSString</span> *)lastname bookName:(<span class="built_in">NSString</span> *)bookName &#123;</span><br><span class="line">    Student stu = [Student studentWithFirstName:firstname lastName:lastname];</span><br><span class="line">    stu.book = [Book bookWithName:bookName];</span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSComparisonResult</span>)compareStudent:(Student *)stu &#123;</span><br><span class="line">    <span class="comment">// 先按照姓排序</span></span><br><span class="line">    <span class="built_in">NSComparisonResult</span> result = [<span class="keyword">self</span>.lastName compare:stu.lastName]</span><br><span class="line">    <span class="comment">// 如果有相同的姓，就比较名字</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="built_in">NSOrderedSame</span>) &#123;</span><br><span class="line">        result = [<span class="keyword">self</span>.firstName compare:stu.firstName];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [_firstName release];</span><br><span class="line">    [_lastName release];</span><br><span class="line">    [_book release];</span><br><span class="line">    [<span class="variable language_">super</span> release];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) description &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;[%@ %@ - %@]&quot;</span>, <span class="keyword">self</span>.lastName, <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.book.name];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>main.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Student *s1 = [Student studentWithFirstName:<span class="string">@&quot;LeBin&quot;</span> lastName:<span class="string">@&quot;Mei&quot;</span>];</span><br><span class="line">Student *s2 = [Student studentWithFirstName:<span class="string">@&quot;JiBin&quot;</span> lastName:<span class="string">@&quot;Chen&quot;</span>];</span><br><span class="line">Student *s3 = [Student studentWithFirstName:<span class="string">@&quot;BinBin&quot;</span> lastName:<span class="string">@&quot;Chi&quot;</span>];</span><br><span class="line">Student *s4 = [Student studentWithFirstName:<span class="string">@&quot;Bi&quot;</span> lastName:<span class="string">@&quot;Xue&quot;</span>];</span><br><span class="line">Student *s5 = [Student studentWithFirstName:<span class="string">@&quot;Bin&quot;</span> lastName:<span class="string">@&quot;Xu&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:s1, s2, s3, s4, s5, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 指定排序的比较方法</span></span><br><span class="line"><span class="built_in">NSArray</span> *array2 = [array sortedArrayUsingSelector:<span class="keyword">@selector</span>(compareStudent:)];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array2 = %@&quot;</span>, array2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="comment">// 利用Block进行排序</span></span><br><span class="line"><span class="built_in">NSArray</span> *array3 = [array sortedArrayUsingComparator:</span><br><span class="line">    ^<span class="built_in">NSComparisonResult</span>(Student *obj1, Student *obj2) &#123;</span><br><span class="line">        <span class="comment">// 先按照姓排序</span></span><br><span class="line">        <span class="built_in">NSComparisonResult</span> result = [<span class="keyword">self</span>.lastName compare:stu.lastName]</span><br><span class="line">        <span class="comment">// 如果有相同的姓，就比较名字</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="built_in">NSOrderedSame</span>) &#123;</span><br><span class="line">            result = [<span class="keyword">self</span>.firstName compare:stu.firstName];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array3 = %@&quot;</span>, array3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外一种排序，多属性</span></span><br><span class="line">Student *s1 = [Student studentWithFirstName:<span class="string">@&quot;LeBin&quot;</span> lastName:<span class="string">@&quot;Mei&quot;</span> bookName:<span class="string">@&quot;book1&quot;</span>];</span><br><span class="line">Student *s2 = [Student studentWithFirstName:<span class="string">@&quot;JiBin&quot;</span> lastName:<span class="string">@&quot;Chen&quot;</span> bookName:<span class="string">@&quot;book2&quot;</span>];</span><br><span class="line">Student *s3 = [Student studentWithFirstName:<span class="string">@&quot;BinBin&quot;</span> lastName:<span class="string">@&quot;Chi&quot;</span> bookName:<span class="string">@&quot;book1&quot;</span>];</span><br><span class="line">Student *s4 = [Student studentWithFirstName:<span class="string">@&quot;Bi&quot;</span> lastName:<span class="string">@&quot;Xue&quot;</span> bookName:<span class="string">@&quot;book2&quot;</span>];</span><br><span class="line">Student *s5 = [Student studentWithFirstName:<span class="string">@&quot;Bin&quot;</span> lastName:<span class="string">@&quot;Xu&quot;</span> bookName:<span class="string">@&quot;book3&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:s1, s2, s3, s4, s5, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.先按照书名进行排序</span></span><br><span class="line"><span class="built_in">NSSortDescriptor</span> *bookNameDesc = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@&quot;book.name&quot;</span> ascending:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 2.再按照姓进行排序</span></span><br><span class="line"><span class="built_in">NSSortDescriptor</span> *lastNameDesc = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@&quot;lastName&quot;</span> ascending:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 3.最后按照名进行排序</span></span><br><span class="line"><span class="built_in">NSSortDescriptor</span> *firstNameDesc = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@&quot;firstName&quot;</span> ascending:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 按顺序添加排序描述器</span></span><br><span class="line"><span class="built_in">NSArray</span> *descs = [<span class="built_in">NSArray</span> arrayWithObjects:bookNameDesc, lastNameDesc , firstNameDesc , <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *array2 = [array sortedArrayUsingDescriptors:descs];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array2 = %@&quot;</span>, array2);</span><br></pre></td></tr></table></figure>

<p>NSMutableArray</p>
<ol>
<li>可变的 NSArray，NSArray 的子类，可以随意的添加或者删除元素</li>
<li>创建 NSMutableArray 的方法：<ol>
<li><code>+ (id)arrayWithCapacity:(NSUInteger)numItems</code></li>
<li><code>- (id)initWithCapacity:(NSUInteger)numItems</code></li>
</ol>
</li>
<li>也可以使用创建 NSArray 的方法来创建 NSMutableArray</li>
<li>当一个元素被加到集合中时，会执行一次 retain 操作；当一个元素从集合中移除时，会执行一次 release 操作；当集合被销毁时（调用了 dealloc），集合里的所有元素都会执行一次 release 操作（这个原则还适用于其他集合：NSDictionary&#x2F;NSSet 等）</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 NSMutableArray</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithObject:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line"><span class="comment">// 添加元素，对被添加的元素会做一次 retain 操作，引用计数器加 1</span></span><br><span class="line">[array addObject:<span class="string">@&quot;2&quot;</span>];</span><br><span class="line">[array addObject:<span class="string">@&quot;3&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, array);</span><br><span class="line"><span class="comment">// 删除元素，对被删除的元素做一次 release 操作，引用计数器减 1</span></span><br><span class="line"><span class="comment">// 删除指定元素</span></span><br><span class="line">[array removeObject:<span class="string">@&quot;2&quot;</span>];</span><br><span class="line"><span class="comment">// 删除最后一个元素</span></span><br><span class="line">[array removeLastObject];</span><br><span class="line"><span class="comment">// 删除所有元素</span></span><br><span class="line">[array removeAllObject];</span><br><span class="line"><span class="comment">// 当数组被释放的时候，会对所有的元素都做一次 release 操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换指定下标的元素</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithObject:<span class="string">@&quot;1&quot;</span>, <span class="string">@&quot;2&quot;</span>, <span class="string">@&quot;3&quot;</span>];</span><br><span class="line">[array relaceObjectAtIndex:<span class="number">1</span> withObject:<span class="string">@&quot;4&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array = %@&quot;</span>, array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithObject:<span class="string">@&quot;1&quot;</span>, <span class="string">@&quot;3&quot;</span>, <span class="string">@&quot;2&quot;</span>];</span><br><span class="line"><span class="comment">// 因为是可变数组，所以不需要返回新的数组</span></span><br><span class="line">[array sortUsingSelector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;array = %@&quot;</span>, array);</span><br></pre></td></tr></table></figure>

<p>NSDictionary<br>通过唯一的 key 找到对应的 value，类似于 Java 的 Map</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典的初始化</span></span><br><span class="line"><span class="comment">// NSDiationary 是不可变的</span></span><br><span class="line"><span class="built_in">NSDiationary</span> *dict = [<span class="built_in">NSDiationary</span> dictionaryWithObject:<span class="string">@&quot;v&quot;</span> forKey:<span class="string">@&quot;k&quot;</span>];</span><br><span class="line">dict = [<span class="built_in">NSDiationary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">        <span class="string">@&quot;v1&quot;</span>, <span class="string">@&quot;k1&quot;</span>,</span><br><span class="line">        <span class="string">@&quot;v2&quot;</span>, <span class="string">@&quot;k2&quot;</span>,</span><br><span class="line">        <span class="string">@&quot;v3&quot;</span>, <span class="string">@&quot;k3&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *objects = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;v1&quot;</span>, <span class="string">@&quot;v2&quot;</span>, <span class="string">@&quot;v3&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *keys = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;k1&quot;</span>, <span class="string">@&quot;k2&quot;</span>, <span class="string">@&quot;k3&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">dict = [<span class="built_in">NSDiationary</span> dictionaryWithObjects:objects forKeys:keys];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, dict);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSDiationary 常用方法</span></span><br><span class="line"><span class="comment">// count 是计算有几个键值对 (key-value)</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;count = %zi&quot;</span>, dict.count);</span><br><span class="line"><span class="comment">// 由于 NSDiationary 是不可变的，所以只能取值，而不能修改值</span></span><br><span class="line"><span class="type">id</span> obj = [dict objectForKey];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;obj = %@&quot;</span>, obj);</span><br><span class="line"><span class="comment">// 将字典写入文件中，写入的格式是 XML 的</span></span><br><span class="line"><span class="built_in">NSString</span> *path = <span class="string">@&quot;/Users/HelloWorld/Desktop/dict.xml&quot;</span>;</span><br><span class="line">[dict writeToFile:path atomically:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 也可以从文件中读取，文件内容必须是 XML 格式</span></span><br><span class="line">dict = [<span class="built_in">NSDiationary</span> dictionalryWithContentsOfFile:path];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;dict = %@&quot;</span>, dict);</span><br><span class="line"><span class="comment">// 返回所有的 key</span></span><br><span class="line"><span class="built_in">NSArray</span> *keys = [dict allKeys];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;keys = %@&quot;</span>, keys);</span><br><span class="line"><span class="comment">// 返回所有的 value</span></span><br><span class="line"><span class="built_in">NSArray</span> *object = [dict allValues];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;objects = %@&quot;</span>, objects);</span><br><span class="line"><span class="comment">// 根据多个 key 取出对应的多个 value</span></span><br><span class="line"><span class="comment">// notFoundMarker 不能为 nil</span></span><br><span class="line">objects = [dict objectsForKeys:[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;k1&quot;</span>, <span class="string">@&quot;k2&quot;</span>, <span class="literal">nil</span>] notFoundMarker:<span class="string">@&quot;not_found&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;objects = %@&quot;</span>, objects);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字典</span></span><br><span class="line"><span class="built_in">NSDiationary</span> *dict = [<span class="built_in">NSDiationary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">        <span class="string">@&quot;v1&quot;</span>, <span class="string">@&quot;k1&quot;</span>,</span><br><span class="line">        <span class="string">@&quot;v2&quot;</span>, <span class="string">@&quot;k2&quot;</span>,</span><br><span class="line">        <span class="string">@&quot;v3&quot;</span>, <span class="string">@&quot;k3&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">id</span> key <span class="keyword">in</span> dict) &#123;</span><br><span class="line">    <span class="type">id</span> value = [dict objectForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ = %@&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="built_in">NSEnumerator</span> *enumer = [dict keyEnumerator];</span><br><span class="line"><span class="type">id</span> key = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">while</span> (key = [enumer nextObject]) &#123;</span><br><span class="line">    <span class="type">id</span> value = [dict objectForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ = %@&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象迭代器：[dict objectEnumerator]</span></span><br><span class="line"><span class="comment">// 第三种方法</span></span><br><span class="line">[dict enumerateKeysAndObjectsUsingBlock:</span><br><span class="line">        ^(<span class="type">id</span> key, <span class="type">id</span> obj, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ = %@&quot;</span>, key, obj);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>NSDiationary 的内存管理</p>
<p>Student.h：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">+ (<span class="type">id</span>)studentWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Student.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line">+ (<span class="type">id</span>)studentWithName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    Student *stu = [[[Student alloc] init] autorelease];</span><br><span class="line">    stu.name = name;</span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@被销毁了&quot;</span>, _name);</span><br><span class="line">    [_name release];</span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>main.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Student *s1 = [Student studentWithName:<span class="string">@&quot;student1&quot;</span>];</span><br><span class="line">Student *s2 = [Student studentWithName:<span class="string">@&quot;student2&quot;</span>];</span><br><span class="line">Student *s3 = [Student studentWithName:<span class="string">@&quot;student3&quot;</span>];</span><br><span class="line"><span class="comment">// 一个对象称为字典的 key 或者 value 时，会做一次 retain 操作，也就是引用计数器 +1</span></span><br><span class="line"><span class="built_in">NSDiationary</span> *dict = [<span class="built_in">NSDiationary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">        s1, <span class="string">@&quot;k1&quot;</span>,</span><br><span class="line">        s2, <span class="string">@&quot;k2&quot;</span>,</span><br><span class="line">        s3, <span class="string">@&quot;k3&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 当字典被销毁时，里面的所有 key 和 value 都会做一次 release 操作，也就是引用计数器 -1</span></span><br></pre></td></tr></table></figure>

<p>NSMutableDiationary</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变的字典的使用</span></span><br><span class="line"><span class="comment">// 创建一个空的字典</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">Student *s1 = [Student studentWithName:<span class="string">@&quot;student1&quot;</span>];</span><br><span class="line">Student *s2 = [Student studentWithName:<span class="string">@&quot;student2&quot;</span>];</span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="comment">// s1 的引用计数器会 +1</span></span><br><span class="line">[dict setObject:s1 forKey:<span class="string">@&quot;k1&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;s1: %zi&quot;</span>, [s1 retainCount]);</span><br><span class="line"><span class="comment">// 添加其他字典的键值对到一个字典中</span></span><br><span class="line"><span class="built_in">NSDiationary</span> *others = [<span class="built_in">NSDiationary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">        <span class="string">@&quot;v1&quot;</span>, <span class="string">@&quot;k1&quot;</span>,</span><br><span class="line">        <span class="string">@&quot;v2&quot;</span>, <span class="string">@&quot;k2&quot;</span>,</span><br><span class="line">        <span class="string">@&quot;v3&quot;</span>, <span class="string">@&quot;k3&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">[dict addEntriesFromDictionary:other];</span><br><span class="line"><span class="comment">// 删除所有的键值对</span></span><br><span class="line">[dict removeAllObjects];</span><br><span class="line"><span class="comment">// 删除key对应的键值对</span></span><br><span class="line">[dict removeObjectForKey:<span class="string">@&quot;k1&quot;</span>];</span><br><span class="line"><span class="comment">// 删除多个 key 对应的键值对</span></span><br><span class="line">[dict removeObjectsForKeys:[<span class="built_in">NSArray</span> arrayWithObject:<span class="string">@&quot;k1&quot;</span>]];</span><br><span class="line"><span class="comment">// 字典被销毁时，内部的所有 key 和 value 的引用计数器都会 -1，也就是说，s1 会被 release 一次</span></span><br></pre></td></tr></table></figure>

<p>NSNumber<br>NSNumber 可以将基本数据类型包装成对象，这样就可以间接将基本数据类型存进 NSArray、NSDictionary 等集合中</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 int 类型的数据包装成一个 NSNumber 对象</span></span><br><span class="line"><span class="built_in">NSNumber</span> *num = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">10</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;num = %@&quot;</span>, num);</span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="comment">// 添加数值到数组中</span></span><br><span class="line">[array addObject:number];</span><br><span class="line"><span class="comment">// 取出来还是一个 NSNumber 对象，不支持自动解包（也就是不会自动转化为 int 类型）</span></span><br><span class="line"><span class="built_in">NSNumber</span> *num1 = [array lastObject];</span><br><span class="line"><span class="comment">// 将 NSNumber 对象转化为 int 类型</span></span><br><span class="line"><span class="type">int</span> n = [num1 intValue];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;n = %i&quot;</span>, n);</span><br></pre></td></tr></table></figure>

<p>NSNumber 的常用方法</p>
<ol>
<li><code>- (char)charValue</code></li>
<li><code>- (int)intValue</code></li>
<li><code>- (double)doubleValue</code></li>
<li><code>- (BOOL)boolValue</code></li>
<li><code>- (NSString *)stringValue</code></li>
<li><code>- (NSComparisonResult)compare:(NSNumber *)otherNumber</code></li>
<li><code>- (BOOL)isEqualToNumber:(NSNumber *)number</code></li>
</ol>
<p>NSValue<br>NSNumber 是 NSValue 的子类，但 NSNumber 只能包装数字类型，NSValue 可以包装任意值。也就可以用 NSValue 包装结构体后加入 NSArray、NSDictionary 等集合中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGPoint</span> point = <span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 将结构体变量包装成一个对象</span></span><br><span class="line"><span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithPoint:point];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="comment">// 添加 value</span></span><br><span class="line">[array addObject:value];</span><br><span class="line"><span class="comment">//取出当时放进去的 value</span></span><br><span class="line"><span class="built_in">NSValue</span> *value1 = [array lastObject];</span><br><span class="line"><span class="built_in">CGPoint</span> point1 = [value1 pointValue];</span><br><span class="line"><span class="type">BOOL</span> result = <span class="built_in">CGPointEqualToPoint</span>(point1, point);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;result = %i&quot;</span>, result);</span><br><span class="line"><span class="comment">// 包装结构体变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125; Date;</span><br><span class="line"></span><br><span class="line">Date date = &#123;<span class="number">2014</span>, <span class="number">11</span>, <span class="number">27</span>&#125;;</span><br><span class="line"><span class="comment">// 这里要传结构体的地址 &amp;date</span></span><br><span class="line"><span class="comment">// 根据结构体类型生成对应的结构描述字符串</span></span><br><span class="line"><span class="type">char</span> *type = <span class="keyword">@encode</span>(Date);</span><br><span class="line">[<span class="built_in">NSValue</span> value:&amp;date, withObjCType:type];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体变量</span></span><br><span class="line">Date date1;</span><br><span class="line"><span class="comment">// 取出包装好的结构体</span></span><br><span class="line">[value getValue:&amp;date1];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;year = %i, month = %i, day = %i&quot;</span>, date1.year, date1.month, date1.day);</span><br></pre></td></tr></table></figure>

<p>NSNull</p>
<ol>
<li>集合中是不能存放 nil 值的，因为 nil 在集合中有特殊含义，但有时确实需要存储一个表示“什么都没有”的值，那么就可以使用 NSNull，它也是 NSObject 的一个子类</li>
<li>创建和获取 NSNull 的方法：<br> <code>+ (NSNull *)null</code></li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个null只有一个，也就是说多个NSNull对象，他们的地址是相同的</span></span><br><span class="line"><span class="built_in">NSNUll</span> *n = [<span class="built_in">NSNull</span> null];</span><br></pre></td></tr></table></figure>

<p>NSDate<br>NSDate 的静态初始化<br>TimeInterval 是秒</p>
<ol>
<li>返回当前时间：<br><code>+ (id)date</code></li>
<li>返回以当前时间为基准，然后过了 secs 秒的时间<br><code>+ (id)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs</code></li>
<li>返回以 2001&#x2F;01&#x2F;01 GMT 为基准，然后过了 secs 秒的时间<br><code>+ (id)dateWithTimeIntervalSinceReferenceDate:(NSTimeInterval)secs</code></li>
<li>返回以 1970&#x2F;01&#x2F;01 GMT 为基准，然后过了 secs 秒的时间<br><code>+ (id)dateWithTimeIntervalSince1970:(NSTimeInterval)secs</code></li>
<li>返回很多年以后的未来的某一天<br><code>+ (id)distantFuture</code></li>
<li>返回很多年以前的某一天<br><code>+ (id)distantPast</code></li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 日期创建</span></span><br><span class="line"><span class="comment">// date 方法返回的就是当前时间</span></span><br><span class="line"><span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="comment">// 日期使用</span></span><br><span class="line"><span class="comment">// now: 11:12:40</span></span><br><span class="line"><span class="comment">// date: 11:12:50</span></span><br><span class="line">date = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 从 1970-01-01 00:00:00 开始</span></span><br><span class="line">date = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 随机返回一个比较遥远的未来时间</span></span><br><span class="line">date = [<span class="built_in">NSDate</span> distantFuture];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;future date = %@&quot;</span>, date);</span><br><span class="line"><span class="comment">// 随机返回一个比较遥远的过去时间</span></span><br><span class="line">date = [<span class="built_in">NSDate</span> distantPast];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;future date = %@&quot;</span>, date);</span><br><span class="line"><span class="comment">// 返回 1970-01-01 00:00:00 开始到现在的毫秒数</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> interval = [date timeIntervalSince1970];</span><br><span class="line"><span class="comment">// 日期比较</span></span><br><span class="line"><span class="comment">// 返回两个时间中比较早的时间</span></span><br><span class="line"><span class="built_in">NSDate</span> *date2 = [<span class="built_in">NSDate</span> date];</span><br><span class="line">[date earlierDate:date2];</span><br><span class="line"><span class="comment">// 返回两个时间中比较晚的时间</span></span><br><span class="line">[date laterDate:date2];</span><br><span class="line"><span class="comment">// 日期格式化</span></span><br><span class="line"><span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line"><span class="comment">// 设置格式，hh 是12小时进制，HH 是24小时进制</span></span><br><span class="line">formatter.dateFormat = <span class="string">@&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line"><span class="comment">// 设置时区</span></span><br><span class="line"><span class="comment">// formatter.locale = [[[NSLocale alloc] initWithLocaleIdentifier:@&quot;&quot;] autorelease];</span></span><br><span class="line"><span class="comment">// 把 NSDate 转换为 NSString</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [formatter stringFromDate:date];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;str = %@&quot;</span>, str);</span><br><span class="line"><span class="comment">// 把 NSString 转换为 NSDate，如果没有设置时区，默认是格林尼治时区</span></span><br><span class="line"><span class="built_in">NSDate</span> *date2 = [formatter dateFromString:<span class="string">@&quot;2014-11-27 16:02:50&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;date2 = %@&quot;</span>, date2);</span><br><span class="line">[formatter release];</span><br></pre></td></tr></table></figure>

<p>NSObject 常用方法</p>
<ol>
<li>判断是否为 @class 或者 @class 的子类的实例<br><code>- (BOOL)isKindOfClass:(Class)@class</code></li>
<li>判断是否为 @class 的实例（不包括 @class 的子类）<br><code>- (BOOL)isMemberOfClass:(Class)@class</code></li>
<li>判断对象是否实现了 @protocol 协议<br><code>- (BOOL)conformsToProtocol:(Protocol)@protocol</code></li>
<li>判断这个类的对象是否拥有参数提供的方法<br><code>+ (BOOL)instancesRespondToSelector:(SEL)@selector</code></li>
<li>判断对象是否拥有参数提供的方法<br><code>- (BOOL)respondsToSelector:(SEL)@selector</code></li>
<li>延迟调用参数提供的方法，方法所需参数用 withObject 传入<br><code>- (void)performSelector:(SEL)@selector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay</code></li>
</ol>
<p>Person.h：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">void</span>)test;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Person.m</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person 调用了 test 方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Student.h：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test;</span><br><span class="line">- (<span class="type">void</span>)test2:(<span class="built_in">NSString</span> *)str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Student.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Student 调用了 test 方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test2:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Student 调用了 test2 方法，str = %@&quot;</span>， str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>main.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Student *stu = [[[Student alloc] init] autorelease];</span><br><span class="line"><span class="comment">// isKindOfClass 判断对象是否属于某个类或者其子类</span></span><br><span class="line"><span class="keyword">if</span> ([stu isKindOfClass:[Person <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;stu 属于 Person 或者属于继承自 Person 的类&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// isMemberOfClass 判断对象是否属于某个类（不包括子类）</span></span><br><span class="line"><span class="type">BOOL</span> result = [stu isMemberOfClass:[Person <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;result = %i&quot;</span>, result);</span><br><span class="line"><span class="comment">// 直接调用方法</span></span><br><span class="line"><span class="comment">// 1. 把 test 方法包装成 SEL 类型的数据</span></span><br><span class="line"><span class="comment">// 2. 根据 SEL 数据找到对应的方法地址</span></span><br><span class="line"><span class="comment">// 3. 根据方法地址调用对应的方法</span></span><br><span class="line">[stu test];</span><br><span class="line"><span class="comment">// 间接调用方法</span></span><br><span class="line">[stu performSelector:<span class="keyword">@selector</span>(test)];</span><br><span class="line"><span class="comment">// 传入参数</span></span><br><span class="line">[stu performSelector:<span class="keyword">@selector</span>(test2:) withObject:<span class="string">@&quot;123&quot;</span>];</span><br><span class="line"><span class="comment">// 延迟调用</span></span><br><span class="line">[stu performSelector:<span class="keyword">@selector</span>(test2:) withObject:<span class="string">@&quot;123&quot;</span> afterDelay:<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>反射</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的反射</span></span><br><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;Person&quot;</span>;</span><br><span class="line">Class <span class="keyword">class</span> = <span class="built_in">NSClassFromString</span>(str);</span><br><span class="line">Person *person = [[<span class="keyword">class</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, person);</span><br><span class="line">[person release];</span><br><span class="line"><span class="comment">// Class 变成字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *name = <span class="built_in">NSStringFromClass</span>([Person <span class="keyword">class</span>]);</span><br><span class="line"><span class="comment">// 方法的反射</span></span><br><span class="line"><span class="built_in">NSString</span> *method = <span class="string">@&quot;test&quot;</span>;</span><br><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(method);</span><br><span class="line">[person performSelector:selector];</span><br><span class="line"><span class="comment">// 将 SEL 转换为字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</span><br><span class="line">[person release];</span><br></pre></td></tr></table></figure>

<p>SEL<br>SEL 其实是对方法的一种包装，将方法包装成一个 SEL 类型的数据，去找对应的方法地址，找到方法地址就可以调用方法。其实消息（常说的发送消息）就是 SEL。</p>
<ul>
<li>方法的存储位置<ol>
<li>每个类的方法列表都存储在类对象中</li>
<li>每个方法都有一个与之对应的 SEL 类型的对象</li>
<li>根据一个 SEL 对象就可以找到方法的地址，进而调用方法</li>
<li>SEL 类型的定义<br> <code>typedef struct objc_selector *SEL;</code></li>
</ol>
</li>
<li>SEL 对象的创建</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SEL s = <span class="keyword">@selector</span>(test);</span><br><span class="line">SEL s2 = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>SEL 对象的其他用法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 SEL 对象转为 NSString 对象</span></span><br><span class="line"><span class="built_in">NSString</span> *str = <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(test));</span><br><span class="line"></span><br><span class="line">Person *p = [Person new];</span><br><span class="line"><span class="comment">// 调用对象 p 的  test方法</span></span><br><span class="line">[p performSelector:<span class="keyword">@selector</span>(test)];</span><br></pre></td></tr></table></figure>

<p>每个方法的内部都有一个隐藏的 SEL 对象：<code>_cmd</code>，代表当前方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;_cmd = %@&quot;</span>, str);</span><br><span class="line">    <span class="comment">// 会引发死循环</span></span><br><span class="line">    <span class="comment">// [self performSelector:_cmd];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy 和 mutableCopy</p>
<ol>
<li>一个对象使用 copy 或 mutableCopy 方法可以创建对象的副本</li>
<li>copy - 需要先实现 NSCopying 协议，创建的是不可变得副本（如 NSString、NSArray、NSDictionary）</li>
<li>mutableCopy - 需要先实现 NSMutableCopying 协议，，创建的是可变副本（如 NSMutableString、NSMutableArray、NSMutableDictionary）</li>
<li>深复制：内容拷贝，源对象和副本指向不同的两个对象。源对象引用计时器不变，副本计数器设置为 1</li>
<li>浅复制：指针拷贝，源对象和副本指向的是同一个对象。对象的引用计数器+1，其实相当于做了一次 retain 操作</li>
<li>只有不可变对象创建不可变副本（copy）才是浅复制，其他都是深复制</li>
</ol>
<p>copy 语法的目的：改变副本的时候，不会影响到源对象</p>
<p>为自定义类添加复制功能</p>
<ol>
<li>如果想自定义 copy，那么就必须遵守 NSCopying，并且实现 copyWithZone 方法</li>
<li>如果想自定义 mutableCopy，那么就必须遵守 NSMutableCopying，并且实现 mutableCopyWithZone：方法</li>
<li>以 copy 为例，建议用 <code>[self class]</code> 代替直接类名</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="type">id</span> <span class="keyword">copy</span> = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    <span class="comment">// 做一些属性的初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">copy</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 演示字符串的拷贝</span></span><br><span class="line"><span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;age is %i&quot;</span>, <span class="number">21</span>];<span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 产生了一个新的对象，引用计数器为 1.源对象的引用计数器不变</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *str = [string mutableCopy];<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;str: &amp;zi&quot;</span>, [str retainCount]); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;string: %zi&quot;</span>, [string retainCount]);<span class="comment">// 1</span></span><br><span class="line"><span class="comment">// str 和 string 不是相同对象</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%i&quot;</span>, str == string);</span><br><span class="line"><span class="comment">// 修改 str 看 string 是否有被修改</span></span><br><span class="line">[str appendString<span class="string">@&quot;123456&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;str = %@&quot;</span>, str);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;string = %@&quot;</span>, string);</span><br><span class="line">[str release];<span class="comment">// 0</span></span><br><span class="line">[string release];<span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 如果一个对象是不可变的，copy 的对象也是不可变的，系统会直接返回被 copy 的对象本身</span></span><br><span class="line"><span class="comment">// copy 产生的是不可变副本，由于源对象本身就不可变，所以为了性能着想，copy 会直接返回源对象本身，相当于源对象的 retain 操作，引用计数器 +1</span></span><br><span class="line"><span class="built_in">NSString</span> *s1  = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;age is %i&quot;</span>, <span class="number">21</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;s1: %zi&quot;</span>, [s1 retainCount]);<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">NSString</span> *s2 = [s1 <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;s1: %zi&quot;</span>, [s1 retainCount]);<span class="comment">// 2</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%i&quot;</span>, s2 == s1);</span><br></pre></td></tr></table></figure>

<p>Student.h：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"><span class="comment">// copy 代表 setter 方法会 release 旧对象，copy 新对象</span></span><br><span class="line"><span class="comment">// 修改外面的变量，并不会影响到内部的成员变量</span></span><br><span class="line"><span class="comment">// 建议：NSString 一般用 copy 策略，其他对象一般用 retain</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, cop)<span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>)studentWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Student.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line">+ (<span class="type">id</span>)studentWithName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    Student *stu = [[[Student alloc] init] autorelease];</span><br><span class="line">    stu.name = name;</span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里创建的副本对象不要求释放</span></span><br><span class="line">- (<span class="type">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    Student *<span class="keyword">copy</span> = [[Student allocWithZone:zone] init];</span><br><span class="line">    <span class="keyword">copy</span>.name = <span class="keyword">self</span>.name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">copy</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)description &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;[name = %@]&quot;</span>, _name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [_name release];</span><br><span class="line">    [<span class="variable language_">super</span> release];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>main.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里写 self class 是为了防止子类在创建的过程中导致类型错误</span></span><br><span class="line">Student *stu = [[[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init] autorelease];</span><br><span class="line"><span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> stringWithFormat<span class="string">@&quot;age is %i&quot;</span>, <span class="number">21</span>];</span><br><span class="line">stu.name = string;</span><br><span class="line">[string addendString:<span class="string">@&quot;abcd&quot;</span>];</span><br><span class="line"><span class="comment">// 如果 Student.h 中的 *name 是 retain，那么修改了 string，stu.name 也被修改了</span></span><br><span class="line"><span class="comment">// 如果 Student.h 中的 *name 是 copy，那么修改了 string，stu.name 就不会被修改</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;name = %@&quot;</span>, stu.name);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;string = %@&quot;</span>, string);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 的 copy</span></span><br><span class="line">Student *stu1 = [Student studentWithName:<span class="string">@&quot;student1&quot;</span>];</span><br><span class="line"><span class="comment">// 如果 Student 没有实现 NSCopying 协议，那么会报错：unrecognized selector sent to instance....</span></span><br><span class="line">Student *stu2 = [stu1 <span class="keyword">copy</span>];</span><br><span class="line">stu2.name = <span class="string">@&quot;stu2&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;stu1 = %@&quot;</span>, stu1);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;stu2 = %@&quot;</span>, stu2);</span><br><span class="line">[stu2 release];</span><br></pre></td></tr></table></figure>

<p>类的本质<br>类本身也是一个对象，是一个 Class 类型的对象，简称类对象<br>Class 类型的定义：<br><code>typedef struct objc_class *Class;</code><br>类名就代表着类对象，每个类只有一个类对象<br>例如：<br>利用 Class 创建 Person 类对象<br>利用 Person 类对象创建 Person 类型的对象</p>
<p>获取内存中的类对象：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Person *p1 = [[Person alloc] init];</span><br><span class="line">Person *p2 = [[Person alloc] init];</span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line">Class c1 = [p1 <span class="keyword">class</span>];</span><br><span class="line">Class c2 = [p2 <span class="keyword">class</span>];</span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line">Class c3 = [Person <span class="keyword">class</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;c1 = %p, c2 = %p, c3 = %p&quot;</span>, c1, c2, c3);</span><br></pre></td></tr></table></figure>

<p>获取的类对象（Class）可以调用类方法，比如 Person.h 中有一个名为 test 的类方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)texst;</span><br></pre></td></tr></table></figure>

<p>Person.m 中有实现该方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;调用了类方法 test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Class c = [p1 <span class="keyword">class</span>];</span><br><span class="line">[c test];</span><br></pre></td></tr></table></figure>

<p>类的加载和初始化：<br>+load</p>
<ol>
<li>在程序启动的时候会加载所有的类和分类，并调用所有类和分类的 <code>+load</code> 方法</li>
<li>先加载父类，再加载子类：也就是先调用父类的 <code>+load</code> 方法，再调用子类的 <code>+load</code> 方法</li>
<li>先加载原始类，再加载分类</li>
<li>不管程序运行过程有没有用到这个类，都会调用 <code>+load</code> 加载</li>
</ol>
<p>+initialize</p>
<ol>
<li>在第一次使用某个类时（比如创建对象等），就会调用一次 <code>+initialize</code> 方法</li>
<li>一个类只会调用一次 <code>+initialize</code> 方法，先调用父类的，再调用子类的</li>
</ol>
<p><code>+ (void)load</code> 方法在程序启动的时候，就会加载一次项目中所有的类和分类。类加载完毕后就会调用每个类和分类的 load 方法。只会调用一次</p>
<p>load 方法会从父类开始调用，再是子类，包括 Category 也会调用 load 方法<br><code>+ (void)initialize</code> 方法在第一次使用某个类的时候调用</p>
<p>initialize 方法也是先初始化父类，再是子类</p>
<p>description 方法</p>
<ol>
<li><code>-description</code> 方法：使用 NSLog 和 %@ 输出某个对象时，会调用对象的 <code>-description</code> 方法，并拿到返回值进行输出</li>
<li><code>+description</code> 方法：使用 NSLog 和 %@ 输出某个对象时，会调用类对象的 <code>+description</code> 方法，并拿到返回值进行输</li>
</ol>
<p>死循环陷阱：如果在 <code>-description</code> 方法中使用 NSLog 打印 self</p>
<p>构造方法<br>作用：用来初始化对象的方法，是一个对象方法，<code>-</code> 开头<br>重写构造方法的目的：为了让对象创建出来，成员变量就已经有一些固定的值<br>重写构造方法的注意点：</p>
<ol>
<li>先调用父类的构造方法（[super init]）</li>
<li>再进行子类的内部成员变量的初始化</li>
</ol>
<p>例如：<br>重写 <code>-init</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line">    <span class="comment">// 1. 一定要调用回 super 的 init 方法：初始化父类中声明的一些成员变量和其他属性</span></span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];<span class="comment">// 当前对象 self</span></span><br><span class="line">    <span class="comment">// 2. 如果对象初始化成功，才有必要进行接下来的初始化操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化成功</span></span><br><span class="line">        _age = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 返回一个已经初始化完毕的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类的属性交给父类方法去处理，子类方法处理子类自己的属性<br>自定义构造方法的规范：</p>
<ol>
<li>一定是对象方法，一定以 <code>-</code> 开头</li>
<li>返回值一般是 id 类型</li>
<li>方法名一般以 init 开头</li>
</ol>
<p>NSLog 输出的一些补充(都是两个下划线 <code>_</code> )：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出当前函数名</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"><span class="comment">// 输出行号</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, __LINE__);</span><br><span class="line"><span class="comment">// NSLog 输出 C 语言字符串的时候，不能有中文，可以使用 printf 函数输出</span></span><br><span class="line"><span class="comment">// NSLog(@&quot;%s&quot;, __FILE__);</span></span><br><span class="line">printf(<span class="string">&quot;%s\n&quot;</span>, __FILE__);</span><br></pre></td></tr></table></figure>

<p>ARC<br>ARC 的判断准则：只要没有强指针指向对象，就会释放对象<br>ARC 的特点：</p>
<ol>
<li>不允许调用 release、retain、retainCount</li>
<li>允许重写 dealloc，但是不允许调用 <code>[super deallo]</code></li>
<li>@property 的参数：<ul>
<li>strong：成员变量时强指针，相当于原来的 retain（适用于OC对象类型）</li>
<li>weak：成员变量时弱指针，相当于原来的 assign（适用于OC对象类型）</li>
<li>assign：适用于非 OC 对象类型</li>
</ul>
</li>
</ol>
<p>指针分两种：</p>
<ol>
<li>强指针：默认情况下，所有的指针都是强指针 <code>__strong</code></li>
<li>弱指针：<code>__weak</code></li>
</ol>
<p>Xcode 是默认使用 ARC 的，如果某个 .m 文件真的不想使用 ARC，可以通过以下步骤来不适用 ARC：<br>选择 Xcode 右侧项目树的根，然后是 <strong>TARGETS -&gt; Build Phases -&gt; Compile Sources</strong> ，下拉，选择目标 .m 文件，回车或者双击，弹出输入框，输入 <code>-fno-objc-arc</code> 回车，就可以了，如下图所示：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabefcd32e8.png"></p>
<p>如果开发环境是非 ARC 的，想要使用 ARC 的，将上面的 <code>-fno-objc-arc</code> 改成 <code>-f-objc-arc</code> 就可以了。</p>
<p>ARC 循环引用<br>当两端循环引用的时候，解决方案如下：</p>
<ol>
<li>ARC<br> 1端用 strong，另一端用 weak</li>
<li>非ARC<br> 1端用 retain，另一端用 assign</li>
</ol>
<p>例如：<br>在使用 ARC 下，有两个类：Person、Dog，如下：<br>Person.h：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Dog</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 人有一只狗，strong，强指针</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Dog *dog;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Person.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person ---- dealloc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Dog.h：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Dog</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 狗有一个主人，strong，强指针</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *person;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Dog.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Dog ---- dealloc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>main.m：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">Dog *d = [[Dog alloc] init];</span><br><span class="line"><span class="comment">// 第一种情况：</span></span><br><span class="line"><span class="comment">// 当两个互指之后，会出现内存泄露，两个对象的 dealloc 没有被调用，也就是两个对象的内存没有被释放</span></span><br><span class="line">p.dog = d;</span><br><span class="line">d.person = p;</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabf0c082a2.png"></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种情况：</span></span><br><span class="line"><span class="comment">// 如果注释上面两行代码中的任意一行，两个对象都可以被释放</span></span><br><span class="line"><span class="comment">// 因为当 main 函数执行完毕之后，对象 p 和 d 都被回收，但是两个内存中的对象有强指针，不会被回收，所以会造成内存泄露</span></span><br><span class="line">p.dog = d;</span><br><span class="line"><span class="comment">// d.person = p;</span></span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabf1b36c23.png"></p>
<p>如果将 Dog 中的 person 属性改成 weak：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) Person *person;</span><br></pre></td></tr></table></figure>

<p>那么，上面第二种情况就变成了如下图所示：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabf275937a.png"></p>
<p>这样的话，当程序运行结束，被回收的就是 Person 对象，既然 Person 对象被回收了，那么 Dog 对象就没有了强指针，也会被回收了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameWork 支持的手机壳颜色</title>
    <url>/2018/12/18/app-framework-supported-device-colors/</url>
    <content><![CDATA[<p><a href="https://itunes.apple.com/us/app/apple-store/id1412383595?mt=8">FrameWork</a> 目前版本（v1.3.0）支持的手机壳颜色。</p>
<span id="more"></span>

<p>缺失的我会尽力去补充完整。</p>
<h1 id="手机壳颜色表"><a href="#手机壳颜色表" class="headerlink" title="手机壳颜色表"></a>手机壳颜色表</h1><h2 id="iPhone-11-Pro-Max"><a href="#iPhone-11-Pro-Max" class="headerlink" title="iPhone 11 Pro Max"></a>iPhone 11 Pro Max</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 11 Pro Max</td>
<td>金色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 11 Pro Max</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 11 Pro Max</td>
<td>银色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 11 Pro Max</td>
<td>暗夜绿色</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="iPhone-11-Pro"><a href="#iPhone-11-Pro" class="headerlink" title="iPhone 11 Pro"></a>iPhone 11 Pro</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 11 Pro</td>
<td>金色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 11 Pro</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 11 Pro</td>
<td>银色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 11 Pro</td>
<td>暗夜绿色</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="iPhone-11"><a href="#iPhone-11" class="headerlink" title="iPhone 11"></a>iPhone 11</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 11</td>
<td>黑色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 11</td>
<td>绿色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 11</td>
<td>黄色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 11</td>
<td>紫色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 11</td>
<td>红色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 11</td>
<td>白色</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-XS-Max"><a href="#iPhone-XS-Max" class="headerlink" title="iPhone XS Max"></a>iPhone XS Max</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone XS Max</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone XS Max</td>
<td>金色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone XS Max</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-XS"><a href="#iPhone-XS" class="headerlink" title="iPhone XS"></a>iPhone XS</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone XS</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone XS</td>
<td>金色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone XS</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-XR"><a href="#iPhone-XR" class="headerlink" title="iPhone XR"></a>iPhone XR</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone XR</td>
<td>蓝色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone XR</td>
<td>白色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone XR</td>
<td>黑色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone XR</td>
<td>黄色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone XR</td>
<td>珊瑚色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone XR</td>
<td>红色特别版</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-X"><a href="#iPhone-X" class="headerlink" title="iPhone X"></a>iPhone X</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone X</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone X</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-8-Plus"><a href="#iPhone-8-Plus" class="headerlink" title="iPhone 8 Plus"></a>iPhone 8 Plus</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 8 Plus</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 8 Plus</td>
<td>金色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 8 Plus</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 8 Plus</td>
<td>红色特别版</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="iPhone-8"><a href="#iPhone-8" class="headerlink" title="iPhone 8"></a>iPhone 8</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 8</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 8</td>
<td>金色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 8</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 8</td>
<td>红色特别版</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="iPhone-7-Plus"><a href="#iPhone-7-Plus" class="headerlink" title="iPhone 7 Plus"></a>iPhone 7 Plus</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 7 Plus</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 7 Plus</td>
<td>金色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 7 Plus</td>
<td>黑色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 7 Plus</td>
<td>玫瑰金</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 7 Plus</td>
<td>亮黑色</td>
<td>❌</td>
</tr>
<tr>
<td>iPhone 7 Plus</td>
<td>红色特别版</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="iPhone-7"><a href="#iPhone-7" class="headerlink" title="iPhone 7"></a>iPhone 7</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 7</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 7</td>
<td>金色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 7</td>
<td>黑色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 7</td>
<td>玫瑰金</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 7</td>
<td>亮黑色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 7</td>
<td>红色特别版</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="iPhone-6S-Plus"><a href="#iPhone-6S-Plus" class="headerlink" title="iPhone 6S Plus"></a>iPhone 6S Plus</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 6S Plus</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 6S Plus</td>
<td>金色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 6S Plus</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 6S Plus</td>
<td>玫瑰金色</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-6S"><a href="#iPhone-6S" class="headerlink" title="iPhone 6S"></a>iPhone 6S</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 6S</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 6S</td>
<td>金色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 6S</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 6S</td>
<td>玫瑰金色</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-6-Plus"><a href="#iPhone-6-Plus" class="headerlink" title="iPhone 6 Plus"></a>iPhone 6 Plus</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 6 Plus</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 6 Plus</td>
<td>金色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 6 Plus</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-6"><a href="#iPhone-6" class="headerlink" title="iPhone 6"></a>iPhone 6</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 6</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 6</td>
<td>金色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 6</td>
<td>深空灰色</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-SE"><a href="#iPhone-SE" class="headerlink" title="iPhone SE"></a>iPhone SE</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone SE</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone SE</td>
<td>金色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone SE</td>
<td>深空色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone SE</td>
<td>玫瑰金色</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-5S"><a href="#iPhone-5S" class="headerlink" title="iPhone 5S"></a>iPhone 5S</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 5S</td>
<td>金色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 5S</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 5S</td>
<td>深空灰</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-5C"><a href="#iPhone-5C" class="headerlink" title="iPhone 5C"></a>iPhone 5C</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 5C</td>
<td>蓝色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 5C</td>
<td>绿色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 5C</td>
<td>红色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 5C</td>
<td>银色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 5C</td>
<td>黄色</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="iPhone-5"><a href="#iPhone-5" class="headerlink" title="iPhone 5"></a>iPhone 5</h2><table>
<thead>
<tr>
<th>型号</th>
<th>颜色</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>iPhone 5</td>
<td>黑色</td>
<td>✔️</td>
</tr>
<tr>
<td>iPhone 5</td>
<td>白色</td>
<td>✔️</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>FrameWork</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameWork 使用小技巧</title>
    <url>/2018/11/26/app-framework-tips/</url>
    <content><![CDATA[<p>可以在 “<a href="https://itunes.apple.com/cn/app/apple-store/id1412383595?mt=8">FrameWork</a>” -&gt; “底部更多（三个点）” -&gt; “小技巧” 找到这篇文章的入口。</p>
<p>有任何问题、建议或 Bug 都可以点击 “<a href="https://itunes.apple.com/cn/app/apple-store/id1412383595?mt=8">FrameWork</a>” 中的 “底部更多（三个点）” -&gt; “联系我” 来给我发邮件。或者直接发送到 <a href="mailto:codingallnight@gmail.com">codingallnight@gmail.com</a>。</p>
<p>或者可以在微博上 at 我 <a href="https://weibo.com/fuckingcode">@我的眼里只有代码</a>。</p>
<!-- 其他社交账号也可以在我博客的资料页面里面找到（手机端浏览器可能是没有资料页面的）。 -->
<span id="more"></span>

<p><a href="https://meilbn.com/2018/11/26/app-framework-tips-en/">English</a></p>
<h1 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h1><p><img src="https://i.loli.net/2018/11/28/5bfe9a4b37a82.jpg"></p>
<h1 id="底部工具栏"><a href="#底部工具栏" class="headerlink" title="底部工具栏"></a>底部工具栏</h1><p><img src="https://i.loli.net/2018/11/28/5bfe9a9b5bb2c.jpg" alt="底部工具栏0"><br><img src="https://i.loli.net/2018/11/28/5bfe9aabb24b0.jpg" alt="底部工具栏1"></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><img src="https://i.loli.net/2018/11/28/5bfea5e0baffd.png" style="width:414px;height:896px;">

<p>背景可以设置多种类型，透明色只在图片保存格式为 <code>PNG</code> 时才支持（可以在“更多”界面里面修改）。</p>
<h1 id="设置背景为渐变色"><a href="#设置背景为渐变色" class="headerlink" title="设置背景为渐变色"></a>设置背景为渐变色</h1><p><img src="https://i.loli.net/2018/11/28/5bfea36cbd150.gif" alt="创建渐变色"></p>
<p>目前只支持三种颜色的渐变，因为感觉颜色多了不好看，三个算是上限了。</p>
<p>颜色可以长按进行排序，点击修改颜色。</p>
<h1 id="标题（副标题）样式"><a href="#标题（副标题）样式" class="headerlink" title="标题（副标题）样式"></a>标题（副标题）样式</h1><p><img src="https://i.loli.net/2018/11/28/5bfeab9380632.jpg"></p>
<ol>
<li>设置标题的左右边距，往左变小（标题可以更长，可能字体显示会变大），反之则变大（标题变短，可能字体显示也会变小）</li>
<li>更改标题的字体，点击可以更改以及预览</li>
<li>更改标题的字体大小</li>
<li>更改标题的文字颜色</li>
<li>如图所示，可以随意选择一个颜色作为标题的文字颜色</li>
<li>更改标题文字的排列方式（靠左、居中、靠右）</li>
<li>更改标题顶部的距离（上下移动）</li>
</ol>
<h1 id="手机壳样式"><a href="#手机壳样式" class="headerlink" title="手机壳样式"></a>手机壳样式</h1><p><img src="https://i.loli.net/2018/11/28/5bfeb0cc1a539.jpg"></p>
<ol>
<li>设置手机壳的左右边距，往左变小（手机壳变大），反之则变大（手机壳变小）</li>
<li>重置为默认的边距</li>
<li>隐藏手机壳，此时就只有用户选择的截图</li>
<li>更改手机壳顶部的距离（上下移动）</li>
</ol>
<p>ps. 手机壳颜色请使用底部工具栏第二个按钮来切换</p>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>FrameWork</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网 - VPS 搭建 Shadowsocks 并开启 BBR</title>
    <url>/2017/10/25/VPS-build-shadowsocks-and-bbr/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p><strong>本文仅供学习，请勿用于非法用途！</strong></p>
<p>首先，你要有台服务器，个人用过几个不同服务商的 VPS，有：</p>
<ul>
<li><a href="https://bandwagonhost.com/aff.php?aff=21621">搬瓦工</a>：第一次自己买 VPS 搭 SS 的服务商，价格挺便宜的，实惠一点的，100出头一点可以用一年，每月 2T 的流量，20 GB 的硬盘，忘了是不是 SSD 的了。但是速度慢，很卡，后来没到期就不用了。</li>
<li>阿里云：买的是香港的服务器，2016 年双 11 买的，还打折（后来证明没什么卵用，没便宜），500 多一年，流量另算，1 GB 1 块钱，速度很快，但是 2017 年 10 月份十九大之前，竟然被封了 IP。所以换别的服务商。</li>
<li><a href="https://www.vultr.com/?ref=7238810">Vultr</a>（通过此链接注册，你可以免费获得 10 美元，同时也能帮助我获得一些小奖励，谢谢！）：阿里云被封了 IP 之后，看同事在用这个，就买了这个的日本机房的 VPS，但是搭完之后，没过3天，就被封了 IP，又燃起换服务商的想法，然后看到 Linode 有日本机房的 VPS 可以选，然后就退款，换到 Linode 了。</li>
<li><a href="https://www.linode.com/?r=f2bc7074ae89253f83de5918700abc6a82f1685a">Linode</a>：换到 Linode 才真正开始了折腾之路，申请过更换 IP，但是被拒，然后我的解决办法是切换机房，从日本东京切换到新加坡，或者删掉已有的重新创建一个，IP 也是不一样的，但是依然被封 IP，有时候新创建的 VPS 的 IP 是已经被封的。感觉是因为用了 <code>rc4-md5</code> 的加密算法，遂使用更安全更快速的 <code>chacha20</code>，依然逃不过被封 IP 的厄运。</li>
<li><a href="https://cloud.google.com/">Google Cloud Platform</a>: 于 2018 年 5 月底开始转战 GCP，速度很快，删掉了 Linode 的主机，而且 GCP 也送了 300 美元，够用好多个月了。</li>
</ul>
<p>FUCKING GFW!!!!!!!!!!!!!!!!!!!!</p>
<span id="more"></span>

<h1 id="ox01-开始搭建-SS"><a href="#ox01-开始搭建-SS" class="headerlink" title="ox01 开始搭建 SS"></a>ox01 开始搭建 SS</h1><p>上面啰嗦了这么多，现在开始搭建 SS，这里服务商就以 Linode 为例，系统就用 Ubuntu 14.04 LTS。</p>
<h2 id="0x0100-创建服务器"><a href="#0x0100-创建服务器" class="headerlink" title="0x0100 创建服务器"></a>0x0100 创建服务器</h2><ul>
<li>在 Linode 上新建一个服务器，配置随便，搭 SS 用最低的就够用了，然后地点选日本：</li>
</ul>
<p><img src="https://i.loli.net/2018/11/01/5bdac27a4c7f6.png"></p>
<ul>
<li>创建好了之后，点击名称或者 Dashboard 进入详情：</li>
</ul>
<p><img src="https://i.loli.net/2018/11/01/5bdac28919a7f.png"></p>
<ul>
<li>现在服务器还没有配置一个系统，我们点击 Deploy an Image，来安装一个系统：</li>
</ul>
<p><img src="https://i.loli.net/2018/11/01/5bdac293add1f.png"></p>
<ul>
<li>系统选择 Ubuntu 14.04 LTS，再设置一下 root 密码，后面 ssh 登录会用到：</li>
</ul>
<p><img src="https://i.loli.net/2018/11/01/5bdac29ec1d77.png"></p>
<ul>
<li>创建完之后，等下面 Host Job Queue 中的进度都完成了，点击 Boot 按钮启动服务器。或者直接点 Boot 按钮，Linode 会按队列来一个个执行：</li>
</ul>
<p><img src="https://i.loli.net/2018/11/01/5bdac2aba97b5.png"></p>
<ul>
<li>服务器运行起来之后，现在我们就可以使用 ssh 登录服务器了，但是为了避免分配的服务器的 IP 是已经被封的，首先我们先 ping 一下 IP，避免做无用功：</li>
</ul>
<p><img src="https://i.loli.net/2018/11/01/5bdac2b6ec4c9.png"></p>
<p>看来是被封过的，那我们只能重头开始重新创建一个服务器了。</p>
<ul>
<li>拿到一个 IP 没有被封的服务器，我们 ssh 连接上去，如果电脑终端连接不上去的，可以先用 Linode 提供的 Glish 连接：</li>
</ul>
<p><img src="https://i.loli.net/2018/11/01/5bdac2c576485.png"></p>
<h2 id="0x0101-搭建-SS"><a href="#0x0101-搭建-SS" class="headerlink" title="0x0101 搭建 SS"></a>0x0101 搭建 SS</h2><ul>
<li>首先，我们先更新一下 apt-get：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get update</span><br></pre></td></tr></table></figure>

<p>然后等待完成，需要一点时间。</p>
<ul>
<li>完成之后，我们先安装 python-pip 等一些库（中间需要确认安装一下，输入 y 然后回车）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get install python-pip python-m2crypto</span><br></pre></td></tr></table></figure>

<ul>
<li>然后就可以安装 SS 了：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install shadowsocks</span><br></pre></td></tr></table></figure>

<ul>
<li>很快就安装好了，然后我们创建所需的文件夹和 config.json 文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc</span><br><span class="line">$ <span class="built_in">mkdir</span> shadowsocks</span><br><span class="line">$ <span class="built_in">cd</span> shadowsocks/</span><br><span class="line">$ vi config.json</span><br></pre></td></tr></table></figure>

<p>然后输入一下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_SERVER_IP&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span> <span class="number">8388</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span> <span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YOUR_SS_PASSWORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aes-256-cfb&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>（2017-10-30 更新）：最近封锁越来越严重，推荐使用常用端口。</p>
<ul>
<li>然后就可以启动 SS 了：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo /usr/local/bin/ssserver -c /etc/shadowsocks/config.json --user nobody -qq -d start</span><br></pre></td></tr></table></figure>

<p>也可以把这个命令加到 <code>/etc/rc.local</code> 里面，每次系统启动都会启动 SS，注意要在 <code>exit 0</code> 之前：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdac2d1e6ff6.png"></p>
<p>然后要么重启一下服务器，要么重新运行一下刚刚添加的那条命令，启动 SS。</p>
<p>到这里，SS 搭建就完成了。</p>
<h2 id="0x0102-加密方式"><a href="#0x0102-加密方式" class="headerlink" title="0x0102 加密方式"></a>0x0102 加密方式</h2><p>上面使用的加密方式是 <code>aes-256-cfb</code>，还有一个更快更安全的 <code>chacha20</code> 或者 <code>salsa20</code>，但是我用过 <code>chacha20</code>，还是被封 IP，要是想用这个加密方式，还要额外的几步，因为还缺少了一个库：<code>libsodium</code>，不然启动 SS 的时候，会报错，安装方法如下：</p>
<ul>
<li>安装 <code>libsodium</code>，需 <code>&gt;= 1.0.0</code>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install build-essential</span><br><span class="line">$ <span class="built_in">cd</span> /tmp</span><br><span class="line">$ wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz</span><br><span class="line">$ tar zxf LATEST.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> libsodium*</span><br><span class="line">$ ./configure</span><br><span class="line">$ make -j2</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<ul>
<li>然后将下面的代码加入到 <code>/etc/ld.so.conf</code>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include ld.so.conf.d/*.conf<span class="string">&quot;</span></span><br><span class="line"><span class="string">/lib</span></span><br><span class="line"><span class="string">/usr/lib64</span></span><br><span class="line"><span class="string">/usr/local/lib</span></span><br></pre></td></tr></table></figure>

<ul>
<li>再重新载入配置：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>最后重新启动 SS 即可。</li>
</ul>
<h2 id="0x0103-ss-启动成功，但是并没有运行"><a href="#0x0103-ss-启动成功，但是并没有运行" class="headerlink" title="0x0103 ss 启动成功，但是并没有运行"></a>0x0103 ss 启动成功，但是并没有运行</h2><p>在启动了 ss 之后，终端打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@tw:~# sudo /usr/local/bin/ssserver -c /etc/shadowsocks/config.json --user nobody -qq -d start</span><br><span class="line">INFO: loading config from /etc/shadowsocks/config.json</span><br><span class="line">started</span><br></pre></td></tr></table></figure>

<p>但是查看当前进程，并没有 <code>ssserver</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@tw:~# ps -e | grep ss</span><br><span class="line"> 1372 ?        00:00:00 sshguard</span><br><span class="line"> 1619 ?        00:00:00 sshd</span><br><span class="line"> 2031 ?        00:00:00 sshd</span><br><span class="line"> 2105 ?        00:00:00 sshd</span><br></pre></td></tr></table></figure>

<p>被这个问题困扰了很久，中间还放弃过一次，但是本着不放过的原则，重新开始搭建。</p>
<p>想到既然启动成功，但是并没有运行，应该查看下 log，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo less /var/log/shadowsocks.log</span><br></pre></td></tr></table></figure>

<p>日志中出现最多，最引人注目的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket.error: [Errno 99] Cannot assign requested address</span><br></pre></td></tr></table></figure>

<p>看字面意思应该是分配地址有问题，遂去 Google 搜索，找到的可用方法是，将配置文件的 Server 地址改成 <code>0.0.0.0</code>，重新启动下 ss，就可以正常启动并运行了。</p>
<h1 id="0x02-更换系统内核并开启-TCP-BBR"><a href="#0x02-更换系统内核并开启-TCP-BBR" class="headerlink" title="0x02 更换系统内核并开启 TCP BBR"></a>0x02 更换系统内核并开启 TCP BBR</h1><p>TCP BBR 是 Google 开发的新的拥塞控制算法，据说是用在 YouTube 上，并且在去年 9 月开源并且现在已经集成到 Linux 4.9-rc8 之后版本的内核中。虽然 Linode 也更新到了 4.9 版本内核，但是并没有 TCP BBR，所以还是要自己更换一下内核。</p>
<h2 id="0x0200-更换系统内核"><a href="#0x0200-更换系统内核" class="headerlink" title="0x0200 更换系统内核"></a>0x0200 更换系统内核</h2><p>这里要注意的一点是，如果你的 VPS 使用的是 OpenVZ 的虚拟技术，你是不能使用 BBR 的。并且系统要求在 CentOS 6+，Debian 7+，Ubuntu 12+。</p>
<p>首先确定下自己购买的 VPS 的架构吧，这里就不涉及了，自己去找吧。</p>
<p>这里我就选 <code>4.13.9</code> 了，如果你要选择别的内核版本，完整列表在<a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/">这里</a>。</p>
<ul>
<li>下载内核文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /tmp</span><br><span class="line">$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.13.9/linux-image-4.13.9-041309-generic_4.13.9-041309.201710211231_amd64.deb</span><br></pre></td></tr></table></figure>

<ul>
<li>等待下载完成，然后使用 <code>dpkg -i</code> 命令安装：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dpkg -i linux-image-4.13.9-041309-generic_4.13.9-041309.201710211231_amd64.deb</span><br></pre></td></tr></table></figure>

<ul>
<li>安装完成以后，查看一下已安装的内核列表：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dpkg -l | linux-image</span><br></pre></td></tr></table></figure>

<ul>
<li>如果看到了刚刚安装的内核，证明安装成功了，然后我执行一下内核更新，然后重启：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ update-grub</span><br><span class="line">$ reboot</span><br></pre></td></tr></table></figure>

<ul>
<li>重新 ssh 连接，查看一下系统内核：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>

<p>发现还是旧的内核，网上找了一下原因，解决办法如下：</p>
<ul>
<li>安装内核系统引导：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get install linux-image-virtual grub2</span><br></pre></td></tr></table></figure>

<p>会出现这个界面，我是直接回车确定的：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdac2e0babc8.png"></p>
<ul>
<li>确定一下你的内核已经被安装上，是否有刚刚安装的那个内核：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /boot/vmlinuz*</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2018/11/01/5bdac2ee20c72.png"></p>
<ul>
<li>然后编辑 <code>grub</code> 文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/default/grub</span><br></pre></td></tr></table></figure>

<p>如果和下面有不一样的，修改成一样的（其实我这基本都不用改，默认就是这样）：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">GRUB_TIMEOUT</span>=<span class="number">10</span></span><br><span class="line"><span class="attr">GRUB_CMDLINE_LINUX</span>=<span class="string">&quot;console=ttyS0,19200n8&quot;</span></span><br><span class="line"><span class="attr">GRUB_DISABLE_LINUX_UUID</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">GRUB_SERIAL_COMMAND</span>=<span class="string">&quot;serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1&quot;</span></span><br><span class="line"><span class="attr">GRUB_TERMINAL</span>=serial</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 grub：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ update-grub</span><br></pre></td></tr></table></figure>

<ul>
<li>显示在最顶端的 kernel 就是即将启动的 kernel 。如果没显示在最顶端，就把其余的 kernel 删掉（一般都在最顶端）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get purge 旧内核名称</span><br></pre></td></tr></table></figure>

<ul>
<li>然后进入 Linode 的 Dashboard，点击 Edit：</li>
</ul>
<p><img src="https://i.loli.net/2018/11/01/5bdac2f8dbf06.png"></p>
<ul>
<li>在 Kernel 选项处选择 GRUB 2，然后点击 Save Changes 按钮，然后重启 VPS，看看是否内核更新了：</li>
</ul>
<p><img src="https://i.loli.net/2018/11/01/5bdac3045b617.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>

<p>如果显示的是你安装的新的内核，说明成功了。</p>
<h2 id="0x0201-开启-TCP-BBR"><a href="#0x0201-开启-TCP-BBR" class="headerlink" title="0x0201 开启 TCP BBR"></a>0x0201 开启 TCP BBR</h2><ul>
<li>执行下面两条命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>保存生效：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sysctl -p</span><br></pre></td></tr></table></figure>

<ul>
<li>执行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>

<p>则会打印：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br></pre></td></tr></table></figure>

<ul>
<li>然后查看 TCP BBR 是否运行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsmod | grep bbr</span><br></pre></td></tr></table></figure>

<p>如果结果中有 <code>tcp_bbr</code> 说明 BBR 已经启动了。</p>
<h1 id="0x03-修改-SSH-远程登录端口"><a href="#0x03-修改-SSH-远程登录端口" class="headerlink" title="0x03 修改 SSH 远程登录端口"></a>0x03 修改 SSH 远程登录端口</h1><ul>
<li>修改 <code>/etc/ssh/sshd_config</code>，在 <code>Port 22</code> 下添加你的端口：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Port 22</span><br><span class="line">Port YOUR_PORT</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>/etc/ssh/ssh_config</code>，在 <code>Host *</code> 下添加你的端口：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host *</span><br><span class="line">Port 22</span><br><span class="line">Port YOUR_PORT</span><br><span class="line"># ForwardAgent no</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>重启 SSH</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>

<ul>
<li>再 SSH 连接新的端口，成功连接后再修改上面的配置把 22 端口注释掉。再在本机 <code>~/.ssh/</code> 下新建一个 <code>config</code> 文件，文件内容为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host YOUR_HOST</span><br><span class="line">    User YOUR_USER_NAME</span><br><span class="line">    Port YOUR_NEW_PORT</span><br></pre></td></tr></table></figure>

<p>这样下次连接就只需要 <code>ssh YOUR_HOST</code> 就可以了。</p>
<ul>
<li>修改 SSH 默认端口后 git 的一些远程操作会失败，解决办法也是修改 <code>config</code> 文件：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">Port 22</span><br><span class="line">Host bitbucket.org</span><br><span class="line">HostName bitbucket.org</span><br><span class="line">Port 22</span><br></pre></td></tr></table></figure>

<h1 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h1><p><a href="https://groups.google.com/forum/#!forum/bbr-dev">BBR 官方论坛</a><br><a href="https://github.com/google/bbr/blob/master/Documentation/bbr-quick-start.md">BBR Quick Start</a><br><a href="https://github.com/shadowsocks/shadowsocks/wiki/Encryption">Shadowsocks wiki Encryption</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
        <tag>VPS</tag>
        <tag>Linode</tag>
        <tag>BBR</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameWork Usage Tips</title>
    <url>/2018/11/26/app-framework-tips-en/</url>
    <content><![CDATA[<p>You can find this page in “<a href="https://itunes.apple.com/us/app/apple-store/id1412383595?mt=8">FrameWork</a>“ -&gt; “More (three dots)” -&gt; “Tips”.</p>
<p>If you have any questions, suggestions or bugs, you can sending email to me in “<a href="https://itunes.apple.com/us/app/apple-store/id1412383595?mt=8">FrameWork</a>“ -&gt; “More (three dots)” -&gt; “Contact Me”. Or sending email directly to <a href="mailto:codingallnight@gmail.com">codingallnight@gmail.com</a>.</p>
<p>Or you can @ me on Weibo <a href="https://weibo.com/fuckingcode">@我的眼里只有代码</a> or Twitter <a href="https://twitter.com/meilbn">@meilbn</a>.</p>
<!-- Other social accont can be finf in my blog's profile page (mobile browser may not have profile page). -->
<span id="more"></span>

<p><a href="https://meilbn.com/2018/11/26/app-framework-tips/">中文版</a></p>
<h1 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h1><p><img src="https://i.loli.net/2018/11/28/5bfea92e5a7b6.jpg"></p>
<h1 id="Bottom-Toolbar"><a href="#Bottom-Toolbar" class="headerlink" title="Bottom Toolbar"></a>Bottom Toolbar</h1><p><img src="https://i.loli.net/2018/11/28/5bfe9e1f7fd3b.jpg" alt="Bottom Toolbar 0"><br><img src="https://i.loli.net/2018/11/28/5bfe9e445998b.jpg" alt="Bottom Toolbar 1"></p>
<h1 id="Backdrop"><a href="#Backdrop" class="headerlink" title="Backdrop"></a>Backdrop</h1><img src="https://i.loli.net/2018/11/28/5bfea7a08240f.png" style="width:414px;height:896px;">

<p>Backdrop can set with many types, <code>Clear Color</code> only available when screenshot save as <code>PNG</code> (you can change it in <code>More</code>).</p>
<h1 id="Set-Backdrop-with-Gradient"><a href="#Set-Backdrop-with-Gradient" class="headerlink" title="Set Backdrop with Gradient"></a>Set Backdrop with Gradient</h1><p><img src="https://i.loli.net/2018/11/28/5bfea36cbd150.gif" alt="Create Gradient"></p>
<p>Just support three colors currently, because I think gradient will be ugly if color greater than three.</p>
<p>Color can long press to reorder, click color to modify.</p>
<h1 id="Title-Subtitle-Attributes"><a href="#Title-Subtitle-Attributes" class="headerlink" title="Title (Subtitle) Attributes"></a>Title (Subtitle) Attributes</h1><p><img src="https://i.loli.net/2018/11/28/5bfead61f12a8.jpg"></p>
<ol>
<li>Set title’s left and right margin, slide to left will decrease (title can be long, maybe font will bigger), otherwise will increase (title will be short, maybe font will smaller).</li>
<li>Change title’s font, click can change and preview.</li>
<li>Change title’s font size.</li>
<li>Change title’s text color.</li>
<li>As the picture shows, can choose a color as title’s text color</li>
<li>Change title’s text alignment</li>
<li>Change title’s top offset (move up or down)</li>
</ol>
<h1 id="Device-Attributes"><a href="#Device-Attributes" class="headerlink" title="Device Attributes"></a>Device Attributes</h1><p><img src="https://i.loli.net/2018/11/28/5bfeb2cc3b2e4.jpg"></p>
<ol>
<li>Set device’s left and right margin, slide to left will decrease (device will bigger), otherwise will increase (device will smaller).</li>
<li>Reset margin to default</li>
<li>Hide device, just screenshot left.</li>
<li>Change device’s top offset (move up or down)</li>
</ol>
<p>ps. Please use the second button on the bottom toolbar to change device’s color.</p>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>FrameWork</tag>
      </tags>
  </entry>
  <entry>
    <title>GeeMoon Releases</title>
    <url>/2018/06/08/app-geemoon-releases-en/</url>
    <content><![CDATA[<p>GeeMoon releases history, record the growth of GeeMoon.</p>
<span id="more"></span>

<p><a href="https://meilbn.com/2018/06/08/app-geemoon-releases/">中文版</a></p>
<h1 id="v1-3-1-2019-01-19"><a href="#v1-3-1-2019-01-19" class="headerlink" title="v1.3.1 (2019-01-19)"></a>v1.3.1 (2019-01-19)</h1><ul>
<li>Bug Fixes: Issue of accounts balance display style switching in Overview</li>
<li>Bug Fixes: Issue of missing prompt text when deleting</li>
</ul>
<h1 id="v1-3-0-2019-01-05"><a href="#v1-3-0-2019-01-05" class="headerlink" title="v1.3.0 (2019-01-05)"></a>v1.3.0 (2019-01-05)</h1><ul>
<li>Advance search add files condition</li>
<li>Transaction Files: Displays all the files (Photos), can browse or view corresponding transactions</li>
<li>Bug Fixes: Remove transaction files compress code</li>
</ul>
<h1 id="v1-2-2-2019-01-03"><a href="#v1-2-2-2019-01-03" class="headerlink" title="v1.2.2 (2019-01-03)"></a>v1.2.2 (2019-01-03)</h1><ul>
<li>Bug fixes: When picking a location while editing transaction, pull up to load more locations may be reload on iOS 11.x.</li>
</ul>
<h1 id="v1-2-1-2018-12-29"><a href="#v1-2-1-2018-12-29" class="headerlink" title="v1.2.1 (2018-12-29)"></a>v1.2.1 (2018-12-29)</h1><ul>
<li>Bug Fixes: When editing a transaction, the selected category has linked tags but no update tags.</li>
</ul>
<h1 id="v1-2-0-2018-12-04"><a href="#v1-2-0-2018-12-04" class="headerlink" title="v1.2.0 (2018-12-04)"></a>v1.2.0 (2018-12-04)</h1><ul>
<li>Transaction Map displays all the location markers (only displays parts of location markers in iOS 11 and later)</li>
<li>Donate view modified</li>
<li>Add Storage (Database and Transaction Files) in “Settings” -&gt; “General”</li>
</ul>
<h1 id="v1-1-0-2018-11-06"><a href="#v1-1-0-2018-11-06" class="headerlink" title="v1.1.0 (2018-11-06)"></a>v1.1.0 (2018-11-06)</h1><ul>
<li>Search transactions add Advanced Search.</li>
<li>Fixed refreshing nearby POI when scrolling list in pick location view in iOS 12.</li>
<li>Can select all history locations.</li>
<li>Long press any transaction in Transactions can starting multi-select mode, can calculate total expenses and incomes money you selected, or can delete the selected transactions.</li>
<li>Click the transaction files to display the big image.</li>
<li>Transaction files display performance optimization</li>
<li>Fixed pending transaction modification without saving success.</li>
<li>Other bug fixes.</li>
</ul>
<h1 id="v1-0-6-2018-08-08"><a href="#v1-0-6-2018-08-08" class="headerlink" title="v1.0.6 (2018-08-08)"></a>v1.0.6 (2018-08-08)</h1><ul>
<li>UI Optimize.</li>
<li>Fixed the bug of Calculator’s calculate result precision.</li>
</ul>
<h1 id="v1-0-5-2018-07-16"><a href="#v1-0-5-2018-07-16" class="headerlink" title="v1.0.5 (2018-07-16)"></a>v1.0.5 (2018-07-16)</h1><ul>
<li>Bug Fixes: Adding wrong local notification when save account while opened repayment reminder.</li>
</ul>
<h1 id="v1-0-4-2018-07-15"><a href="#v1-0-4-2018-07-15" class="headerlink" title="v1.0.4 (2018-07-15)"></a>v1.0.4 (2018-07-15)</h1><ul>
<li>Transaction Search: Fuzzy searching category, note, accounts and money.</li>
<li>Transaction Map: Show transactions which saved location on the map.</li>
<li>Added some debugging mechanism.</li>
</ul>
<h1 id="v1-0-3-2018-07-10"><a href="#v1-0-3-2018-07-10" class="headerlink" title="v1.0.3 (2018-07-10)"></a>v1.0.3 (2018-07-10)</h1><ul>
<li>Picking location added history locations.</li>
<li>Security added TouchID (If device supports TouchID).</li>
<li>Fixed showing swap accounts button in non-transfer transaction when editing template.</li>
</ul>
<h1 id="v1-0-2-2018-07-04"><a href="#v1-0-2-2018-07-04" class="headerlink" title="v1.0.2 (2018-07-04)"></a>v1.0.2 (2018-07-04)</h1><ul>
<li>Accounts in Overview can fold or unfold.</li>
<li>Reminding user Notification permission has been Authorized or not.</li>
<li>When editing account to open the repayment reminder, determine whether there is permission to push Notification.</li>
<li>When editing transfer transaction, the from account and to account can be exchanged, saving time.</li>
</ul>
<h1 id="v1-0-1-2018-06-22"><a href="#v1-0-1-2018-06-22" class="headerlink" title="v1.0.1 (2018-06-22)"></a>v1.0.1 (2018-06-22)</h1><ul>
<li>Fixed 3D Touch shortcut title localization issue.</li>
<li>Currency code selection list add search, search by code alphabet.</li>
<li>Currency code selection list navigation bar adds “More&#x2F;Less” button, which can be switched to display only the currency code or localized name of currency code and code.</li>
<li>Income and Expense color can be switched.</li>
<li>Account add billing day and repayment due day reminders.</li>
<li>Fixed date picker dosen’t scroll to specific row while editing account’s billing date or repayment due date.</li>
</ul>
<h1 id="v1-0-0-2018-06-14"><a href="#v1-0-0-2018-06-14" class="headerlink" title="v1.0.0 (2018-06-14)"></a>v1.0.0 (2018-06-14)</h1><p>First version.</p>
<ul>
<li>Multiple accounts, Divided into ordinary accounts (such as wallet, Debit Card, etc.) and credit accounts (such as credit cards, etc.)</li>
<li>Calendar view, look up everyday’s transactions</li>
<li>Reports, Display incomes and expenses according to the selected period, and list the total incomes and expenses of each categories and tags</li>
<li>Transactions ordered in timeline, and display main infomations</li>
<li>Template, Same or similar transactions are pre-created as templates, saving time</li>
<li>Scheduled transaction, regular expenses set Repeating, will automatic accounting</li>
<li>Budgets, Set a good plan to save money</li>
<li>Multiple currencies, can set rate manually</li>
<li>Including two safe modes, Passcode and Pattern, default is None</li>
<li>Reminder, add reminders to prevent forgotten accounting, keep accounting habits</li>
</ul>
<p>All features are unlimited, such as unlimited number of created accounts, budgets, categories, tags, etc.</p>
<p>No Ads.</p>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>GeeMoon</tag>
        <tag>积木</tag>
      </tags>
  </entry>
  <entry>
    <title>积木版本历史</title>
    <url>/2018/06/08/app-geemoon-releases/</url>
    <content><![CDATA[<p>积木版本发布历史，记录积木的成长。</p>
<span id="more"></span>

<p><a href="https://meilbn.com/2018/06/08/app-geemoon-releases-en/">English</a></p>
<h1 id="v1-3-1-2019-01-19"><a href="#v1-3-1-2019-01-19" class="headerlink" title="v1.3.1 (2019-01-19)"></a>v1.3.1 (2019-01-19)</h1><ul>
<li>Bug 修复：首页账户余额显示样式切换的问题</li>
<li>Bug 修复：删除时提示文字缺失的问题</li>
</ul>
<h1 id="v1-3-0-2019-01-05"><a href="#v1-3-0-2019-01-05" class="headerlink" title="v1.3.0 (2019-01-05)"></a>v1.3.0 (2019-01-05)</h1><ul>
<li>高级搜索增加文件条件</li>
<li>交易文件：显示所有的文件（图片），可浏览，可查看对应的交易</li>
<li>Bug 修复：移除交易文件压缩代码</li>
</ul>
<h1 id="v1-2-2-2019-01-03"><a href="#v1-2-2-2019-01-03" class="headerlink" title="v1.2.2 (2019-01-03)"></a>v1.2.2 (2019-01-03)</h1><ul>
<li>Bug 修复：编辑交易选择地点时，地点列表上拉加载更多时，在 iOS 11.x 上可能会重复加载</li>
</ul>
<h1 id="v1-2-1-2018-12-29"><a href="#v1-2-1-2018-12-29" class="headerlink" title="v1.2.1 (2018-12-29)"></a>v1.2.1 (2018-12-29)</h1><ul>
<li>Bug 修复：在编辑交易时，选中的分类有链接标签但是没有更新标签</li>
</ul>
<h1 id="v1-2-0-2018-12-04"><a href="#v1-2-0-2018-12-04" class="headerlink" title="v1.2.0 (2018-12-04)"></a>v1.2.0 (2018-12-04)</h1><ul>
<li>交易地图显示所有的地点标记（iOS 11 以上以前只会显示部分地点）</li>
<li>捐赠界面修改</li>
<li>在“设置”-&gt;“通用”中增加查看存储空间功能（交易图片，数据库大小）</li>
</ul>
<h1 id="v1-1-0-2018-11-06"><a href="#v1-1-0-2018-11-06" class="headerlink" title="v1.1.0 (2018-11-06)"></a>v1.1.0 (2018-11-06)</h1><ul>
<li>搜索交易增加高级搜索功能</li>
<li>修复地点选择界面在 iOS 12 上滑动重新刷新 POI 的问题</li>
<li>可以选择全部的历史地点</li>
<li>交易界面长按任何一个交易，开启多选模式，显示选中的交易的收支总额，可以删除选中的交易</li>
<li>交易详情界面点击图片查看原图</li>
<li>交易图片显示性能优化</li>
<li>修复了未确认的交易修改没有保存成功的问题</li>
<li>其他小问题修复</li>
</ul>
<h1 id="v1-0-6-2018-08-08"><a href="#v1-0-6-2018-08-08" class="headerlink" title="v1.0.6 (2018-08-08)"></a>v1.0.6 (2018-08-08)</h1><ul>
<li>UI 优化</li>
<li>修复计算器计算结果精度问题</li>
</ul>
<h1 id="v1-0-5-2018-07-16"><a href="#v1-0-5-2018-07-16" class="headerlink" title="v1.0.5 (2018-07-16)"></a>v1.0.5 (2018-07-16)</h1><ul>
<li>修复了账户开启还款提醒时，添加本地通知有误的 Bug</li>
</ul>
<h1 id="v1-0-4-2018-07-15"><a href="#v1-0-4-2018-07-15" class="headerlink" title="v1.0.4 (2018-07-15)"></a>v1.0.4 (2018-07-15)</h1><ul>
<li>交易搜索：分类名称、备注、账户和金额模糊搜索</li>
<li>交易地图：在地图上显示保存过地点的交易</li>
<li>增加一些调试机制</li>
</ul>
<h1 id="v1-0-3-2018-07-10"><a href="#v1-0-3-2018-07-10" class="headerlink" title="v1.0.3 (2018-07-10)"></a>v1.0.3 (2018-07-10)</h1><ul>
<li>地点选择增加历史地点选择</li>
<li>修复编辑模板界面账户选择错误显示账户互换按钮的 Bug</li>
<li>安全模式增加 TouchID (仅限支持 TouchID 设备)</li>
</ul>
<h1 id="v1-0-2-2018-07-04"><a href="#v1-0-2-2018-07-04" class="headerlink" title="v1.0.2 (2018-07-04)"></a>v1.0.2 (2018-07-04)</h1><ul>
<li>概览界面账户列表可收起和展开</li>
<li>概览界面提醒用户通知权限是否授权</li>
<li>编辑账户的开启还款提醒时，判断是否有通知的权限</li>
<li>编辑转账交易时，两个账户可以互换，省时省力</li>
</ul>
<h1 id="v1-0-1-2018-06-22"><a href="#v1-0-1-2018-06-22" class="headerlink" title="v1.0.1 (2018-06-22)"></a>v1.0.1 (2018-06-22)</h1><ul>
<li>修复 3D Touch 快捷菜单文字本地化的问题</li>
<li>货币代码选择列表增加搜索，根据货币代码字母搜索</li>
<li>货币代码选择导航栏增加“详细&#x2F;简略”按钮，可以切换只显示货币代码或者显示货币代码对应的本地化名称</li>
<li>收入&#x2F;支出颜色可以互换</li>
<li>账户增加账单日和到期还款日提醒</li>
<li>修复了账户编辑选择账单日或到期还款日时，选择器没有滚动到当前日期的问题</li>
</ul>
<h1 id="v1-0-0-2018-06-14"><a href="#v1-0-0-2018-06-14" class="headerlink" title="v1.0.0 (2018-06-14)"></a>v1.0.0 (2018-06-14)</h1><p>第一版。</p>
<ul>
<li>多账户，分为普通账户（比如钱包、储蓄卡等）和信贷账户（比如信用卡等）</li>
<li>日历视图，查看每一天的交易</li>
<li>报表，按照选择的周期来显示收支情况，并且列出各个分类和标签的收支总额</li>
<li>交易列表按照时间排序，并显示一些主要信息</li>
<li>模板，相同或类似的交易预先创建成模板，记账更省时省事</li>
<li>定期交易，固定支出设置为定期交易，自动记账</li>
<li>预算，定好消费计划，节省不浪费</li>
<li>多币种，可以手动设置汇率</li>
<li>包含两种安全模式，密码和手势密码，默认为无</li>
<li>提醒，添加提醒，防止忘记记账，养好记账习惯</li>
</ul>
<p>所有功能无限制，比如不会限制创建的账户个数，预算个数，分类个数，标签个数等</p>
<p>软件无广告</p>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>GeeMoon</tag>
        <tag>积木</tag>
      </tags>
  </entry>
  <entry>
    <title>GeeMoon Roadmap</title>
    <url>/2018/06/08/app-geemoon-roadmap-en/</url>
    <content><![CDATA[<p><strong>DEPRECATED</strong></p>
<p><del>Features may add into GeeMoon in the future and known bugs.</del></p>
<span id="more"></span>

<p><a href="https://meilbn.com/2018/06/08/app-geemoon-roadmap/">中文版</a></p>
<h1 id="0x00-Features"><a href="#0x00-Features" class="headerlink" title="0x00 Features"></a>0x00 Features</h1><h2 id="0x0000-Overview"><a href="#0x0000-Overview" class="headerlink" title="0x0000 Overview"></a>0x0000 Overview</h2><ul>
<li><del>Accounts can fold or unfold. (Released in v1.0.2)</del></li>
<li><del>All account list use card layout, in addition show account name and balance, also show this account expenses and incomes count. (Released in v1.0.6)</del></li>
</ul>
<h2 id="0x0001-Account"><a href="#0x0001-Account" class="headerlink" title="0x0001 Account"></a>0x0001 Account</h2><ul>
<li><del>Billing date and Payment due date reminds. (Released in v1.0.1)</del></li>
</ul>
<h2 id="0x0002-Transactions"><a href="#0x0002-Transactions" class="headerlink" title="0x0002 Transactions"></a>0x0002 Transactions</h2><ul>
<li><del>Searching Transactions. (Released in v1.0.4)</del></li>
<li><del>Picking history locations. (Released in v1.0.3)</del></li>
<li><del>Transactions Map, show Transactions in map which saved with location. (Released in v1.0.4)</del></li>
<li>Category can set icon.</li>
<li><del>When editing transfer transaction, the from account and to account can be exchanged. (Released in v1.0.2)</del></li>
<li><del>Transaction detail adding “Add Same Transaction” and “Save As Template” features. (Released in v1.0.2)</del></li>
</ul>
<h2 id="0x0003-Others"><a href="#0x0003-Others" class="headerlink" title="0x0003 Others"></a>0x0003 Others</h2><ul>
<li><p><del>Searching currency code. (Released in v1.0.1)</del></p>
</li>
<li><p>Security adding try times and retry time.</p>
</li>
<li><p><del>Secutiry support TouchID. (Released in v1.0.3)</del></p>
</li>
<li><p>When period is Quarter, user can choose first quarter start with January or March.</p>
</li>
<li><p>Internationalization and localization, supporting more countries or regions language</p>
<ul>
<li>v1.0.0: Simplified Chinese, English</li>
</ul>
</li>
<li><p>Datas backup and restore.</p>
</li>
<li><p>Today Widgets.</p>
</li>
</ul>
<h2 id="0x0004-Eternal"><a href="#0x0004-Eternal" class="headerlink" title="0x0004 Eternal"></a>0x0004 Eternal</h2><ul>
<li>Beautify the UI, Optimize performance, Bug fixes.</li>
</ul>
<h1 id="0x01-Bugs"><a href="#0x01-Bugs" class="headerlink" title="0x01 Bugs"></a>0x01 Bugs</h1><ul>
<li><del>Calculator, precision problem (e.g. 27.3+10.96 &#x3D; 38.26.000000000001), used system function to calculate. (Fixed in v1.0.6)</del></li>
<li><del>Dosen’t request Notification permission while opening repayment reminder for editing account. (Fixed in v1.0.2)</del></li>
<li><del>3D Touch shortcut item (New Transaction) localization. (Fixed in v1.0.1)</del></li>
</ul>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>GeeMoon</tag>
        <tag>积木</tag>
      </tags>
  </entry>
  <entry>
    <title>积木路线图</title>
    <url>/2018/06/08/app-geemoon-roadmap/</url>
    <content><![CDATA[<p><strong>DEPRECATED</strong></p>
<p><del>未来可能会要加入到积木中的一些功能和一些已知的 Bug。</del></p>
<span id="more"></span>

<p><a href="https://meilbn.com/2018/06/08/app-geemoon-roadmap-en/">English</a></p>
<h1 id="0x00-功能"><a href="#0x00-功能" class="headerlink" title="0x00 功能"></a>0x00 功能</h1><h2 id="0x0000-概览界面"><a href="#0x0000-概览界面" class="headerlink" title="0x0000 概览界面"></a>0x0000 概览界面</h2><ul>
<li><del>账户列表可收起 &#x2F; 展开（v1.0.2 中已完成）</del></li>
<li><del>所有账户列表界面采用卡片式布局，除了展示账户名称和余额外，可以再展示此账户的收支总额（在 v1.0.6 中已完成）</del></li>
</ul>
<h2 id="0x0001-账户"><a href="#0x0001-账户" class="headerlink" title="0x0001 账户"></a>0x0001 账户</h2><ul>
<li><del>账单日和还款日提醒（v1.0.1 中已完成）</del></li>
</ul>
<h2 id="0x0002-交易"><a href="#0x0002-交易" class="headerlink" title="0x0002 交易"></a>0x0002 交易</h2><ul>
<li><del>交易搜索（在 v1.0.4 中已完成）</del></li>
<li><del>选择地点增加历史地点选择（v1.0.3 中已完成）</del></li>
<li><del>交易地图，在地图上显示保存过地点的交易（在 v1.0.4 中已完成）</del></li>
<li>分类可以设置图标</li>
<li><del>创建交易界面，转账的两个账户可以互相切换（v1.0.2 中已完成）</del></li>
<li><del>交易详情界面增加“再记一笔”和“保存为模板”功能（v1.0.2 中已完成）</del></li>
</ul>
<h2 id="0x0003-其他"><a href="#0x0003-其他" class="headerlink" title="0x0003 其他"></a>0x0003 其他</h2><ul>
<li><p><del>货币代码列表可搜索（v1.0.1 中已完成）</del></p>
</li>
<li><p>密码保护增加尝试次数和重试时间</p>
</li>
<li><p><del>安全模式增加 TouchID（v1.0.3 中已完成）</del></p>
</li>
<li><p>以季度为周期时，可以让用户选择是以1月开始还是3月开始第一季度</p>
</li>
<li><p>国际化，支持更多国家或地区的语言</p>
<ul>
<li>v1.0.0：简体中文、英语</li>
</ul>
</li>
<li><p>数据可以备份及恢复</p>
</li>
<li><p>Today Widgets</p>
</li>
</ul>
<h2 id="0x0004-永恒不变的"><a href="#0x0004-永恒不变的" class="headerlink" title="0x0004 永恒不变的"></a>0x0004 永恒不变的</h2><ul>
<li>美化 UI，优化性能，解决 Bug</li>
</ul>
<h1 id="0x01-Bugs"><a href="#0x01-Bugs" class="headerlink" title="0x01 Bugs"></a>0x01 Bugs</h1><ul>
<li><del>计算器，计算精度问题（例如计算 27.3+10.96 &#x3D; 38.26.000000000001），使用的是系统方法计算（在 v1.0.6 中已修复）</del></li>
<li><del>账户编辑界面开启还款提醒时，没有申请通知的权限（在 v1.0.2 中已修复）</del></li>
<li><del>3D Touch 快捷菜单 (New Transaction) 名称本地化。（在 v1.0.1 中已修复）</del></li>
</ul>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>GeeMoon</tag>
        <tag>积木</tag>
      </tags>
  </entry>
  <entry>
    <title>GeeMoon Usage Tips</title>
    <url>/2018/06/08/app-geemoon-tips-en/</url>
    <content><![CDATA[<p>You can find this page in “<a href="https://itunes.apple.com/us/app/apple-store/id1390979359?mt=8">GeeMoon</a>“ -&gt; “More” -&gt; “Tips”.</p>
<p>If you have any questions, suggestions or bugs, you can sending email to me in “<a href="https://itunes.apple.com/us/app/apple-store/id1390979359?mt=8">GeeMoon</a>“ -&gt; “More” -&gt; “Contact Me”. Or sending email directly to <a href="mailto:codingallnight@gmail.com">codingallnight@gmail.com</a>.</p>
<p>Or you can @ me on Weibo <a href="https://weibo.com/fuckingcode">@我的眼里只有代码</a> or Twitter <a href="https://twitter.com/meilbn">@meilbn</a>.</p>
<!-- Other social accont can be finf in my blog's profile page (mobile browser may not have profile page). -->
<span id="more"></span>

<p><a href="https://meilbn.com/2018/06/06/app-geemoon-tips/">中文版</a></p>
<h1 id="0x00-Tips-Index"><a href="#0x00-Tips-Index" class="headerlink" title="0x00 Tips Index"></a>0x00 Tips Index</h1><ul>
<li><a href="#title_overview">Overview</a></li>
<li><a href="#title_calculator">Calculator</a></li>
<li><a href="#title_transactions">Create or Edit Transaction</a></li>
<li><a href="#title_others">Others</a></li>
</ul>
<p><span id="title_overview"></span></p>
<h1 id="0x01-Overview"><a href="#0x01-Overview" class="headerlink" title="0x01 Overview"></a>0x01 Overview</h1><ul>
<li>Total Balance can tap twice to hide or show.</li>
<li>Tapping Account list to open all account list page.</li>
<li>Shake device in Overview page will open create Transaction page (configurable in future).</li>
</ul>
<p><span id="title_calculator"></span></p>
<h1 id="0x02-Calculator"><a href="#0x02-Calculator" class="headerlink" title="0x02 Calculator"></a>0x02 Calculator</h1><ul>
<li>Tapping “Equal mark (&#x3D;)” to calculating result or back to transaction editing page.</li>
</ul>
<p><span id="title_transactions"></span></p>
<h1 id="0x03-Create-or-Edit-Transaction"><a href="#0x03-Create-or-Edit-Transaction" class="headerlink" title="0x03 Create or Edit Transaction"></a>0x03 Create or Edit Transaction</h1><ul>
<li>Long press money view on top of page will reset money to 0.</li>
<li>Select category again can deselect.</li>
<li>Long press date will reset to current date.</li>
<li>Long press time will reset to current time.</li>
<li>Shake device in Transactions page will open create Transaction page (configurable in future).</li>
</ul>
<p><span id="title_others"></span></p>
<h1 id="0x04-Others"><a href="#0x04-Others" class="headerlink" title="0x04 Others"></a>0x04 Others</h1><ul>
<li>Calendar, Transactions and Budget Transactions list support 3D Touch to preview.</li>
<li>Support 3D Touch shortcut item, adding transaction quickly.</li>
</ul>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>GeeMoon</tag>
        <tag>积木</tag>
      </tags>
  </entry>
  <entry>
    <title>积木使用小技巧</title>
    <url>/2018/06/06/app-geemoon-tips/</url>
    <content><![CDATA[<p>可以在 “<a href="https://itunes.apple.com/cn/app/apple-store/id1390979359?mt=8">积木</a>” -&gt; “更多” -&gt; “小技巧” 找到这篇文章的入口。</p>
<p>有任何问题、建议或 Bug 都可以点击 “<a href="https://itunes.apple.com/cn/app/apple-store/id1390979359?mt=8">积木</a>” 中的 “更多” -&gt; “联系我” 来给我发邮件。或者直接发送到 <a href="mailto:codingallnight@gmail.com">codingallnight@gmail.com</a>。</p>
<p>或者可以在微博上 at 我 <a href="https://weibo.com/fuckingcode">@我的眼里只有代码</a>。</p>
<!-- 其他社交账号也可以在我博客的资料页面里面找到（手机端浏览器可能是没有资料页面的）。 -->
<span id="more"></span>

<p><a href="https://meilbn.com/2018/06/08/app-geemoon-tips-en/">English</a></p>
<h1 id="0x00-小技巧列表"><a href="#0x00-小技巧列表" class="headerlink" title="0x00 小技巧列表"></a>0x00 小技巧列表</h1><ul>
<li><a href="#title_overview">概览界面</a></li>
<li><a href="#title_calculator">计算器界面</a></li>
<li><a href="#title_transactions">创建 &#x2F; 编辑交易</a></li>
<li><a href="#title_others">其他</a></li>
</ul>
<p><span id="title_overview"></span></p>
<h1 id="0x01-概览界面"><a href="#0x01-概览界面" class="headerlink" title="0x01 概览界面"></a>0x01 概览界面</h1><ul>
<li>总余额（金额）双击隐藏或展示</li>
<li>点击账户（列表）进入所有账户列表</li>
<li>在概览界面摇晃手机，打开新增交易界面（后期可配置）</li>
</ul>
<p><span id="title_calculator"></span></p>
<h1 id="0x02-计算器界面"><a href="#0x02-计算器界面" class="headerlink" title="0x02 计算器界面"></a>0x02 计算器界面</h1><ul>
<li>点击“等号”计算结果或者返回编辑界面</li>
</ul>
<p><span id="title_transactions"></span></p>
<h1 id="0x03-创建-x2F-编辑交易"><a href="#0x03-创建-x2F-编辑交易" class="headerlink" title="0x03 创建 &#x2F; 编辑交易"></a>0x03 创建 &#x2F; 编辑交易</h1><ul>
<li>长按顶部金额视图会重置金额为 0</li>
<li>再次点击已选中的分类取消选中</li>
<li>长按日期重置为当前日期</li>
<li>长按时间重置为当前时间</li>
<li>在交易列表界面摇晃手机，打开新增交易界面（后期可配置）</li>
</ul>
<p><span id="title_others"></span></p>
<h1 id="0x04-其他"><a href="#0x04-其他" class="headerlink" title="0x04 其他"></a>0x04 其他</h1><ul>
<li>日历、交易列表和预算交易列表界面支持 3D Touch 预览</li>
<li>软件图标 3D Touch 快速新建交易</li>
</ul>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>GeeMoon</tag>
        <tag>积木</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器扩展插件</title>
    <url>/2015/07/02/browser-extensions/</url>
    <content><![CDATA[<h1 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h1><p>通过 Chrome 网上应用店安装扩展需要梯子。</p>
<ul>
<li><a href="https://agilebits.com/onepassword/extensions">1Password: Password Manager and Secure Wallet</a>：Mac 上安装了 1Password 的话，搭配浏览器插件来使用，非常的棒！支持 Chrome、Firefox、Safari。</li>
<li><a href="https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb?hl=zh-CN">Adblock Plus</a>：屏蔽广告，非常好用，屏蔽规则支持正则。我常用来手动屏蔽网页广告元素。</li>
<li><a href="https://chrome.google.com/webstore/detail/ip-whois-flags-chrome-web/kmdfbacgombndnllogoijhnggalgmkon?hl=zh-CN">IP Whois &amp; Flags Chrome &amp; Websites Rating</a>：查看网站的各种信息。</li>
<li><a href="https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj?hl=zh-CN">Save to Pocket</a>：一键保存到 Pocket。</li>
<li><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN">Tampermonkey</a>：管理脚本的插件，同 Firefox 上的 Greasemonkey。</li>
<li><a href="https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg?hl=zh-CN">The Great Suspender</a>：将暂时不用的标签页挂起，节省系统资源。这个我一般是将需要经常打开，但是使用频率不那么大的标签页挂起。</li>
<li><a href="https://chrome.google.com/webstore/detail/user-agent-switcher/ffhkkpnppgnfaobgihpdblnhmmbodake?hl=zh-CN">User-Agent Switcher</a>：切换各种客户端状态。</li>
<li><a href="https://chrome.google.com/webstore/detail/video-downloader-professi/elicpjhcidhpjomhibiffojpinpmmpil?hl=zh-CN">Video Downloader professional</a>：下载网页视频。</li>
<li><a href="https://chrome.google.com/webstore/detail/xmarks-bookmark-sync/ajpgkpeckebdhofmmjfgcjjiiejpodla?hl=zh-CN">Xmarks Bookmark Sync</a>：浏览器书签同步，支持 Chrome、Firefox、Safari。</li>
<li><a href="https://chrome.google.com/webstore/detail/%E7%9C%BC%E4%B8%8D%E8%A7%81%E5%BF%83%E4%B8%8D%E7%83%A6%EF%BC%88%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%EF%BC%89/aognaapdfnnldnjglanfbbklaakbpejm?hl=zh-CN">眼不见心不烦（新浪微博）</a>：恩，如果你对渣浪的广告等页面模块非常讨厌，这个就非常适合你，必装扩展之一！</li>
</ul>
<h1 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h1><ul>
<li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/greasemonkey/">Greasemonkey</a>：油猴子。通过使用少量的 JavaScript 脚本，自定义网页显示方式或表现方式。</li>
<li>1Password：同 Chrome</li>
<li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/adblock-plus/?src=search">Adblock Plus</a>：屏蔽网页广告。</li>
<li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/firebug/?src=search">Firebug</a>：Firebug 为你的 Firefox 集成了浏览网页的同时随手可得的丰富开发工具。你可以对任何网页的 CSS、HTML 和 JavaScript 进行实时编辑、调试和监控。</li>
<li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/firegestures/?src=search">FireGestures</a>：一个定制的鼠标手势扩展，可以通过五种类型手势执行各种命令和用户脚本。</li>
<li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/flagfox/?src=search">Flagfox</a>：显示描述当前服务器位置的国旗。</li>
<li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/netvideohunter-video-downloade/?src=search">NetVideoHunter</a>：这款扩展是一个辅助下载工具，它能帮助你从 Youtube、Facebook、Metacafe、Dailymotion、Break、VKontakte、DivShare 以及其他更多网站上轻松下载视频和音乐。</li>
<li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/user-agent-overrider/?src=search">User Agent Overrider</a>：切换各种客户端状态。</li>
<li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/xmarks-sync/?src=search">Xmarks</a>：如果您在多台机器上的使用 Firefox ，您就会用到 Foxmarks。在每一台机器上安装 Foxmarks，它会在后台安静的工作，保持书签的同步。您也可以登录到 my.foxmarks.com 来管理您的书签。</li>
<li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/quick-markup/?src=search">图桌</a>：可以任意截取网页，并标注形状、文字、图标，思维导图信息，最后将其导出为 PNG 格式的图片，或者一键发布到新浪微博等社区。用于整理思路和工作，计划和跟踪项目，解决基于图片的信息交流问题。</li>
<li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/image-picker/?src=search">集图工具(ImagePicker)</a>：从浏览中的网页中，过滤并选择喜爱的图片保存。对于网页图片非常多的情况下很方便！</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2015/06/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="http://hexo.io/">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>一些开发中用到的方法</title>
    <url>/2017/11/08/collecting-some-of-the-methods-in-the-development/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本文是一些我在开发过程中用到的比较有用、能用且好用的方法等一些干货。<br>将这些写成一篇文章，以后用到也能比较快的找到。</p>
<span id="more"></span>

<h1 id="0x01-iOS"><a href="#0x01-iOS" class="headerlink" title="0x01 iOS"></a>0x01 iOS</h1><h2 id="0x0100-获取-APP-信息"><a href="#0x0100-获取-APP-信息" class="headerlink" title="0x0100 获取 APP 信息"></a>0x0100 获取 APP 信息</h2><ul>
<li>获取 App 的版本号：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)appVersion &#123;</span><br><span class="line">    <span class="keyword">return</span> [[[<span class="built_in">NSBundle</span> mainBundle] infoDictionary] objectForKey:<span class="string">@&quot;CFBundleShortVersionString&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 App 的 Build 号：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)appBuildNumber &#123;</span><br><span class="line">    <span class="keyword">return</span> [[[<span class="built_in">NSBundle</span> mainBundle] infoDictionary] objectForKey:(<span class="built_in">NSString</span> *)kCFBundleVersionKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x0101-获取设备信息"><a href="#0x0101-获取设备信息" class="headerlink" title="0x0101 获取设备信息"></a>0x0101 获取设备信息</h2><ul>
<li>获取 deviceModel：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)deviceModel &#123;</span><br><span class="line">    <span class="keyword">struct</span> utsname systemInfo;</span><br><span class="line">    uname(&amp;systemInfo);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithCString:systemInfo.machine encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 Nodename：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)deviceNodename &#123;</span><br><span class="line">    <span class="keyword">struct</span> utsname systemInfo;</span><br><span class="line">    uname(&amp;systemInfo);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithCString:systemInfo.nodename encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取手机型号：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)modelName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *machine = [MLBUtilities deviceModel];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPod5,1&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPod Touch 5&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPod7,1&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPod Touch 6&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone3,1&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPhone3,2&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPhone3,3&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 4&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone4,1&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 4s&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone5,1&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPhone5,2&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 5&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone5,3&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPhone5,4&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 5c&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone6,1&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPhone6,2&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 5s&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone7,2&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 6&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone7,1&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 6 Plus&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone8,1&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 6s&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone8,2&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 6s Plus&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone8,4&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone SE&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone9,1&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPhone9,3&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 7&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone9,2&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPhone9,4&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 7 Plus&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone10,1&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPhone10,4&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 8&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone10,2&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPhone10,5&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone 8 Plus&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPhone10,3&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPhone10,6&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPhone X&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad2,1&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad2,2&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad2,3&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad2,4&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad 2&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad3,1&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad3,2&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad3,3&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad 3&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad3,4&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad3,5&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad3,6&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad 4&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad4,1&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad4,2&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad4,3&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad Air&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad5,3&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad5,4&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad Air 2&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad6,11&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad6,12&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad 5&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad2,5&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad2,6&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad2,7&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad Mini&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad4,4&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad4,5&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad4,6&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad Mini 2&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad4,7&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad4,8&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad4,9&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad Mini 3&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad5,1&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad5,2&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad Mini 4&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad6,3&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad6,4&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad Pro 9.7 Inch&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad6,7&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad6,8&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad Pro 12.9 Inch&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad7,1&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad7,2&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad Pro 12.9 Inch 2. Generation&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;iPad7,3&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;iPad7,4&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;iPad Pro 10.5 Inch&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;AppleTV5,3&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;Apple TV&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([machine isEqualToString:<span class="string">@&quot;i386&quot;</span>] || [machine isEqualToString:<span class="string">@&quot;x86_64&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@-Simulator&quot;</span>, <span class="keyword">self</span>.localizedModel];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> machine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x0102-地图相关"><a href="#0x0102-地图相关" class="headerlink" title="0x0102 地图相关"></a>0x0102 地图相关</h2><ul>
<li>打开系统地图：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)openMapWithlatitude:(<span class="type">double</span>)latitude longitude:(<span class="type">double</span>)longitude name:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="built_in">CLLocationDistance</span> regionDistance = <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">CLLocationCoordinate2D</span> coord = <span class="built_in">CLLocationCoordinate2DMake</span>(latitude, longitude);</span><br><span class="line">    <span class="built_in">CLLocationCoordinate2D</span> coordGCJ = [<span class="keyword">self</span> transformFromWGSToGCJ:coord];</span><br><span class="line">    <span class="built_in">MKCoordinateRegion</span> regionSpan = <span class="built_in">MKCoordinateRegionMakeWithDistance</span>(coordGCJ, regionDistance, regionDistance);</span><br><span class="line">    <span class="built_in">NSDictionary</span> *options = @&#123;<span class="built_in">MKLaunchOptionsMapCenterKey</span> : [<span class="built_in">NSValue</span> valueWithMKCoordinate:regionSpan.center],</span><br><span class="line">                              <span class="built_in">MKLaunchOptionsMapSpanKey</span> : [<span class="built_in">NSValue</span> valueWithMKCoordinateSpan:regionSpan.span]&#125;;</span><br><span class="line">    <span class="built_in">MKPlacemark</span> *placemark = [[<span class="built_in">MKPlacemark</span> alloc] initWithCoordinate:coordGCJ addressDictionary:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">MKMapItem</span> *mapItem = [[<span class="built_in">MKMapItem</span> alloc] initWithPlacemark:placemark];</span><br><span class="line">    mapItem.name = name;</span><br><span class="line">    [mapItem openInMapsWithLaunchOptions:options];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>各类坐标转换：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">double</span> pi = <span class="number">3.14159265358979324</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">double</span> x_pi = pi * <span class="number">3000.0</span> / <span class="number">180.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">double</span> a = <span class="number">6378245.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">double</span> ee = <span class="number">0.00669342162296594323</span>;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)bdLat:(<span class="type">double</span>)bd_lat Lon:(<span class="type">double</span>)bd_lon toAMapLat:(<span class="type">double</span> *)gg_lat aMaplng:(<span class="type">double</span> *)gg_lon &#123;</span><br><span class="line">    <span class="type">double</span> x = bd_lon - <span class="number">0.0065</span>, y = bd_lat - <span class="number">0.006</span>;</span><br><span class="line">    <span class="type">double</span> z = sqrt(x * x + y * y) - <span class="number">0.00002</span> * sin(y * x_pi);</span><br><span class="line">    <span class="type">double</span> theta = atan2(y, x) - <span class="number">0.000003</span> * cos(x * x_pi);</span><br><span class="line">    *gg_lon = z * cos(theta);</span><br><span class="line">    *gg_lat = z * sin(theta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  将 WGS 的经纬度（GPS）转成 GCJ 的经纬度（比如高德）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param wgsLoc wgs 经纬度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return GCJ 经纬度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">CLLocationCoordinate2D</span>)transformFromWGSToGCJ:(<span class="built_in">CLLocationCoordinate2D</span>)wgsLoc &#123;</span><br><span class="line">    <span class="built_in">CLLocationCoordinate2D</span> adjustLoc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isLocationOutOfChina:wgsLoc])&#123;</span><br><span class="line">        adjustLoc = wgsLoc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">double</span> adjustLat = [<span class="keyword">self</span> transformLatWithX:wgsLoc.longitude - <span class="number">105.0</span> withY:wgsLoc.latitude - <span class="number">35.0</span>];</span><br><span class="line">        <span class="type">double</span> adjustLon = [<span class="keyword">self</span> transformLonWithX:wgsLoc.longitude - <span class="number">105.0</span> withY:wgsLoc.latitude - <span class="number">35.0</span>];</span><br><span class="line">        <span class="type">double</span> radLat = wgsLoc.latitude / <span class="number">180.0</span> * pi;</span><br><span class="line">        <span class="type">double</span> magic = sin(radLat);</span><br><span class="line">        magic = <span class="number">1</span> - ee * magic * magic;</span><br><span class="line">        <span class="type">double</span> sqrtMagic = sqrt(magic);</span><br><span class="line">        adjustLat = (adjustLat * <span class="number">180.0</span>) / ((a * (<span class="number">1</span> - ee)) / (magic * sqrtMagic) * pi);</span><br><span class="line">        adjustLon = (adjustLon * <span class="number">180.0</span>) / (a / sqrtMagic * cos(radLat) * pi);</span><br><span class="line">        adjustLoc.latitude = wgsLoc.latitude + adjustLat;</span><br><span class="line">        adjustLoc.longitude = wgsLoc.longitude + adjustLon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> adjustLoc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  判断经纬度是否在中国</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param location  经纬度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 是否在中国</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isLocationOutOfChina:(<span class="built_in">CLLocationCoordinate2D</span>)location &#123;</span><br><span class="line">    <span class="keyword">if</span> (location.longitude &lt; <span class="number">72.004</span> || location.longitude &gt; <span class="number">137.8347</span> || location.latitude &lt; <span class="number">0.8293</span> || location.latitude &gt; <span class="number">55.8271</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">double</span>)transformLatWithX:(<span class="type">double</span>)x withY:(<span class="type">double</span>)y &#123;</span><br><span class="line">    <span class="type">double</span> lat = <span class="number">-100.0</span> + <span class="number">2.0</span> * x + <span class="number">3.0</span> * y + <span class="number">0.2</span> * y * y + <span class="number">0.1</span> * x * y + <span class="number">0.2</span> * sqrt(fabs(x));</span><br><span class="line">    lat += (<span class="number">20.0</span> * sin(<span class="number">6.0</span> * x * pi) + <span class="number">20.0</span> *sin(<span class="number">2.0</span> * x * pi)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    lat += (<span class="number">20.0</span> * sin(y * pi) + <span class="number">40.0</span> * sin(y / <span class="number">3.0</span> * pi)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    lat += (<span class="number">160.0</span> * sin(y / <span class="number">12.0</span> * pi) + <span class="number">320</span> * sin(y * pi / <span class="number">30.0</span>)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> lat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">double</span>)transformLonWithX:(<span class="type">double</span>)x withY:(<span class="type">double</span>)y &#123;</span><br><span class="line">    <span class="type">double</span> lon = <span class="number">300.0</span> + x + <span class="number">2.0</span> * y + <span class="number">0.1</span> * x * x + <span class="number">0.1</span> * x * y + <span class="number">0.1</span> * sqrt(fabs(x));</span><br><span class="line">    lon += (<span class="number">20.0</span> * sin(<span class="number">6.0</span> * x * pi) + <span class="number">20.0</span> * sin(<span class="number">2.0</span> * x * pi)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    lon += (<span class="number">20.0</span> * sin(x * pi) + <span class="number">40.0</span> * sin(x / <span class="number">3.0</span> * pi)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    lon += (<span class="number">150.0</span> * sin(x / <span class="number">12.0</span> * pi) + <span class="number">300.0</span> * sin(x / <span class="number">30.0</span> * pi)) * <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> lon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  GJC 经纬度（比如高德）转成 WGS 经纬度（GPS）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param location GJC 经纬度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return WGS 经纬度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">CLLocationCoordinate2D</span>)transformFromGCJ02ToWGS84:(<span class="built_in">CLLocationCoordinate2D</span>)location &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> gcj02Decrypt:location.latitude gjLon:location.longitude];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CLLocationCoordinate2D</span>)gcj02Decrypt:(<span class="type">double</span>)gjLat gjLon:(<span class="type">double</span>)gjLon &#123;</span><br><span class="line">    <span class="built_in">CLLocationCoordinate2D</span>  gPt = [<span class="keyword">self</span> gcj02Encrypt:gjLat bdLon:gjLon];</span><br><span class="line">    <span class="type">double</span> dLon = gPt.longitude - gjLon;</span><br><span class="line">    <span class="type">double</span> dLat = gPt.latitude - gjLat;</span><br><span class="line">    <span class="built_in">CLLocationCoordinate2D</span> pt;</span><br><span class="line">    pt.latitude = gjLat - dLat;</span><br><span class="line">    pt.longitude = gjLon - dLon;</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CLLocationCoordinate2D</span>)gcj02Encrypt:(<span class="type">double</span>)ggLat bdLon:(<span class="type">double</span>)ggLon &#123;</span><br><span class="line">    <span class="built_in">CLLocationCoordinate2D</span> resPoint;</span><br><span class="line">    <span class="type">double</span> mgLat;</span><br><span class="line">    <span class="type">double</span> mgLon;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isLocationOutOfChina:<span class="built_in">CLLocationCoordinate2DMake</span>(ggLat, ggLon)]) &#123;</span><br><span class="line">        resPoint.latitude = ggLat;</span><br><span class="line">        resPoint.longitude = ggLon;</span><br><span class="line">        <span class="keyword">return</span> resPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> dLat = [<span class="keyword">self</span> transformLatWithX:(ggLon - <span class="number">105.0</span>) withY:(ggLat - <span class="number">35.0</span>)];</span><br><span class="line">    <span class="type">double</span> dLon = [<span class="keyword">self</span> transformLonWithX:(ggLon - <span class="number">105.0</span>) withY:(ggLat - <span class="number">35.0</span>)];</span><br><span class="line">    <span class="type">double</span> radLat = ggLat / <span class="number">180.0</span> * M_PI;</span><br><span class="line">    <span class="type">double</span> magic = sin(radLat);</span><br><span class="line">    magic = <span class="number">1</span> - ee * magic * magic;</span><br><span class="line">    <span class="type">double</span> sqrtMagic = sqrt(magic);</span><br><span class="line">    dLat = (dLat * <span class="number">180.0</span>) / ((a * (<span class="number">1</span> - ee)) / (magic * sqrtMagic) * M_PI);</span><br><span class="line">    dLon = (dLon * <span class="number">180.0</span>) / (a / sqrtMagic * cos(radLat) * M_PI);</span><br><span class="line">    mgLat = ggLat + dLat;</span><br><span class="line">    mgLon = ggLon + dLon;</span><br><span class="line">    </span><br><span class="line">    resPoint.latitude = mgLat;</span><br><span class="line">    resPoint.longitude = mgLon;</span><br><span class="line">    <span class="keyword">return</span> resPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x0103-字符串"><a href="#0x0103-字符串" class="headerlink" title="0x0103 字符串"></a>0x0103 字符串</h2><ul>
<li>将对象转成字符串，可以防止 NSNull 对象：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)stringWithObject:(<span class="type">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">NSNull</span> *)object == [<span class="built_in">NSNull</span> null]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, object];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>随机字符串：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> letters = <span class="string">@&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)randomLettersWithCount:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *string = <span class="string">@&quot;&quot;</span>.mutableCopy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        uint32_t random = arc4random_uniform(letters.length);</span><br><span class="line">        [string appendString:[letters substringWithRange:<span class="built_in">NSMakeRange</span>(random, <span class="number">1</span>)]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [string <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>给文字添加行间距：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSAttributedString</span> *)attributedStringWithText:(<span class="built_in">NSString</span> *)text lineSpacing:(<span class="built_in">CGFloat</span>)lineSpacing font:(<span class="built_in">UIFont</span> *)font textColor:(<span class="built_in">UIColor</span> *)textColor &#123;</span><br><span class="line">    <span class="built_in">NSMutableParagraphStyle</span> *paragraphStyle = [[<span class="built_in">NSMutableParagraphStyle</span> alloc] init];</span><br><span class="line">    paragraphStyle.lineSpacing = lineSpacing;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *attrsDictionary = @&#123;<span class="built_in">NSFontAttributeName</span> : font, <span class="built_in">NSForegroundColorAttributeName</span> : textColor, <span class="built_in">NSParagraphStyleAttributeName</span> : paragraphStyle&#125;;</span><br><span class="line">    <span class="built_in">NSAttributedString</span> *attributedString =  [[<span class="built_in">NSAttributedString</span> alloc] initWithString:text attributes:attrsDictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> attributedString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x0104-图片"><a href="#0x0104-图片" class="headerlink" title="0x0104 图片"></a>0x0104 图片</h2><p>公共方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)createNonInterpolatedUIImageFromCIImage:(<span class="built_in">CIImage</span> *)image withScale:(<span class="built_in">CGFloat</span>)scale &#123;</span><br><span class="line">    <span class="comment">// Render the CIImage into a CGImage</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> cgImage = [[<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>] createCGImage:image fromRect:image.extent];</span><br><span class="line">    <span class="comment">// Now we&#x27;ll rescale using CoreGraphics</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(image.extent.size.width * scale, image.extent.size.width * scale));</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">// We don&#x27;t want to interpolate (since we&#x27;ve got a pixel-correct image)</span></span><br><span class="line">    <span class="built_in">CGContextSetInterpolationQuality</span>(context, kCGInterpolationNone);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGContextGetClipBoundingBox</span>(context), cgImage);</span><br><span class="line">    <span class="comment">// Get the image out</span></span><br><span class="line">    <span class="built_in">UIImage</span> *scaledImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">// Tidy up</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgImage);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> scaledImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成二维码：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)generateQRCodeImageWithString:(<span class="built_in">NSString</span> *)qrString scale:(<span class="built_in">CGFloat</span>)scale color:(<span class="built_in">UIColor</span> *)color backgroundColor:(<span class="built_in">UIColor</span> *)backgroundColor &#123;</span><br><span class="line">    <span class="built_in">CIFilter</span> *qrFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@&quot;CIQRCodeGenerator&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (!qrFilter) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: Could not load filter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *stringData = [qrString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]; <span class="comment">// NSISOLatin1StringEncoding</span></span><br><span class="line">    [qrFilter setValue:stringData forKey:<span class="string">@&quot;inputMessage&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIFilter</span> *colorQRFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@&quot;CIFalseColor&quot;</span>];</span><br><span class="line">    [colorQRFilter setValue:qrFilter.outputImage forKey:<span class="string">@&quot;inputImage&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二维码颜色</span></span><br><span class="line">    <span class="keyword">if</span> (color == <span class="literal">nil</span>) &#123;</span><br><span class="line">        color = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (backgroundColor == <span class="literal">nil</span>) &#123;</span><br><span class="line">        backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [colorQRFilter setValue:[<span class="built_in">CIColor</span> colorWithCGColor:color.CGColor] forKey:<span class="string">@&quot;inputColor0&quot;</span>];</span><br><span class="line">    <span class="comment">// 背景颜色</span></span><br><span class="line">    [colorQRFilter setValue:[<span class="built_in">CIColor</span> colorWithCGColor:backgroundColor.CGColor] forKey:<span class="string">@&quot;inputColor1&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIImage</span> *ciImage = colorQRFilter.outputImage;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *qrCodeImage = [<span class="keyword">self</span> createNonInterpolatedUIImageFromCIImage:ciImage withScale:scale * [<span class="built_in">UIScreen</span> mainScreen].scale];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> qrCodeImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成条形码：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)generateBarcodeImageWithString:(<span class="built_in">NSString</span> *)codeString scale:(<span class="built_in">CGFloat</span>)scale color:(<span class="built_in">UIColor</span> *)color backgroundColor:(<span class="built_in">UIColor</span> *)backgroundColor &#123;</span><br><span class="line">    <span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@&quot;CICode128BarcodeGenerator&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (!filter) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: Could not load filter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *data = [codeString dataUsingEncoding:<span class="built_in">NSISOLatin1StringEncoding</span> allowLossyConversion:<span class="literal">false</span>];</span><br><span class="line">    [filter setValue:data forKey:<span class="string">@&quot;inputMessage&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIFilter</span> * colorFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@&quot;CIFalseColor&quot;</span>];</span><br><span class="line">    [colorFilter setValue:filter.outputImage forKey:<span class="string">@&quot;inputImage&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条形码颜色</span></span><br><span class="line">    <span class="keyword">if</span> (color == <span class="literal">nil</span>) &#123;</span><br><span class="line">        color = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (backgroundColor == <span class="literal">nil</span>) &#123;</span><br><span class="line">        backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [colorFilter setValue:[<span class="built_in">CIColor</span> colorWithCGColor:color.CGColor] forKey:<span class="string">@&quot;inputColor0&quot;</span>];</span><br><span class="line">    <span class="comment">// 背景颜色</span></span><br><span class="line">    [colorFilter setValue:[<span class="built_in">CIColor</span> colorWithCGColor:backgroundColor.CGColor] forKey:<span class="string">@&quot;inputColor1&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIImage</span> *ciImage = colorFilter.outputImage;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *barCodeImage = [<span class="keyword">self</span> createNonInterpolatedUIImageFromCIImage:ciImage withScale:scale * [<span class="built_in">UIScreen</span> mainScreen].scale];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> barCodeImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UIView 转 UIImage：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)renderImageFromView:(<span class="built_in">UIView</span> *)view withRect:(<span class="built_in">CGRect</span>)frame transparentInsets:(<span class="built_in">UIEdgeInsets</span>)insets &#123;</span><br><span class="line">    <span class="built_in">CGSize</span> imageSizeWithBorder = <span class="built_in">CGSizeMake</span>(frame.size.width + insets.left + insets.right, frame.size.height + insets.top + insets.bottom);</span><br><span class="line">    <span class="comment">// Create a new context of the desired size to render the image</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(imageSizeWithBorder, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clip the context to the portion of the view we will draw</span></span><br><span class="line">    <span class="built_in">CGContextClipToRect</span>(context, (<span class="built_in">CGRect</span>)&#123;&#123;insets.left, insets.top&#125;, frame.size&#125;);</span><br><span class="line">    <span class="comment">// Translate it, to the desired position</span></span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, -frame.origin.x + insets.left, -frame.origin.y + insets.top);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Render the view as image</span></span><br><span class="line">    [view.layer renderInContext:<span class="built_in">UIGraphicsGetCurrentContext</span>()];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fetch the image</span></span><br><span class="line">    <span class="built_in">UIImage</span> *renderedImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Cleanup</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> renderedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UIColor 转 UIImage：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithColor:(<span class="built_in">UIColor</span> *)aColor &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithColor:aColor withFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithColor:(<span class="built_in">UIColor</span> *)aColor withFrame:(<span class="built_in">CGRect</span>)aFrame &#123;</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(aFrame.size);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, [aColor <span class="built_in">CGColor</span>]);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, aFrame);</span><br><span class="line">    <span class="built_in">UIImage</span> *img = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x0105-其他"><a href="#0x0105-其他" class="headerlink" title="0x0105 其他"></a>0x0105 其他</h2><ul>
<li>按照给定的总数和每列的个数计算行数：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSInteger</span>)rowsWithCount:(<span class="built_in">NSInteger</span>)count colNumber:(<span class="built_in">NSInteger</span>)colNumber &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> rows = ceilf(count / (<span class="built_in">CGFloat</span>)colNumber);</span><br><span class="line">    <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将数字转成中文大写金额：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *chineseDigits;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)stringFromMoney:(<span class="built_in">CGFloat</span>)amount &#123;</span><br><span class="line">    <span class="keyword">if</span> (!chineseDigits) &#123;</span><br><span class="line">        chineseDigits = @[<span class="string">@&quot;零&quot;</span>, <span class="string">@&quot;壹&quot;</span>, <span class="string">@&quot;贰&quot;</span>, <span class="string">@&quot;叁&quot;</span>, <span class="string">@&quot;肆&quot;</span>, <span class="string">@&quot;伍&quot;</span>, <span class="string">@&quot;陆&quot;</span>, <span class="string">@&quot;柒&quot;</span>, <span class="string">@&quot;捌&quot;</span>, <span class="string">@&quot;玖&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (amount &gt; <span class="number">99999999999999.99</span> || amount &lt; <span class="number">-99999999999999.99</span>) &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(<span class="literal">YES</span>, <span class="string">@&quot;参数值超出允许范围 (-99999999999999.99 ～ 99999999999999.99)！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        negative = <span class="literal">true</span>;</span><br><span class="line">        amount = amount * (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> temp = round(amount * <span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> numFen = (<span class="type">int</span>)(temp % <span class="number">10</span>); <span class="comment">// 分</span></span><br><span class="line">    temp = temp / <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> numJiao = (<span class="type">int</span>)(temp % <span class="number">10</span>); <span class="comment">//角</span></span><br><span class="line">    temp = temp / <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// temp 目前是金额的整数部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *parts = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">20</span>]; <span class="comment">// 其中的元素是把原来金额整数部分分割为值在 0~9999 之间的数的各个部分</span></span><br><span class="line">    <span class="type">int</span> numParts = <span class="number">0</span>; <span class="comment">// 记录把原来金额整数部分分割为了几个部分（每部分都在 0~9999 之间）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> part = (<span class="type">int</span>)(temp % <span class="number">10000</span>);</span><br><span class="line">        parts[i] = @(part);</span><br><span class="line">        numParts++;</span><br><span class="line">        temp = temp / <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> beforeWanIsZero = <span class="literal">true</span>; <span class="comment">// 标志“万”下面一级是不是 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *chineseStr = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numParts; i++) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *partChinese = [MLBUtilities partTranslate:[parts[i] intValue]];</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (IsStringEmpty(partChinese)) &#123;</span><br><span class="line">                beforeWanIsZero = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                beforeWanIsZero = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                chineseStr = [<span class="string">@&quot;亿&quot;</span> stringByAppendingString:chineseStr];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (IsStringEmpty(partChinese) &amp;&amp; !beforeWanIsZero) &#123; <span class="comment">// 如果“万”对应的 part 为 0，而“万”下面一级不为 0，则不加“万”，而加“零”</span></span><br><span class="line">                    chineseStr = [<span class="string">@&quot;零&quot;</span> stringByAppendingString:chineseStr];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ([parts[i<span class="number">-1</span>] intValue] &lt; <span class="number">1000</span> &amp;&amp; [parts[i<span class="number">-1</span>] intValue] &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果&quot;万&quot;的部分不为 0, 而&quot;万&quot;前面的部分小于 1000 大于 0， 则万后面应该跟“零”</span></span><br><span class="line">                        chineseStr = [<span class="string">@&quot;零&quot;</span> stringByAppendingString:chineseStr];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    chineseStr = [<span class="string">@&quot;万&quot;</span> stringByAppendingString:chineseStr];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        chineseStr = [partChinese stringByAppendingString:chineseStr];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (IsStringEmpty(chineseStr)) &#123; <span class="comment">// 整数部分为 0, 则表达为&quot;零元&quot;</span></span><br><span class="line">        chineseStr = chineseDigits[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (negative) &#123; <span class="comment">// 整数部分不为 0, 并且原金额为负数</span></span><br><span class="line">        chineseStr = [<span class="string">@&quot;负&quot;</span> stringByAppendingString:chineseStr];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    chineseStr = [chineseStr stringByAppendingString:<span class="string">@&quot;元&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numFen == <span class="number">0</span> &amp;&amp; numJiao == <span class="number">0</span>) &#123;</span><br><span class="line">        chineseStr = [chineseStr stringByAppendingString:<span class="string">@&quot;整&quot;</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numFen == <span class="number">0</span>) &#123; <span class="comment">// 0 分，角数不为 0</span></span><br><span class="line">        chineseStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@%@%@&quot;</span>, chineseStr, chineseDigits[numJiao], <span class="string">@&quot;角&quot;</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// “分”数不为 0</span></span><br><span class="line">        <span class="keyword">if</span> (numJiao == <span class="number">0</span>) &#123;</span><br><span class="line">            chineseStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@%@%@%@&quot;</span>, chineseStr, <span class="string">@&quot;零&quot;</span>, chineseDigits[numFen], <span class="string">@&quot;分&quot;</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chineseStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@%@%@%@%@&quot;</span>, chineseStr, chineseDigits[numJiao], <span class="string">@&quot;角&quot;</span>, chineseDigits[numFen], <span class="string">@&quot;分&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> chineseStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)partTranslate:(<span class="type">int</span>)amountPart &#123;</span><br><span class="line">    <span class="keyword">if</span> (amountPart &lt; <span class="number">0</span> || amountPart &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(<span class="literal">YES</span>, <span class="string">@&quot;参数必须是大于等于 0，小于 10000 的整数！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *units = @[<span class="string">@&quot;&quot;</span>, <span class="string">@&quot;拾&quot;</span>, <span class="string">@&quot;佰&quot;</span>, <span class="string">@&quot;仟&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> temp = amountPart;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *amountStr = [@(amountPart) stringValue];</span><br><span class="line">    <span class="type">int</span> amountStrLength = (<span class="type">int</span>)amountStr.length;</span><br><span class="line">    <span class="type">bool</span> lastIsZero = <span class="literal">true</span>; <span class="comment">//在从低位往高位循环时，记录上一位数字是不是 0</span></span><br><span class="line">    <span class="built_in">NSString</span> *chineseStr = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; amountStrLength; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125; <span class="comment">// 高位已无数据</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> digit = temp % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (digit == <span class="number">0</span>) &#123; <span class="comment">// 取到的数字为 0</span></span><br><span class="line">            <span class="keyword">if</span> (!lastIsZero) &#123; <span class="comment">//前一个数字不是 0，则在当前汉字串前加“零”字;</span></span><br><span class="line">                chineseStr = [<span class="string">@&quot;零&quot;</span> stringByAppendingString:chineseStr];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lastIsZero = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 取到的数字不是 0</span></span><br><span class="line">            chineseStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@%@%@&quot;</span>, chineseDigits[digit], units[i], chineseStr];</span><br><span class="line">            lastIsZero = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        temp = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> chineseStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x02-其他"><a href="#0x02-其他" class="headerlink" title="0x02 其他"></a>0x02 其他</h1><ul>
<li>火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换</li>
</ul>
<p>算法代码如下，其中 bd_encrypt 将 GCJ-02 坐标转换成 BD-09 坐标，bd_decrypt 反之。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> x_pi = <span class="number">3.14159265358979324</span> * <span class="number">3000.0</span> / <span class="number">180.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bd_encrypt</span><span class="params">(<span class="type">double</span> gg_lat, <span class="type">double</span> gg_lon, <span class="type">double</span> &amp;bd_lat, <span class="type">double</span> &amp;bd_lon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x = gg_lon, y = gg_lat;</span><br><span class="line">    <span class="type">double</span> z = <span class="built_in">sqrt</span>(x * x + y * y) + <span class="number">0.00002</span> * <span class="built_in">sin</span>(y * x_pi);</span><br><span class="line">    <span class="type">double</span> theta = <span class="built_in">atan2</span>(y, x) + <span class="number">0.000003</span> * <span class="built_in">cos</span>(x * x_pi);</span><br><span class="line">    bd_lon = z * <span class="built_in">cos</span>(theta) + <span class="number">0.0065</span>;</span><br><span class="line">    bd_lat = z * <span class="built_in">sin</span>(theta) + <span class="number">0.006</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bd_decrypt</span><span class="params">(<span class="type">double</span> bd_lat, <span class="type">double</span> bd_lon, <span class="type">double</span> &amp;gg_lat, <span class="type">double</span> &amp;gg_lon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x = bd_lon - <span class="number">0.0065</span>, y = bd_lat - <span class="number">0.006</span>;</span><br><span class="line">    <span class="type">double</span> z = <span class="built_in">sqrt</span>(x * x + y * y) - <span class="number">0.00002</span> * <span class="built_in">sin</span>(y * x_pi);</span><br><span class="line">    <span class="type">double</span> theta = <span class="built_in">atan2</span>(y, x) - <span class="number">0.000003</span> * <span class="built_in">cos</span>(x * x_pi);</span><br><span class="line">    gg_lon = z * <span class="built_in">cos</span>(theta);</span><br><span class="line">    gg_lat = z * <span class="built_in">sin</span>(theta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/coolypf/article/details/8569813">原博客地址</a><br>这篇博文是通过 SegmentFault 上的 <a href="https://segmentfault.com/a/1190000000498434">这篇文章</a> 找到的。</p>
<ul>
<li>日期转换格式<br>iOS NSDateFormatter 格式说明：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">G: 公元时代，例如AD公元</span><br><span class="line">yy: 年的后2位</span><br><span class="line">yyyy: 完整年</span><br><span class="line">MM: 月，显示为1-12</span><br><span class="line">MMM: 月，显示为英文月份简写,如 Jan</span><br><span class="line">MMMM: 月，显示为英文月份全称，如 Janualy</span><br><span class="line">dd: 日，2位数表示，如02</span><br><span class="line">d: 日，1-2位显示，如 2</span><br><span class="line">EEE: 简写星期几，如Sun</span><br><span class="line">EEEE: 全写星期几，如Sunday</span><br><span class="line">aa: 上下午，AM/PM</span><br><span class="line">H: 时，24小时制，0-23</span><br><span class="line">K：时，12小时制，0-11</span><br><span class="line">m: 分，1-2位</span><br><span class="line">mm: 分，2位</span><br><span class="line">s: 秒，1-2位</span><br><span class="line">ss: 秒，2位</span><br><span class="line">S: 毫秒</span><br><span class="line">Z：GMT</span><br></pre></td></tr></table></figure>

<p>常用的时间格式有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yyyy-MM-dd HH:mm:ss.SSS</span><br><span class="line">yyyy-MM-dd HH:mm:ss</span><br><span class="line">yyyy-MM-dd</span><br><span class="line">MM dd yyyy</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/crayondeng/article/details/8755306">原博客地址</a></p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>坐标</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Hosting 在 GitHub Pages 的 Hexo 博客开启 HTTPS</title>
    <url>/2019/01/12/hexo-enabled-https-on-github-pages/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>2018 年 5 月 1 日 GitHub 官网宣布了 <a href="https://blog.github.com/2018-05-01-github-pages-custom-domains-https/">GitHub Pages 自定义域名增加对 HTTPS 的支持</a>，不过我那时候在做自己的个人项目，就懒得去更新了，一直拖到现在，也算是懒癌发作了。</p>
<p>首先说明一下，我的域名（meilbn.com）是在 <a href="https://www.godaddy.com/">Godaddy</a> 买的，不过域名解析使用的是腾讯云的 <a href="https://www.dnspod.cn/">DNSPod</a>，如何配置什么的我就不讲了，可以在网上找到很多资料，我这里就只讲一下如何开启 HTTPS，非常简单，不过我也遇到了一个“坑”。</p>
<span id="more"></span>

<h1 id="0x01-一步到位"><a href="#0x01-一步到位" class="headerlink" title="0x01 一步到位"></a>0x01 一步到位</h1><p>首先，假设你设置的 DNS 解析地址是正确的，你可以直接在你的 GitHub 上的博客项目仓库的设置中直接开启 HTTPS：</p>
<ul>
<li>进入仓库的设置：</li>
</ul>
<p><img src="https://i.loli.net/2019/01/12/5c39fadea6a9e.png"></p>
<ul>
<li>勾选 Enforce HTTPS (可能你网页拉下来的时候并没有，需要一点时间才会显示出来)</li>
</ul>
<p><img src="https://i.loli.net/2019/01/12/5c39faefdd98f.jpg"></p>
<p>如果你这里并不像截图中的这样，没有黄色的警告，并且勾选框也是可以勾选的（我这里并不能勾选），那么你就直接勾选上，然后可能需要等一会，你打开你的博客（或者刷新），那么，你的博客就已经是 HTTPS 开头的了，你也不需要继续往下看了。</p>
<p>But,</p>
<p>要是你这里跟我一样，那么，请继续耐心地往下看。</p>
<h1 id="0x02-更新-DNS-记录"><a href="#0x02-更新-DNS-记录" class="headerlink" title="0x02 更新 DNS 记录"></a>0x02 更新 DNS 记录</h1><p>因为以前用的是 HTTP，所以在 <a href="https://www.dnspod.cn/">DNSPod</a> 里的 <code>A</code> 记录的地址填的是 <code>192.30.252.153</code> 或者 <code>192.30.252.154</code>，这是没有任何问题的，但是现在要换成 HTTPS，就不能继续用这个 IP 地址了（具体可以查看<a href="https://help.github.com/articles/troubleshooting-custom-domains/#dns-configuration-errors">这里</a>的绿色 <code>Notes</code>）。</p>
<p>接下来开始讲我遇到的这个“坑”。</p>
<h1 id="0x03-自填自坑"><a href="#0x03-自填自坑" class="headerlink" title="0x03 自填自坑"></a>0x03 自填自坑</h1><p>因为我使用的是 <a href="https://www.dnspod.cn/">DNSPod</a>，并不能添加 <code>ALIAS</code> 或 <code>ANAME</code> 记录，只能用 <code>A</code> 记录，所以根据官网的<a href="https://help.github.com/articles/setting-up-an-apex-domain/#configuring-an-alias-or-aname-record-with-your-dns-provider">文档</a>，添加 <code>A</code> 记录的 IP 地址，有如下 4 条：</p>
<ul>
<li>185.199.108.153</li>
<li>185.199.109.153</li>
<li>185.199.110.153</li>
<li>185.199.111.153</li>
</ul>
<p>我以为是 4 条都要添加，结果 <a href="https://www.dnspod.cn/">DNSPod</a> 里免费的账户只能添加 2 条 <code>A</code> 记录：</p>
<p><img src="https://i.loli.net/2019/01/12/5c39fb0207b26.png"></p>
<p>然后我看了一下升级套餐：</p>
<p><img src="https://i.loli.net/2019/01/12/5c39fb0d8428c.png"></p>
<p>发现好贵，遂作罢，想换其他的 DNS 解析服务商。注册了 <a href="https://www.namecheap.com/">NameCheap</a>，发现好像不是 <a href="https://www.namecheap.com/">NameCheap</a> 上买的域名不能使用 DNS 解析服务（或者是我没找到）。</p>
<p>然后回过头来，重新看了下博客仓库的设置界面（刷新），发现警告没有了：</p>
<p><img src="https://i.loli.net/2019/01/12/5c39fb27c1342.png"></p>
<p>一看下面的勾选框也可以勾选了：</p>
<p><img src="https://i.loli.net/2019/01/12/5c39fb1aa1272.png"></p>
<p><strong>原来不需要 4 条记录全部加上</strong>，我只加了两条：</p>
<p><img src="https://i.loli.net/2019/01/12/5c39fb31cee30.png"></p>
<p>可能一条也可以吧，不过我没去试。</p>
<p>勾选了之后：</p>
<p><img src="https://i.loli.net/2019/01/12/5c39fb4c5e564.png"></p>
<p>博客原来的地址栏是 HTTP 的：</p>
<p><img src="https://i.loli.net/2019/01/12/5c39fb56b27c3.png"></p>
<p>现在刷新一下就是 HTTPS 的了：</p>
<p><img src="https://i.loli.net/2019/01/12/5c39fb60e88a1.png"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode Debug 技巧之一</title>
    <url>/2015/07/06/iOS-Xcode-Debug-Skills-0x00/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这个技巧是在新浪微博上看到的，源地址为<a href="https://weibo.com/1745945040/CpBv73dSR?type=comment#_rnd1436172574844">戴铭的这条微博</a>，不过看评论有说不懂的，其实第一次看这个微博，看了这些图，我也没怎么在意，完全是因为 App 崩溃后 Xcode 经常是定位到 App 的起始方法里面，让人有点抓狂，如果项目是用 OC 写的，那么可能是如下这个情况：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab871dd6a5.png"></p>
<p>Swift 就是微博配图里面的那样：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab8722b40d.jpg"></p>
<p>看完这个微博之后，我并没有转发，但是呢，就在当天下午，项目经理让我改一个 Bug，然后我重现这个 Bug 之后，发现定位到的代码就是上面 OC 版本的那样子，以前也经常遇到，然后我就跟平时一样，查看 Console 中的 Log，打算从 Log 上下手，当我看到 Log 我就又懵逼了，还是跟以前一样，这个 Log 并没有什么卵用：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab8722a662.png"></p>
<p>就告诉了我原因是数组越界，然而项目大了，界面复杂一点了，我怎么知道是哪个数组越界了，这样找起来不是非常浪费时间吗？然后我就想起来，之前看到的那条微博，然后我马上去微博上找了，因为我还记得是大神叶孤城___转发的，然后我就找到了，然后看了下，跟着配图操作了一下，哇擦类，竟然成功了！然后我就打算写一篇文章，记录在自己的博客上面，所以就有了这篇文章。好了，废话说了这么多，开始一步步操作吧。</p>
<h1 id="0x01-操作步骤"><a href="#0x01-操作步骤" class="headerlink" title="0x01 操作步骤"></a>0x01 操作步骤</h1><p>首先，当出现这中崩溃，Xcode 是直接帮我们打开了 Debug navigator 界面，就是上面 OC 版本的那样子，然后我们点击标识为 0 的进程：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab87229a5e.png"></p>
<p>然后在 Console 中输入如下命令，然后回车：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab8717b83b.png"></p>
<p>接着，我们切换到 Breakpoint navigator：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab8717ba07.png"></p>
<p>点击最下面的“+”号，选择 Add Exception Breakpoint：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab8721f7eb.png"></p>
<p>然后右键选择 Edit Breakpoint…：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab8722087b.png"></p>
<p>接着点击 Add Action：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab87229681.png"></p>
<p>然后输入刚刚的命令：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab8722a4ba.png"></p>
<p>最后，重新运行，然后重复之前的操作，将 Bug 重现一下，就会定位到导致 App 崩溃的那一行代码了：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab98cbd9b2.png"></p>
<p>下面是 Console 的 Log：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdab98c90bd1.png"></p>
<p>就是这么简单啦！</p>
<h1 id="0x02-更新"><a href="#0x02-更新" class="headerlink" title="0x02 更新"></a>0x02 更新</h1><p>2015.12.04 更新</p>
<p>按照上面一步步设置之后，在当前项目是可以的，不过在新项目当中就不能用了，还要再手动设置一次，很麻烦，再做如下这步，就可以在全部的项目当中使用了，不用每一个新项目都设置一遍：<br><img src="https://i.loli.net/2018/11/01/5bdab98cbe164.png"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode 运行 iOS 项目到模拟器/真机一直卡在启动页（Launch Screen）</title>
    <url>/2022/09/20/iOS-app-get-stuck-on-launch-screen/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>很久之前，Xcode 12 还是 13，项目运行起来，有时候是真机，有时候是模拟器，一直卡在 App 的启动页，也就是 Launch Screen，稍微低一点的版本倒还好，那时候 iOS 15 就会卡住，低的就不会， <em><strong>而且只在 Xcode 项目运行时会，结束 Xcode 项目的运行，再直接运行 App 是不会卡住的</strong></em> ，网上找过一些办法，但是都没啥卵用，后面就不了了之。</p>
<p>最近，更新了 MacOS Monterey（没错，2022年9月份，我才更新的），Xcode 也更新到了 14，iOS 16 也出来了，运行之前的项目到 iOS 16 的模拟器（14 Pro Max），还是一直卡在启动页，实在忍受不了，就继续上网找解决办法。</p>
<span id="more"></span>

<p>最普遍的方法，就是删除 Derived Data，目录为 <code>/Users/yourname/Library/Developer/Xcode/DerivedData</code>，然后重启 Xcode，试过好几遍，没啥用，该卡还是卡，甚至有一次，看到一个办法是删除 <code>/Users/yourname/Library/Developer/Xcode/</code> 下的所有内容，我也没太多想，删除，加上清除了回收站，结果芭比Q了，很多 Xcode 的配置、Code Snippet 等，都是在这个目录下，还好我之前有 Time Machine 备份，有些东西都复制回来了。</p>
<h2 id="0x01-原因"><a href="#0x01-原因" class="headerlink" title="0x01 原因"></a>0x01 原因</h2><p>这篇文章我只记录下我自己遇到的情况及解决办法，不一定和你一样，仅当参考。</p>
<p>在网上找解决办法的时候，看到一个人说的一句话，让我有点茅塞顿开，是不是断点的问题。当我把 Xcode 里面的所有断点关闭之后，再运行项目到模拟器，发现很快就进入首页了，不会卡在启动页，此时非常开心，因为找到问题所在了。</p>
<p>接下来就是试着开启一个个断点，看看是开启了哪一个断点之后，会卡在启动页，经过测试，发现问题断点：</p>
<p><img src="https://s1.ax1x.com/2022/11/24/zJR1OO.png" alt="Untitled"></p>
<p>这是 Reveal 调试的断点，根据 Reveal 官方的<a href="%5Bhttps://support.revealapp.com/hc/en-us/articles/360022477972-Load-Reveal-Server-via-an-Xcode-Breakpoint%5D(https://support.revealapp.com/hc/en-us/articles/360022477972-Load-Reveal-Server-via-an-Xcode-Breakpoint)">这篇文档</a>添加的，已经很久了，然后我就去 Reveal 官网找，看到了一篇文档：<a href="%5Bhttps://support.revealapp.com/hc/en-us/articles/4403215920793-My-app-is-hanging-on-launch-under-Xcode-13-and-iOS-tvOS-15%5D(https://support.revealapp.com/hc/en-us/articles/4403215920793-My-app-is-hanging-on-launch-under-Xcode-13-and-iOS-tvOS-15)">My app is hanging on launch under Xcode 13 and iOS&#x2F;tvOS 15</a>，原来 Reveal 官方自己就有收到反馈，那就好办了。</p>
<h2 id="0x02-解决"><a href="#0x02-解决" class="headerlink" title="0x02 解决"></a>0x02 解决</h2><p>根据上面的 Reveal 的文档，将断点改为：</p>
<p><img src="https://s1.ax1x.com/2022/11/24/zJRtkd.png" alt="Untitled"></p>
<p>然后再重新运行项目，完美，顺利进入，不会卡在启动页了。</p>
<p>PS：Reveal 官方文档里面说，要更新 Reveal 到 30及以后，但是我的 Reveal 还是 26 的，本来想想可以更新下，不过我买的 Plan 已经过期很久了，所以一直没有更新，但是我还是试了试，发现并不用 30+，所以就没有重新购买新版本的 Reveal。</p>
<p>既然问题解决了，升级新版本 Reveal 的钱也可以暂时先省下来了。😄</p>
<p>完~</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
        <tag>Reveal</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 读取 txt 文本文件中文乱码的解决办法</title>
    <url>/2019/10/19/iOS-read-txt-file-mojibake-solution/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/10/19/SOJrYMaUZDlTnH1.png" alt="Screenshot 2019-10-19 at 22.57.47.png"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在做公司的一个外包项目，是一个小说阅读 App，但是不仅是文本小说的阅读，还有有声小说，学习，ASMR 安眠等功能，这篇文章主要是说读取 txt 文本小说乱码的解决办法。</p>
<span id="more"></span>

<p><a href="#jump">太长不看，直接看解决办法</a></p>
<h1 id="0x01-遇到的情况"><a href="#0x01-遇到的情况" class="headerlink" title="0x01 遇到的情况"></a>0x01 遇到的情况</h1><p>Windows 上，txt 文件的编码一般是 GBK，但是 macOS 上一般是 UTF-8 的编码，所以在 iOS 上，直接用 UTF-8 编码去获取 txt 文件内容，会读取不到想要的数据：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSString</span> *content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;UTF-8, error = %@&quot;</span>, error);</span><br></pre></td></tr></table></figure>

<p>既然 UTF-8 编码不行，那么我们就换对应的编码去读取：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决中文乱码</span></span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="number">0x80000632</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GBK 632, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="number">0x80000631</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GBK 631, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，GBK 编码的“一般”也都能正确读取了，为什么说是一般呢？还打引号呢？因为在某些情况下，上面两种方式并不能正确读取 GBK 编码的 txt 文件的内容，即使你在 Mac 上使用 VS Code 等类似的编辑器，使用 GBK 编码能够正确显示。</p>
<p>读取不了的情况遇到过两种，先说第一种。</p>
<h1 id="0x02-第一种读取失败"><a href="#0x02-第一种读取失败" class="headerlink" title="0x02 第一种读取失败"></a>0x02 第一种读取失败</h1><p>先说 GBK，因为这个花了我一些时间去解决。</p>
<p>明明 Mac 上用 GBK 编码能够正确显示 txt 文件，服务端用 GBK 编码也能正确解析 txt 小说的章节，一到 iOS 上就不行了。</p>
<p>原因是可能编码比较特殊，遇到这个问题，首先试过系统提供的很多其他编码方式：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> enc = <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(kCFStringEncodingGB_2312_80);</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:enc error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GB 2312, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> enc = <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(kCFStringEncodingHZ_GB_2312);</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:enc error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;HZ GB 2312, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> enc = <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(kCFStringEncodingGB_18030_2000);</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:enc error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GB 18030, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都不行，遂去 Google，不过发现基本上都是类似的，抄来抄去，没什么卵用：</p>
<p><img src="https://i.loli.net/2019/10/19/Me8i1AwJ9StumZ2.png" alt="Screenshot 2019-10-18 at 16.55.06.png"></p>
<p>也试过英文搜索，但是也没有找到能够解决的办法。</p>
<p>既然这些解决不了，只能靠自己了。</p>
<p>想到既然系统提供了这么多的编码，会不会有一种能够解析呢？然后跑去看编码的头文件：<code>CFStringEncodingExt.h</code>，内容主要如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_ENUM</span>(<span class="built_in">CFIndex</span>, <span class="built_in">CFStringEncodings</span>) &#123;</span><br><span class="line"><span class="comment">/*  kCFStringEncodingMacRoman = 0L, defined in CoreFoundation/CFString.h */</span></span><br><span class="line">    kCFStringEncodingMacJapanese = <span class="number">1</span>,</span><br><span class="line">    kCFStringEncodingMacChineseTrad = <span class="number">2</span>,</span><br><span class="line">    kCFStringEncodingMacKorean = <span class="number">3</span>,</span><br><span class="line">    kCFStringEncodingMacArabic = <span class="number">4</span>,</span><br><span class="line">    kCFStringEncodingMacHebrew = <span class="number">5</span>,</span><br><span class="line">    kCFStringEncodingMacGreek = <span class="number">6</span>,</span><br><span class="line">    kCFStringEncodingMacCyrillic = <span class="number">7</span>,</span><br><span class="line">    kCFStringEncodingMacDevanagari = <span class="number">9</span>,</span><br><span class="line">    kCFStringEncodingMacGurmukhi = <span class="number">10</span>,</span><br><span class="line">    kCFStringEncodingMacGujarati = <span class="number">11</span>,</span><br><span class="line">    kCFStringEncodingMacOriya = <span class="number">12</span>,</span><br><span class="line">    kCFStringEncodingMacBengali = <span class="number">13</span>,</span><br><span class="line">    kCFStringEncodingMacTamil = <span class="number">14</span>,</span><br><span class="line">    kCFStringEncodingMacTelugu = <span class="number">15</span>,</span><br><span class="line">    kCFStringEncodingMacKannada = <span class="number">16</span>,</span><br><span class="line">    kCFStringEncodingMacMalayalam = <span class="number">17</span>,</span><br><span class="line">    kCFStringEncodingMacSinhalese = <span class="number">18</span>,</span><br><span class="line">    kCFStringEncodingMacBurmese = <span class="number">19</span>,</span><br><span class="line">    kCFStringEncodingMacKhmer = <span class="number">20</span>,</span><br><span class="line">    kCFStringEncodingMacThai = <span class="number">21</span>,</span><br><span class="line">    kCFStringEncodingMacLaotian = <span class="number">22</span>,</span><br><span class="line">    kCFStringEncodingMacGeorgian = <span class="number">23</span>,</span><br><span class="line">    kCFStringEncodingMacArmenian = <span class="number">24</span>,</span><br><span class="line">    kCFStringEncodingMacChineseSimp = <span class="number">25</span>,</span><br><span class="line">    kCFStringEncodingMacTibetan = <span class="number">26</span>,</span><br><span class="line">    kCFStringEncodingMacMongolian = <span class="number">27</span>,</span><br><span class="line">    kCFStringEncodingMacEthiopic = <span class="number">28</span>,</span><br><span class="line">    kCFStringEncodingMacCentralEurRoman = <span class="number">29</span>,</span><br><span class="line">    kCFStringEncodingMacVietnamese = <span class="number">30</span>,</span><br><span class="line">    kCFStringEncodingMacExtArabic = <span class="number">31</span>,</span><br><span class="line">    <span class="comment">/* The following use script code 0, smRoman */</span></span><br><span class="line">    kCFStringEncodingMacSymbol = <span class="number">33</span>,</span><br><span class="line">    kCFStringEncodingMacDingbats = <span class="number">34</span>,</span><br><span class="line">    kCFStringEncodingMacTurkish = <span class="number">35</span>,</span><br><span class="line">    kCFStringEncodingMacCroatian = <span class="number">36</span>,</span><br><span class="line">    kCFStringEncodingMacIcelandic = <span class="number">37</span>,</span><br><span class="line">    kCFStringEncodingMacRomanian = <span class="number">38</span>,</span><br><span class="line">    kCFStringEncodingMacCeltic = <span class="number">39</span>,</span><br><span class="line">    kCFStringEncodingMacGaelic = <span class="number">40</span>,</span><br><span class="line">    <span class="comment">/* The following use script code 4, smArabic */</span></span><br><span class="line">    kCFStringEncodingMacFarsi = <span class="number">0x8C</span>,	<span class="comment">/* Like MacArabic but uses Farsi digits */</span></span><br><span class="line">    <span class="comment">/* The following use script code 7, smCyrillic */</span></span><br><span class="line">    kCFStringEncodingMacUkrainian = <span class="number">0x98</span>,</span><br><span class="line">    <span class="comment">/* The following use script code 32, smUnimplemented */</span></span><br><span class="line">    kCFStringEncodingMacInuit = <span class="number">0xEC</span>,</span><br><span class="line">    kCFStringEncodingMacVT100 = <span class="number">0xFC</span>,	<span class="comment">/* VT100/102 font from Comm Toolbox: Latin-1 repertoire + box drawing etc */</span></span><br><span class="line">    <span class="comment">/* Special Mac OS encodings*/</span></span><br><span class="line">    kCFStringEncodingMacHFS = <span class="number">0xFF</span>,	<span class="comment">/* Meta-value, should never appear in a table */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unicode &amp; ISO UCS encodings begin at 0x100 */</span></span><br><span class="line">    <span class="comment">/* We don&#x27;t use Unicode variations defined in TextEncoding; use the ones in CFString.h, instead. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ISO 8-bit and 7-bit encodings begin at 0x200 */</span></span><br><span class="line"><span class="comment">/*  kCFStringEncodingISOLatin1 = 0x0201, defined in CoreFoundation/CFString.h */</span></span><br><span class="line">    kCFStringEncodingISOLatin2 = <span class="number">0x0202</span>,	<span class="comment">/* ISO 8859-2 */</span></span><br><span class="line">    kCFStringEncodingISOLatin3 = <span class="number">0x0203</span>,	<span class="comment">/* ISO 8859-3 */</span></span><br><span class="line">    kCFStringEncodingISOLatin4 = <span class="number">0x0204</span>,	<span class="comment">/* ISO 8859-4 */</span></span><br><span class="line">    kCFStringEncodingISOLatinCyrillic = <span class="number">0x0205</span>,	<span class="comment">/* ISO 8859-5 */</span></span><br><span class="line">    kCFStringEncodingISOLatinArabic = <span class="number">0x0206</span>,	<span class="comment">/* ISO 8859-6, =ASMO 708, =DOS CP 708 */</span></span><br><span class="line">    kCFStringEncodingISOLatinGreek = <span class="number">0x0207</span>,	<span class="comment">/* ISO 8859-7 */</span></span><br><span class="line">    kCFStringEncodingISOLatinHebrew = <span class="number">0x0208</span>,	<span class="comment">/* ISO 8859-8 */</span></span><br><span class="line">    kCFStringEncodingISOLatin5 = <span class="number">0x0209</span>,	<span class="comment">/* ISO 8859-9 */</span></span><br><span class="line">    kCFStringEncodingISOLatin6 = <span class="number">0x020A</span>,	<span class="comment">/* ISO 8859-10 */</span></span><br><span class="line">    kCFStringEncodingISOLatinThai = <span class="number">0x020B</span>,	<span class="comment">/* ISO 8859-11 */</span></span><br><span class="line">    kCFStringEncodingISOLatin7 = <span class="number">0x020D</span>,	<span class="comment">/* ISO 8859-13 */</span></span><br><span class="line">    kCFStringEncodingISOLatin8 = <span class="number">0x020E</span>,	<span class="comment">/* ISO 8859-14 */</span></span><br><span class="line">    kCFStringEncodingISOLatin9 = <span class="number">0x020F</span>,	<span class="comment">/* ISO 8859-15 */</span></span><br><span class="line">    kCFStringEncodingISOLatin10 = <span class="number">0x0210</span>,	<span class="comment">/* ISO 8859-16 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MS-DOS &amp; Windows encodings begin at 0x400 */</span></span><br><span class="line">    kCFStringEncodingDOSLatinUS = <span class="number">0x0400</span>,	<span class="comment">/* code page 437 */</span></span><br><span class="line">    kCFStringEncodingDOSGreek = <span class="number">0x0405</span>,		<span class="comment">/* code page 737 (formerly code page 437G) */</span></span><br><span class="line">    kCFStringEncodingDOSBalticRim = <span class="number">0x0406</span>,	<span class="comment">/* code page 775 */</span></span><br><span class="line">    kCFStringEncodingDOSLatin1 = <span class="number">0x0410</span>,	<span class="comment">/* code page 850, &quot;Multilingual&quot; */</span></span><br><span class="line">    kCFStringEncodingDOSGreek1 = <span class="number">0x0411</span>,	<span class="comment">/* code page 851 */</span></span><br><span class="line">    kCFStringEncodingDOSLatin2 = <span class="number">0x0412</span>,	<span class="comment">/* code page 852, Slavic */</span></span><br><span class="line">    kCFStringEncodingDOSCyrillic = <span class="number">0x0413</span>,	<span class="comment">/* code page 855, IBM Cyrillic */</span></span><br><span class="line">    kCFStringEncodingDOSTurkish = <span class="number">0x0414</span>,	<span class="comment">/* code page 857, IBM Turkish */</span></span><br><span class="line">    kCFStringEncodingDOSPortuguese = <span class="number">0x0415</span>,	<span class="comment">/* code page 860 */</span></span><br><span class="line">    kCFStringEncodingDOSIcelandic = <span class="number">0x0416</span>,	<span class="comment">/* code page 861 */</span></span><br><span class="line">    kCFStringEncodingDOSHebrew = <span class="number">0x0417</span>,	<span class="comment">/* code page 862 */</span></span><br><span class="line">    kCFStringEncodingDOSCanadianFrench = <span class="number">0x0418</span>, <span class="comment">/* code page 863 */</span></span><br><span class="line">    kCFStringEncodingDOSArabic = <span class="number">0x0419</span>,	<span class="comment">/* code page 864 */</span></span><br><span class="line">    kCFStringEncodingDOSNordic = <span class="number">0x041A</span>,	<span class="comment">/* code page 865 */</span></span><br><span class="line">    kCFStringEncodingDOSRussian = <span class="number">0x041B</span>,	<span class="comment">/* code page 866 */</span></span><br><span class="line">    kCFStringEncodingDOSGreek2 = <span class="number">0x041C</span>,	<span class="comment">/* code page 869, IBM Modern Greek */</span></span><br><span class="line">    kCFStringEncodingDOSThai = <span class="number">0x041D</span>,		<span class="comment">/* code page 874, also for Windows */</span></span><br><span class="line">    kCFStringEncodingDOSJapanese = <span class="number">0x0420</span>,	<span class="comment">/* code page 932, also for Windows */</span></span><br><span class="line">    kCFStringEncodingDOSChineseSimplif = <span class="number">0x0421</span>, <span class="comment">/* code page 936, also for Windows */</span></span><br><span class="line">    kCFStringEncodingDOSKorean = <span class="number">0x0422</span>,	<span class="comment">/* code page 949, also for Windows; Unified Hangul Code */</span></span><br><span class="line">    kCFStringEncodingDOSChineseTrad = <span class="number">0x0423</span>,	<span class="comment">/* code page 950, also for Windows */</span></span><br><span class="line"><span class="comment">/*  kCFStringEncodingWindowsLatin1 = 0x0500, defined in CoreFoundation/CFString.h */</span></span><br><span class="line">    kCFStringEncodingWindowsLatin2 = <span class="number">0x0501</span>,	<span class="comment">/* code page 1250, Central Europe */</span></span><br><span class="line">    kCFStringEncodingWindowsCyrillic = <span class="number">0x0502</span>,	<span class="comment">/* code page 1251, Slavic Cyrillic */</span></span><br><span class="line">    kCFStringEncodingWindowsGreek = <span class="number">0x0503</span>,	<span class="comment">/* code page 1253 */</span></span><br><span class="line">    kCFStringEncodingWindowsLatin5 = <span class="number">0x0504</span>,	<span class="comment">/* code page 1254, Turkish */</span></span><br><span class="line">    kCFStringEncodingWindowsHebrew = <span class="number">0x0505</span>,	<span class="comment">/* code page 1255 */</span></span><br><span class="line">    kCFStringEncodingWindowsArabic = <span class="number">0x0506</span>,	<span class="comment">/* code page 1256 */</span></span><br><span class="line">    kCFStringEncodingWindowsBalticRim = <span class="number">0x0507</span>,	<span class="comment">/* code page 1257 */</span></span><br><span class="line">    kCFStringEncodingWindowsVietnamese = <span class="number">0x0508</span>, <span class="comment">/* code page 1258 */</span></span><br><span class="line">    kCFStringEncodingWindowsKoreanJohab = <span class="number">0x0510</span>, <span class="comment">/* code page 1361, for Windows NT */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Various national standards begin at 0x600 */</span></span><br><span class="line"><span class="comment">/*  kCFStringEncodingASCII = 0x0600, defined in CoreFoundation/CFString.h */</span></span><br><span class="line">    kCFStringEncodingANSEL = <span class="number">0x0601</span>,	<span class="comment">/* ANSEL (ANSI Z39.47) */</span></span><br><span class="line">    kCFStringEncodingJIS_X0201_76 = <span class="number">0x0620</span>,</span><br><span class="line">    kCFStringEncodingJIS_X0208_83 = <span class="number">0x0621</span>,</span><br><span class="line">    kCFStringEncodingJIS_X0208_90 = <span class="number">0x0622</span>,</span><br><span class="line">    kCFStringEncodingJIS_X0212_90 = <span class="number">0x0623</span>,</span><br><span class="line">    kCFStringEncodingJIS_C6226_78 = <span class="number">0x0624</span>,</span><br><span class="line">    kCFStringEncodingShiftJIS_X0213 API_AVAILABLE(macos(<span class="number">10.5</span>), ios(<span class="number">2.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)) = <span class="number">0x0628</span>, <span class="comment">/* Shift-JIS format encoding of JIS X0213 planes 1 and 2*/</span></span><br><span class="line">    kCFStringEncodingShiftJIS_X0213_MenKuTen = <span class="number">0x0629</span>,	<span class="comment">/* JIS X0213 in plane-row-column notation */</span></span><br><span class="line">    kCFStringEncodingGB_2312_80 = <span class="number">0x0630</span>,</span><br><span class="line">    kCFStringEncodingGBK_95 = <span class="number">0x0631</span>,		<span class="comment">/* annex to GB 13000-93; for Windows 95 */</span></span><br><span class="line">    kCFStringEncodingGB_18030_2000 = <span class="number">0x0632</span>,</span><br><span class="line">    kCFStringEncodingKSC_5601_87 = <span class="number">0x0640</span>,	<span class="comment">/* same as KSC 5601-92 without Johab annex */</span></span><br><span class="line">    kCFStringEncodingKSC_5601_92_Johab = <span class="number">0x0641</span>, <span class="comment">/* KSC 5601-92 Johab annex */</span></span><br><span class="line">    kCFStringEncodingCNS_11643_92_P1 = <span class="number">0x0651</span>,	<span class="comment">/* CNS 11643-1992 plane 1 */</span></span><br><span class="line">    kCFStringEncodingCNS_11643_92_P2 = <span class="number">0x0652</span>,	<span class="comment">/* CNS 11643-1992 plane 2 */</span></span><br><span class="line">    kCFStringEncodingCNS_11643_92_P3 = <span class="number">0x0653</span>,	<span class="comment">/* CNS 11643-1992 plane 3 (was plane 14 in 1986 version) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ISO 2022 collections begin at 0x800 */</span></span><br><span class="line">    kCFStringEncodingISO_2022_JP = <span class="number">0x0820</span>,</span><br><span class="line">    kCFStringEncodingISO_2022_JP_2 = <span class="number">0x0821</span>,</span><br><span class="line">    kCFStringEncodingISO_2022_JP_1 = <span class="number">0x0822</span>, <span class="comment">/* RFC 2237*/</span></span><br><span class="line">    kCFStringEncodingISO_2022_JP_3 = <span class="number">0x0823</span>, <span class="comment">/* JIS X0213*/</span></span><br><span class="line">    kCFStringEncodingISO_2022_CN = <span class="number">0x0830</span>,</span><br><span class="line">    kCFStringEncodingISO_2022_CN_EXT = <span class="number">0x0831</span>,</span><br><span class="line">    kCFStringEncodingISO_2022_KR = <span class="number">0x0840</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EUC collections begin at 0x900 */</span></span><br><span class="line">    kCFStringEncodingEUC_JP = <span class="number">0x0920</span>,		<span class="comment">/* ISO 646, 1-byte katakana, JIS 208, JIS 212 */</span></span><br><span class="line">    kCFStringEncodingEUC_CN = <span class="number">0x0930</span>,		<span class="comment">/* ISO 646, GB 2312-80 */</span></span><br><span class="line">    kCFStringEncodingEUC_TW = <span class="number">0x0931</span>,		<span class="comment">/* ISO 646, CNS 11643-1992 Planes 1-16 */</span></span><br><span class="line">    kCFStringEncodingEUC_KR = <span class="number">0x0940</span>,		<span class="comment">/* ISO 646, KS C 5601-1987 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Misc standards begin at 0xA00 */</span></span><br><span class="line">    kCFStringEncodingShiftJIS = <span class="number">0x0A01</span>,		<span class="comment">/* plain Shift-JIS */</span></span><br><span class="line">    kCFStringEncodingKOI8_R = <span class="number">0x0A02</span>,		<span class="comment">/* Russian internet standard */</span></span><br><span class="line">    kCFStringEncodingBig5 = <span class="number">0x0A03</span>,		<span class="comment">/* Big-5 (has variants) */</span></span><br><span class="line">    kCFStringEncodingMacRomanLatin1 = <span class="number">0x0A04</span>,	<span class="comment">/* Mac OS Roman permuted to align with ISO Latin-1 */</span></span><br><span class="line">    kCFStringEncodingHZ_GB_2312 = <span class="number">0x0A05</span>,	<span class="comment">/* HZ (RFC 1842, for Chinese mail &amp; news) */</span></span><br><span class="line">    kCFStringEncodingBig5_HKSCS_1999 = <span class="number">0x0A06</span>, <span class="comment">/* Big-5 with Hong Kong special char set supplement*/</span></span><br><span class="line">    kCFStringEncodingVISCII = <span class="number">0x0A07</span>,	<span class="comment">/* RFC 1456, Vietnamese */</span></span><br><span class="line">    kCFStringEncodingKOI8_U = <span class="number">0x0A08</span>,	<span class="comment">/* RFC 2319, Ukrainian */</span></span><br><span class="line">    kCFStringEncodingBig5_E = <span class="number">0x0A09</span>,	<span class="comment">/* Taiwan Big-5E standard */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Other platform encodings*/</span></span><br><span class="line"><span class="comment">/*  kCFStringEncodingNextStepLatin = 0x0B01, defined in CoreFoundation/CFString.h */</span></span><br><span class="line">    kCFStringEncodingNextStepJapanese = <span class="number">0x0B02</span>,	<span class="comment">/* NextStep Japanese encoding */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EBCDIC &amp; IBM host encodings begin at 0xC00 */</span></span><br><span class="line">    kCFStringEncodingEBCDIC_US = <span class="number">0x0C01</span>,	<span class="comment">/* basic EBCDIC-US */</span></span><br><span class="line">    kCFStringEncodingEBCDIC_CP037 = <span class="number">0x0C02</span>,	<span class="comment">/* code page 037, extended EBCDIC (Latin-1 set) for US,Canada... */</span></span><br><span class="line"></span><br><span class="line">    kCFStringEncodingUTF7 API_AVAILABLE(macos(<span class="number">10.6</span>), ios(<span class="number">4.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)) = <span class="number">0x04000100</span>, <span class="comment">/* kTextEncodingUnicodeDefault + kUnicodeUTF7Format RFC2152 */</span></span><br><span class="line">    kCFStringEncodingUTF7_IMAP API_AVAILABLE(macos(<span class="number">10.6</span>), ios(<span class="number">4.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)) = <span class="number">0x0A10</span>, <span class="comment">/* UTF-7 (IMAP folder variant) RFC3501 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Deprecated constants */</span></span><br><span class="line">    kCFStringEncodingShiftJIS_X0213_00 = <span class="number">0x0628</span> <span class="comment">/* Shift-JIS format encoding of JIS X0213 planes 1 and 2 (DEPRECATED) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span id="jump"></span></p>
<p>我就一个个看下来，看到感觉可能可以用的，我就拿过来去试试，比如 <code>kCFStringEncodingMacChineseSimp</code>，但是发现还是不行，直到我试了下 <code>kCFStringEncodingDOSChineseSimplif</code>，竟然可以正确读取中文了，真是非常高兴：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> enc = <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(kCFStringEncodingDOSChineseSimplif);</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:enc error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;DOS Chinese Simplif, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x03-第二种读取失败"><a href="#0x03-第二种读取失败" class="headerlink" title="0x03 第二种读取失败"></a>0x03 第二种读取失败</h1><p>除了 GKB 编码读取某些 txt 文件时会出问题，UTF-8 编码也是一样。</p>
<p>txt 文件读取方法最好把编码写全一些，这个不行就用另一个试试，另一个不行再用另另一个。</p>
<p>遇到过 UTF-16 LE 编码的，所以索性把基本上用到的编码读取全给上了，下面是我用到的所有尝试读取的编码（不排除后期增加其他编码）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSString</span> *content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;UTF-8, error = %@&quot;</span>, error);</span><br><span class="line"><span class="comment">//解决中文乱码</span></span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="number">0x80000632</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GBK 632, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="number">0x80000631</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GBK 631, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> enc = <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(kCFStringEncodingGB_2312_80);</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:enc error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GB 2312, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> enc = <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(kCFStringEncodingHZ_GB_2312);</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:enc error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;HZ GB 2312, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> enc = <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(kCFStringEncodingMacChineseSimp);</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:enc error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Mac Chinese Simp, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> enc = <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(kCFStringEncodingDOSChineseSimplif);</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:enc error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;DOS Chinese Simplif, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> enc = <span class="built_in">CFStringConvertEncodingToNSStringEncoding</span>(kCFStringEncodingGB_18030_2000);</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:enc error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GB 18030, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF16StringEncoding</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;UTF-16, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF16LittleEndianStringEncoding</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;UTF-16-LE, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF16BigEndianStringEncoding</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;UTF-16-BE, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF32StringEncoding</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;UTF-32, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF32LittleEndianStringEncoding</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;UTF-32-LE, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!content) &#123;</span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    content = [<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF32BigEndianStringEncoding</span> error:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;UTF-32-BE, error = %@&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，基本上都可以正确读取 txt 文件了。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>txt</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 12.4 使用 unc0ver 越狱之后安装 Reveal2Loader</title>
    <url>/2019/08/23/install-reveal2loader-on-jailbreak-device-ios12/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/10/19/9h4jtFiJQcuGgdn.jpg" alt="Uncover Jailbreak"></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>昨天刷微博发现 iOS 12.4 也可以越狱了（虽然是所谓的不完美越狱，也就是重启设备之后会回到未越狱状态，需要重新越狱一次，不过也没事），就拿开发备用机 iPhone 6s 去试了。</p>
<p>越狱教程地址：<a href="https://github.com/pwn20wndstuff/Undecimus">GitHub</a>，要是过程不清楚的，可以看<a href="https://zhuanlan.zhihu.com/p/58097735">这个教程</a>。</p>
<span id="more"></span>

<h1 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h1><ol>
<li>已越狱手机（以下简称手机）</li>
<li>Mac 电脑（已安装了 <code>Reveal</code>）</li>
</ol>
<p>手机安装好 <code>OpenSSH</code>，就是用 unc0ver 越狱时，开启了 <code>(Re)Install OpenSSH</code> 选项，手机和电脑连接同一个 WiFi。</p>
<p>手机打开 Cydia 安装插件 <code>Reveal2Loader</code>，亲测支持 iOS 12.4（iOS 8 时，我的另一个越狱手机 iPhone 5s 安装的是 <code>RevealLoader</code>，一直没有升级系统，停留在 iOS 8）。</p>
<p>打开设置，找到 <code>Reveal</code>，进去随便打开一个 App 的开关，然后 Mac 打开 Reveal，可以看到 App 出现在界面上，点击选择，如果你 Mac 的 Reveal 版本比手机安装的插件里面的 <code>RevealServer</code> 的版本高，那么 Mac 上的 Reveal 会提示：</p>
<p><img src="https://i.loli.net/2019/08/23/JV5dhiD4pSIFNTG.png"></p>
<p><strong>The operation couldn’t be completed. The app is link against an older version of the Reveal library. You may need to update the Reveal library in your app.</strong></p>
<p>不要慌，下面来讲解决办法（嫌过程太长不想看的，请直接点击<a href="#jump">这里查看最终的解决办法</a>）。</p>
<h1 id="0x02-解决过程"><a href="#0x02-解决过程" class="headerlink" title="0x02 解决过程"></a>0x02 解决过程</h1><p>按照<a href="https://meilbn.com/2015/10/23/reveal-troubleshooting-0x00/">以往的经验</a>，只要更新一下 <code>RevealServer</code> 即可。</p>
<p>打开 Mac 终端（我用的 iTerm2），ssh 连接手机（ip 地址改成你自己手机的 ip）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh root@172.20.10.10</span><br></pre></td></tr></table></figure>

<p>初始密码为：<code>alpine</code>（建议修改默认密码）</p>
<p>以前用的插件是 <code>RevealLoader</code>，现在是 <code>Reveal2Loader</code>，不知道 <code>RevealServer</code> 的地址是否一样，那么就先来看看。</p>
<p>进入到 <code>/Library</code> 文件夹，发现并没有 <code>RHRevealLoader</code> 文件夹，看来两个插件不太一样。</p>
<p><img src="https://i.loli.net/2019/08/23/NEO8K5XBtmMqSZb.png"></p>
<p>在浏览 <a href="https://github.com/lanvsblue/LANRevealLoader">LANRevealLoader</a> 这个开源库时，最后的 <code>Install</code> 写着：</p>
<blockquote class="blockquote-center">
<p>从RevealServer.framework&#x2F;RevealServer获取RevealServer，并下载LANRevealLoader，解压后将LANRevealLoader.dylib、LANRevealLoader.plist、RevealServer放在已越狱iOS的&#x2F;Library&#x2F;MobileSubstrate&#x2F;DynamicLibraries目录下。</p>

</blockquote>

<p>看了下这个文件夹下面的文件，发现除了 <code>reveal2Loader.dylib</code> 和 <code>reveal2Loader.plist</code>，并没有 <code>RevealServer</code>：</p>
<p><img src="https://i.loli.net/2019/08/23/dwDMyb3GK4LJR8t.png"></p>
<p>既然如此，那么就试试看，把 Mac 上 Reveal 的 RevealServer 复制到这个文件夹下（新开一个终端窗口，不是在手机上运行这个命令）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp /Users/meilbn/Library/Application\ Support/Reveal/RevealServer/iOS/RevealServer.framework/RevealServer root@172.20.10.10:/Library/MobileSubstrate/DynamicLibraries</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/08/23/K7Ob3oxUWlrzMjd.png"></p>
<p><img src="https://i.loli.net/2019/08/23/ablYzs21gevZNAV.png"></p>
<p>然后重启手机（不建议，还要重新越狱）或者（respings，建议这个方式）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">killall SpringBoard</span><br></pre></td></tr></table></figure>

<p>手机会显示加载的菊花，完了之后杀掉原先打开的 App，重新打开，然后去 Mac 上的 Reveal 中查看下。</p>
<p>·<br>·<br>·</p>
<p>哈哈哈，还是一样，看不了。</p>
<p>没有关系，Google 搜索了下 <code>Reveal2Loader</code>，找到了 Cydia 的对应地址：<a href="http://cydia.saurik.com/package/com.zidaneno5.reveal2loader/">http://cydia.saurik.com/package/com.zidaneno5.reveal2loader/</a></p>
<p><img src="https://i.loli.net/2019/08/23/lj9kPisE6heZDRN.png"></p>
<p><img src="https://i.loli.net/2019/08/23/FzIWPc2it3mKCaU.png"></p>
<p>打开 GitHub 地址，花了一点时间，看了下一些文件的源码，发现了<a href="https://github.com/zidaneno5/Reveal2Loader/blob/master/reveal2Loader/Package/Library/Frameworks/RevealServer.framework/Scripts/copy_and_codesign_revealserver.sh">目标</a>，<code>RevealServer.framework</code> 是会被 copy 和 sign 到 FrameWorks 文件夹。</p>
<p>印象中，<code>/Library</code> 下面就有一个 <code>FrameWorks</code> 文件夹，然后就去看了下，<code>RevealServer.framework</code> 果然是在这个里面：</p>
<p><img src="https://i.loli.net/2019/08/23/PXWIbYOCakHGzF4.png"></p>
<h1 id="0x03-更新-RevealServer-framework"><a href="#0x03-更新-RevealServer-framework" class="headerlink" title="0x03 更新 RevealServer.framework "></a>0x03 更新 RevealServer.framework <span id="jump"></span></h1><p>既然已经知道了 <code>RevealServer.framework</code> 的位置，那么就像之前那样，更新一下就好了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp -r /Users/meilbn/Library/Application\ Support/Reveal/RevealServer/iOS/RevealServer.framework root@172.20.10.10:/Library/Frameworks</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/08/23/ND1ypU6dgJMvqo5.png"></p>
<p><strong>这样就大功告成啦！</strong></p>
]]></content>
      <categories>
        <category>越狱</category>
      </categories>
      <tags>
        <tag>Reveal</tag>
        <tag>越狱</tag>
        <tag>Reveal2Loader</tag>
        <tag>RevealLoader</tag>
        <tag>Cydia</tag>
      </tags>
  </entry>
  <entry>
    <title>Integrating Reveal：Static Linking</title>
    <url>/2015/08/01/integrating-reveal-static-linking/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Reveal 的使用（静态库链接）。</p>
<p>首先，这里是讲用 Xcode 和 Reveal 来查看自己的 App 的视图，如果你是想看第三方的 App 的界面，那么就不需要看下去了。</p>
<span id="more"></span>

<h1 id="0x01-Xcode-查看-App-的视图"><a href="#0x01-Xcode-查看-App-的视图" class="headerlink" title="0x01 Xcode 查看 App 的视图"></a>0x01 Xcode 查看 App 的视图</h1><p>自从买了 Reveal，用着真的是非常爽呢，加上 iPhone 越狱了，那真是爽上加爽啊，高潮不断，哈哈。⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄</p>
<p>咳~</p>
<p>在日常的开发中，经常会有一些界面上的设计是平常用的 App 上看到过的，没办法，产品经理或者美工抄人家嘛，关键是抄的还不好，算了，这里不吐槽这个了。如果你有自己的想法，可以实现这个效果，那还是不错的，但是有时候，那个效果想不出来要怎么实现比较好，想看看别的 App 是怎么实现，怎么设计界面的，这个时候，Reveal 就派上了用场，</p>
<p>不过这里先不说这个情况，先说自己开发的 App，有时候一个界面的问题总是非常难搞，特别是手写控件的时候，不用 xib 或者 storyboard，那个该死的按钮死哪去了？那个图片怎么显示起来这样子的？如果你 Reveal 的试用到期了，或者没有使用 Reveal，没关系，还可以用 Xcode 来查看视图结构，没错，Xcode 自带有这个功能，不过是暂停了 App 的运行，进入了 Debug 模式，步骤如下：</p>
<ol>
<li>先运行你的 App 到手机或者模拟器上</li>
<li>然后点击 Xcode 上的 <code>Debug View Hierarchy</code> 按钮：<img src="https://i.loli.net/2018/11/01/5bdabd4a9ae0c.png"></li>
<li>然后 Xcode 就会显示一个你当前 App 的视图层次的窗口，我这边是这样的：<img src="https://i.loli.net/2018/11/01/5bdabd584cf2d.png"></li>
<li>选中一个控件之后，可以查看该控件的一些信息：<img src="https://i.loli.net/2018/11/01/5bdabd676498a.png"></li>
<li>可以转动视图来查看各个方向上的层次结构：<img src="https://i.loli.net/2018/11/01/5bdabd761d97c.png"></li>
</ol>
<p>对于自己的 App，如果你要求不是那么高的话，Xcode 也是差不多够用了，当然，这是在没有和 Reveal 的对比下，相信我，看完了 Reveal，你绝逼会想买的。</p>
<h1 id="0x02-Reveal-登场"><a href="#0x02-Reveal-登场" class="headerlink" title="0x02 Reveal 登场"></a>0x02 Reveal 登场</h1><p>现在该是 Reveal 的 Show Time 了！你也可以查看相关的<a href="http://support.revealapp.com/kb/getting-started/integrating-reveal-static-linking">官方教程</a>，要想用 Reveal 来查看自己的 App 的视图，先要配置一下项目，也很简单，只要如下几步：</p>
<ol>
<li>你要先安装了 Reveal</li>
<li>打开 Reveal，点击菜单栏上的 <em><strong>Help -&gt; Show Reveal Library in Finder</strong></em> ：<img src="https://i.loli.net/2018/11/01/5bdabd86253a4.png"></li>
<li>点击了之后，Finder 会打开一个窗口，将 <code>Reveal.framework</code> 拖入你的 Xcode 项目中，记得勾选：<img src="https://i.loli.net/2018/11/01/5bdabd99bd99c.png"></li>
<li>然后点击上方的 <em>Project -&gt; Targets -&gt; Build Phases -&gt; Link Binary With Libraries</em> ，将 Reveal.framework 移除（如果有的话）：<img src="https://i.loli.net/2018/11/01/5bdabda8970a5.png"></li>
<li>点击 <em>Build Settings</em> ，搜索 <code>Other Linker Flags</code>，添加下面这行代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-ObjC -lz -framework Reveal</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabdb93e2f0.png"></p>
<p>如果是这样，就算是配置完成了：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabdcc4e4b2.png"></p>
<h1 id="0x03-Reveal-查看-App-视图"><a href="#0x03-Reveal-查看-App-视图" class="headerlink" title="0x03 Reveal 查看 App 视图"></a>0x03 Reveal 查看 App 视图</h1><p>配置完了当然就可以用 Reveal 查看自己的 App 的视图了，直接运行，然后打开 Reveal，点击左上角的 <code>No Connection</code> 来选择要查看的 App：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabddb6f57b.png"></p>
<p>然后就可以开始玩了，比如这个 Demo 在 Reveal 中展示起来就是这样的：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabdeb7655e.png"></p>
<p>左侧是视图层次结构，右侧是各种参数信息，非常多，而且界面也是支持旋转的，2D、3D 模式。</p>
<p>这个 Demo 非常简单，看不出来有什么很屌的样子，那我就上一张自己正在开发的一个 App 的截图：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabdfa84ed7.png"></p>
<p>这样足够明显了吧？知道 Reveal 的好处了吧。</p>
<p>关键是 Reveal 不止可以查看自己的 App，还可以查看第三方的 App，这个对我的吸引才是最大的。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Reveal</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 开发常用的第三方开源库</title>
    <url>/2015/06/23/in-common-use-ios-third-part-library/</url>
    <content><![CDATA[<h1 id="First，Thanks-Open-Source！！！"><a href="#First，Thanks-Open-Source！！！" class="headerlink" title="First，Thanks Open Source！！！"></a>First，Thanks Open Source！！！</h1><hr>
<h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><ol>
<li><a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>：最常用的网络请求库</li>
<li><a href="https://github.com/rs/SDWebImage">SDWebImage</a>：加载网络图片</li>
<li><a href="https://github.com/dustturtle/RealReachability">RealReachability</a>：We need to observe the REAL reachability of network for iOS. That’s what RealReachability do.</li>
</ol>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><ol>
<li><a href="https://github.com/icanzilb/JSONModel">JSONModel</a>：模型 &amp; 字典转换框架</li>
<li><a href="https://github.com/Mantle/Mantle">Mantle</a>：模型 &amp; 字典转换框架</li>
<li><a href="https://github.com/CoderMJLee/MJExtension">MJExtension</a>：获取 JSON 数据之后，转换成本地的 Model 类</li>
<li><a href="https://github.com/ibireme/YYModel">YYModel</a>：高性能 iOS&#x2F;OSX 模型转换框架。</li>
</ol>
<h1 id="Auto-Layout"><a href="#Auto-Layout" class="headerlink" title="Auto Layout"></a>Auto Layout</h1><ol>
<li><a href="https://github.com/SnapKit/Masonry">Masonry</a>：Masonry 是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了，并具有高可读性，而且同时支持 iOS 和 Max OS X。(这句话来自 <a href="http://www.cocoachina.com/ios/20141219/10702.html">CocoaChina</a>)</li>
<li><a href="https://github.com/SnapKit/SnapKit">SnapKit</a>：Swift 上的 Auto Layout 框架，也同时支持 iOS 和 Max OS X。</li>
<li><a href="https://github.com/PureLayout/PureLayout">PureLayout</a>：PureLayout 是 iOS &amp; OS X Auto Layout 的终极 API——非常简单，又非常强大。PureLayout 通过一个全面的 Auto Layout API 扩展了 UIView &#x2F; NSView, NSArray 和 NSLayoutConstraint，仿照苹果自身的框架。</li>
<li><a href="https://github.com/gsdios/SDAutoLayout">SDAutoLayout</a>：AutoLayout 一行代码搞定自动布局！支持 Cell 和 Tableview 高度自适应，Label 和 ScrollView 内容自适应，致力于做最简单易用的 AutoLayout 库。The most easy way for autoLayout. Based Runtime.</li>
</ol>
<h1 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h1><ol>
<li><a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a>：简单好用的上&#x2F;下拉刷新<br><img src="https://camo.githubusercontent.com/15577b87be4403d9e2ede4d5cd5b9fccbd1d03ae/687474703a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f67323031352f3439373237392f3230313530362f3134313230343334333438363135312e676966" alt="MJRefresh" title="MJRefresh"></li>
<li><a href="https://github.com/enormego/EGOTableViewPullRefresh">EGOTableViewPullRefresh</a></li>
<li><a href="https://github.com/MortimerGoro/MGSwipeTableCell.git">MGSwipeTableCell</a>：支持多种侧滑模式</li>
</ol>
<h1 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h1><ol>
<li><a href="https://github.com/JazysYu/JZNavigationExtension">JZNavigationExtension</a>：为UINavigationController集成了许多方便的功能点，同时为它打开了一些隐藏功能。</li>
</ol>
<h1 id="TabBar"><a href="#TabBar" class="headerlink" title="TabBar"></a>TabBar</h1><ol>
<li><a href="https://github.com/antiguab/BATabBarController">BATabBarController</a>：炫酷 Tabbar 切换动画</li>
</ol>
<h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1><ol>
<li><a href="https://github.com/facebook/pop">Pop</a>：Facebook 出品，一些效果可以查看<a href="https://github.com/schneiderandre/popping">popping</a> 这个库</li>
<li><a href="https://github.com/jwilling/JNWSpringAnimation">JNWSpringAnimation</a>：CAKeyframeAnimation 的子类，它支持创建阻尼动画效果。</li>
</ol>
<h1 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h1><ol>
<li><a href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a>：挺好看的加载等待提示</li>
<li><a href="https://github.com/TransitApp/SVProgressHUD">SVProgressHUD</a>：一个轻量级的 HUD<br><img src="https://camo.githubusercontent.com/6ed028acbf67707d622344e0ef1bc3b098425b50/687474703a2f2f662e636c2e6c792f6974656d732f32473146315a304d306b306832553356317033392f535650726f67726573734855442e676966" alt="SVProgressHUD" title="SVProgressHUD"></li>
<li><a href="https://github.com/JonasGessner/JGProgressHUD">JGProgressHUD</a>：挺好看的一个 HUD</li>
</ol>
<h1 id="Image-Picker"><a href="#Image-Picker" class="headerlink" title="Image Picker"></a>Image Picker</h1><ol>
<li><a href="https://github.com/chiunam/CTAssetsPickerController">CTAssetsPickerController</a>：从相册中选择图片<br><img src="https://github.com/chiunam/CTAssetsPickerController/raw/master/Screenshot.png" alt="CTAssetsPickerController" title="CTAssetsPickerController"></li>
</ol>
<h1 id="图片浏览"><a href="#图片浏览" class="headerlink" title="图片浏览"></a>图片浏览</h1><ol>
<li><a href="https://github.com/ideaismobile/IDMPhotoBrowser">IDMPhotoBrowser</a></li>
</ol>
<h1 id="Keyboard"><a href="#Keyboard" class="headerlink" title="Keyboard"></a>Keyboard</h1><ol>
<li><a href="https://github.com/hackiftekhar/IQKeyboardManager">IQKeyboardManager</a>：一行代码都不需要就可以处理键盘事件，非常非常好用！！！</li>
</ol>
<h1 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h1><ol>
<li><a href="https://github.com/jverdi/JVFloatLabeledTextField">JVFloatLabeledTextField</a>：很好看的输入框，框内的提示文字在用户开始输入文本的时候会飞到输入框的上方<br><img src="https://camo.githubusercontent.com/be57d040ec0ce5d6467fb73564c6bcb6c76d5a7b/687474703a2f2f6472696262626c652e73332e616d617a6f6e6177732e636f6d2f75736572732f363431302f73637265656e73686f74732f313235343433392f666f726d2d616e696d6174696f6e2d5f6769665f2e676966" alt="JVFloatLabeledTextField" title="JVFloatLabeledTextField"></li>
</ol>
<h1 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h1><ol>
<li><a href="https://github.com/nicklockwood/iCarousel">iCarousel</a>：iCarousel 是一个用来简化在 iOS 上实现旋转木马时的视图切换效果，支持 iPad，提供多种切换效果。内容类似的页面需要并排列出来，供用户选择。iCarousel 具有非常酷的 3D 效果，比如经典的 CoverFlow, TimeMachine。另外还具有线性，圆柱状等其它效果。可用于图片选择，书籍选择，网页选择等。(介绍来自 <a href="http://www.oschina.net/p/icarousel">OSChina</a>，效果非常多，去 GitHub 上去看吧)</li>
<li><a href="https://github.com/nicklockwood/SwipeView">SwipeView</a>：滚动视图，可以根据回调方法做出懒加载效果，也就是说等下一个视图滚动结束之后再加载该视图内容，而不是一滑动的时候就加载下一个视图内容。<br><img src="https://camo.githubusercontent.com/3fc68ae90647a06add9ade7d13b7631c62e8e7cf/687474703a2f2f672e7265636f726469742e636f2f524b54394f4548626f4c2e676966" alt="SwipeView" title="SwipeView"></li>
<li><a href="https://github.com/dzenbot/DZNEmptyDataSet">DZNEmptyDataSet</a>：展示无数据时的占位视图</li>
</ol>
<h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><ol>
<li><a href="https://github.com/strekfus/TPFloatRatingView">TPFloatRatingView</a>：挺不错的一个打分控件<br><img src="https://camo.githubusercontent.com/f782cd6eff4fda49f07502f8cc01c0c2d2edc2ed/68747470733a2f2f7261772e6769746875622e636f6d2f737472656b6675732f5450466c6f6174526174696e67566965772f6d61737465722f5450466c6f6174526174696e675669657744656d6f2e676966" alt="TPFloatRatingView" title="TPFloatRatingView"></li>
</ol>
<h1 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h1><ol>
<li><a href="https://github.com/path/FastImageCache">FastImageCache</a>：Path 出品的图片加载缓存库</li>
<li><a href="https://github.com/liuzhiyi1992/ZYCornerRadius">ZYCornerRadius</a>：一句代码，圆角风雨无阻。避免为 UIImageView 设置圆角时触发离屏渲染所带来的性能损耗，两种工作方式：Category 和 UIImageView 子类。</li>
<li><a href="https://github.com/Flipboard/FLAnimatedImage">FLAnimatedImage</a>：播放 GIF 图片</li>
</ol>
<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><ol>
<li><a href="https://github.com/DeveloperLx/LxDBAnything">LxDBAnything</a>：简化打 log 时的语句，再也不必考虑蛋疼的格式控制符了，甚至连引号都不需要写！</li>
</ol>
<h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><ol>
<li><a href="https://github.com/pinterest/PINCache">PINCache</a>：比较成熟的缓存框架。</li>
</ol>
<h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><ol>
<li><a href="https://github.com/kconner/KMCGeigerCounter">KMCGeigerCounter</a>：测界面桢率</li>
<li><a href="https://github.com/mac-cain13/R.swift">R.swift</a>：如果你熟悉 Android 开发，你可能知道在 Android 中有一个 R 类，你可以通过 R 来安全地获取到应用包中的各种资源。而在 iOS 开发中，我们往往需要通过指定资源的名字来获取一个资源 (例如 UIImage 的 imageWithName:)。R.swift 在 iOS 开发中实现了一个类似 Android R class 的功能，使用这个框架，你可以用更安全的方式来获取资源。值得一提的是这个库对资源的检查都是在编译时完成的，本身并不会进入到你的项目中去，也不会对 app 的性能产生影响。（介绍来自 <a href="http://www.infoq.com/cn/news/2015/08/ios-weekly-apple-tv">InfoQ</a>）</li>
<li><a href="https://github.com/12207480/TYPagerController">TYPagerController</a>：简单，支持定制，页面控制器，可以滚动内容和标题栏，包含多种 barStyle。</li>
<li><a href="https://github.com/joeldev/JLRoutes">JLRoutes</a>：JLRoutes is advanced URL parsing with a block-based callback API. It is designed to make it very easy to handle complex URL schemes in your application without having to do any URL or string parsing of any kind.</li>
<li><a href="https://github.com/joggerplus/JPFPSStatus">JPFPSStatus</a>：JPFPSStatus 是用来显示 FPS 状态在 iOS 状态栏，FPS 是一秒钟渲染多少帧 Frame Per Second &#x3D; FPS，FPS 的值最佳为 60 左右，一般来说小于这个值就较为卡顿了。</li>
<li><a href="https://github.com/zwaldowski/BlocksKit">BlocksKit</a>：The Objective-C block utilities you always wish you had.</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GitHub</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>NSPredicate 的简单使用</title>
    <url>/2015/09/06/ios-simple-use-of-nspredicate/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在重新学习 Objective-C，因为觉得基础非常重要，而且对 Objective-C 的使用都基本上是工作中用到的，了解得还不够多，就算当初学习 Objective-C 的时候知道了，但是到现在也忘了不少东西。内容主要来自<a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6%E2%80%A2%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97-Objective-C%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E5%85%8B%E7%BA%B3%E6%96%AF%E7%89%B9/dp/B00COG40Y0/ref=sr_1_1?s=books&ie=UTF8&qid=1441502082&sr=1-1&keywords=Objective-C+%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B">《Objective-C 基础教程（第2版）》</a>，这本书的代码可以到<a href="http://www.apress.com/9781430241881">这里</a>下载。</p>
<span id="more"></span>

<h1 id="0x01-NSPredicate"><a href="#0x01-NSPredicate" class="headerlink" title="0x01 NSPredicate"></a>0x01 NSPredicate</h1><p>其实当初第一次接触 NSPredicate 的时候，觉得不是很懂，也觉得有点难，也没去多了解一下，直到最近重新学基础时才发觉，其实 NSPredicate 挺好用的，也很好理解，以前用的最多的应该是正则吧，各种语言里面都是可以用的，就是需要记住的符号什么的好多，如果长时间不用的话，就会忘记，虽然这很正常。</p>
<p>基本上每个 App 都会涉及到数据的筛选过滤，也就是搜索，很少见到哪个 App 没有搜索功能。Cocoa 用 NSPredicate 描述查询的方式，原理类似于数据库查询，其实感觉语法上也有点相似呢。</p>
<h1 id="0x02-创建谓词"><a href="#0x02-创建谓词" class="headerlink" title="0x02 创建谓词"></a>0x02 创建谓词</h1><p>我们这里还是使用书上的例子，不过不用担心，就算没有看过书上的例子代码也是 OK 的，不难理解。<br>下面是一个快速创建一辆汽车的 C 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Car *<span class="title function_">makeCar</span><span class="params">(NSString *name, NSString *make, NSString *model, <span class="type">int</span> modelYear, <span class="type">int</span> numberOfDoors, <span class="type">float</span> mileage, <span class="type">int</span> horsepower)</span> &#123;</span><br><span class="line">	Car *car = [[[Car alloc] init] autorelease];</span><br><span class="line">	car.name = name;</span><br><span class="line">	car.make = make;</span><br><span class="line">	car.model = model;</span><br><span class="line">	car.modelYear = modelYear;</span><br><span class="line">	car.numberOfDoors = numberOfDoors;</span><br><span class="line">	car.mileage = mileage;</span><br><span class="line">	</span><br><span class="line">	Slant6 *engine = [[[Slant6 alloc] init] autorelease];</span><br><span class="line">	[engine setValue:[NSNumber numberWithInt:horsepower] forKey:@<span class="string">&quot;horsepower&quot;</span>];</span><br><span class="line">	car.engine = engine;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Make some tires.</span></span><br><span class="line">	<span class="comment">// int i;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		Tire * tire= [[[Tire alloc] init] autorelease];</span><br><span class="line">		[car setTire:tire  atIndex:i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (car);</span><br><span class="line">&#125; <span class="comment">// makeCar</span></span><br></pre></td></tr></table></figure>

<p>可以使用这个 C 函数来创建一辆汽车：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Car *car = makeCar(<span class="string">@&quot;Herbie&quot;</span>, <span class="string">@&quot;Honda&quot;</span>, <span class="string">@&quot;CRX&quot;</span>, <span class="number">1984</span>, <span class="number">2</span>, <span class="number">34000</span>, <span class="number">58</span>);</span><br><span class="line">[garage addCar:car];</span><br></pre></td></tr></table></figure>

<p>上面代码创建一辆汽车，具体的汽车信息为：Herbie 品牌，型号为双门1984 Honda CRX，马力引擎为58，已行驶34000英里。</p>
<p>现在来创建谓词：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;name == &#x27;Herbie&#x27;&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>我们使用 NSPredicate 的类方法 <code>+predicateWithFormat:</code> 创建了一个 NSPredicate 的对象，并传入了一个字符串参数，这个类方法使用该字符串在后台构建对象，来计算谓词的值，简单来说，就是以这个字符串来当筛选过滤的条件。</p>
<h1 id="0x03-计算谓词"><a href="#0x03-计算谓词" class="headerlink" title="0x03 计算谓词"></a>0x03 计算谓词</h1><p>通过以上步骤，就创建好了一个谓词，现在我们可以使用它了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">BOOL</span> match = [predicate evaluateWithObject:car];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, (match) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>方法 <code>-evaluateWithObject:</code> 通知接收对象（即谓词）根据指定的对象计算自身的值。这里是以 name 作为键路径，使用 <code>-valueForKeyPath:</code> 方法来获取名称，然后将自身的这个名称（即 name）与 Herbie 进行比较，相同返回 YES，否则返回 NO。</p>
<p>以下是另外一个谓词：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;engine.horsepower &gt; 150&quot;</span>];</span><br><span class="line">match = [predicate evaluateWithObject:car];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, (match) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个谓词字符串的左侧是一个键路径，该键路径链接到 car 内部，查找 engine，然后再查找 engine 的 horsepower，然后将其与150进行比较，看它是否大于150。</p>
<p>以上都是通过特定的谓词条件检查单个对象，都很简单，但是在实际工作当中，我们通常都是从一堆的数据里面进行筛选的，比如，有一个车库，我们需要筛选出哪些汽车的马力大于150，普通的做法可能如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Car *car <span class="keyword">in</span> [garage cars]) &#123;</span><br><span class="line">	<span class="keyword">if</span> ([predicate evaluateWithObject:car]) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, car.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 for 循环遍历每一辆汽车，然后检查其马力是否大于150，大于150的话，就输出汽车的名字。</p>
<h1 id="0x04-数据过滤器"><a href="#0x04-数据过滤器" class="headerlink" title="0x04 数据过滤器"></a>0x04 数据过滤器</h1><p>懒惰一直是编程人员的缺点，但是在某种意义上也是优点。如果不用编写这样的 for 循环和 if 语句，没什么不好的。而且 Cocoa 也提供了这样的方法：<code>-filteredArrayUsingPredicate:</code>，这个方法是 NSArray 数组中的一种类别方法，它会循环遍历数组中的对象，根据谓词来计算每个对象的值，如果是 YES，那么就将这个对象添加到将被返回的新数组中，感觉这个和上面的那个 for 循环类似吧？</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, results);</span><br></pre></td></tr></table></figure>

<p>这样的话，只需要一行代码就可以获取筛选之后的结果了，不过这里输出的是汽车的全部信息，而不是上面那样输出汽车的名字，不过我们可以使用 KVC（键值编码）来提取其中的名称：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [results valueForKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, names);</span><br></pre></td></tr></table></figure>

<p>上面的 cars 是不可变数组，如果我们的数据是存放在可变数组里面，而且我们需要剔除不满足条件的对象的话，可以使用 NSMutableArray 的 <code>-filterUsingPredicate:</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *carsCopy = [cars mutableCopy];</span><br><span class="line">[carsCopy filterUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, carsCopy);</span><br></pre></td></tr></table></figure>

<p>因为 NSMutableArray 是 NSArray 的子类，所以也是可以用 <code>-filteredArrayUsingPredicate:</code> 方法来构建新的不可变数组的。使用谓词的确很便捷，但是它的运行速度并不会比自己编写全部代码要快，因为它无法避免要使用循环来遍历。</p>
<h1 id="0x05-格式说明符"><a href="#0x05-格式说明符" class="headerlink" title="0x05 格式说明符"></a>0x05 格式说明符</h1><p>从方法 <code>-predicateWithFormat:</code> 可以看出来，传入的字符串是可以使用格式说明符的，比如：<code>%d</code>、<code>%f</code> 等。而且一般筛选条件都不是硬编码到项目里面的，都是根据用户的输入来进行筛选的。</p>
<p>除了可以使用 printf 说明符，还可以使用 <code>%@</code> 来插入字符串，而 <code>%@</code> 会被当做带引号的字符串：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;name == %@&quot;</span>, <span class="string">@&quot;Herbie&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>要注意，这里的格式字符串 <code>%@</code> 并没有打单引号，如果打上了单引号，例如：<code>&quot;name == &#39;%@&#39;&quot;</code>，字符 <code>%</code> 和 <code>@</code> 会被当做普通字符而失去了格式说明符的作用。</p>
<p>NSPredicate 字符串中也可以使用 <code>%K</code> 来指定键路径：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;%K == %@&quot;</span>, <span class="string">@&quot;name&quot;</span>, <span class="string">@&quot;Herbie&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>为了构造灵活的谓词，一种方式是使用格式说明符，另一种方式是将变量名放入字符串中，类似于环境变量：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSPredicate</span> *predicateTemplate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;name == $NAME&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>现在，我们有一个含有变量的谓词，可以使用 <code>-predicateWithSubstitutionVariables:</code> 来构造新的专用谓词，创建一个键&#x2F;值对字典，其中键是变量名（不包含美元符号$），值是想要插入谓词的内容：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *varDict = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:<span class="string">@&quot;Herbie&quot;</span>, <span class="string">@&quot;NAME&quot;</span>, <span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p>这里使用字符串 “Herbie” 作为键 “NAME” 的值，构造以下新谓词：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicate = [predicateTemplate predicateWithSubstitutionVariables:varDict];</span><br></pre></td></tr></table></figure>

<p>这个谓词跟之前的那些没什么不一样。</p>
<p>也可以用其他对象作为变量的值，例如 NSNumber，以下谓词用于过滤引擎的马力：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicateTemplate = [<span class="built_in">NSPredicate</span> predicateWithFormat:@:<span class="string">&quot;engine.horsepower &gt; $POWER&quot;</span>];</span><br><span class="line">varDict = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">150</span>], <span class="string">@&quot;POWER&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">predicate = [predicateTemplate predicateWithSubstitutionVariables:varDict];</span><br></pre></td></tr></table></figure>

<p>除了使用 NSNumber 和 NSString 之外，也可以使用 <code>[NSNull null]</code> 来设置 nil 值，甚至可以使用数组。要注意的是，不能使用 <code>&quot;$变量名&quot;</code> 作为键路径，它只能表示值。使用谓词格式字符串时，如果想在程序中通过代码改变键路径，需要使用 <code>%K</code> 格式说明符。谓词机制不进行静态类型检查。</p>
<h1 id="0x06-运算符"><a href="#0x06-运算符" class="headerlink" title="0x06 运算符"></a>0x06 运算符</h1><p>NSPredicate 的格式字符串包含大量不同的运算符。</p>
<h2 id="比较和逻辑运算符"><a href="#比较和逻辑运算符" class="headerlink" title="比较和逻辑运算符"></a>比较和逻辑运算符</h2><p>谓词字符串语法支持 C 语言中的一些常用运算符，不等号运算符如下表所示：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>比较作用</th>
</tr>
</thead>
</table>
<blockquote>
<p>  | 大于某数<br>&#x3D; 和 &#x3D;&gt; | 大于或等于某数<br>  &lt;   | 小于某数<br> &lt;&#x3D; 和 &#x3D;&lt; | 小于或等于某数<br> !&#x3D; 和 &lt;&gt; | 不等于某数</p>
</blockquote>
<p>此外，谓词字符串语法还支持括号表达式、AND、OR 和 NOT 逻辑运算符，以及用 C 语言样式表示具有相同功能的 “&amp;&amp;”、”||” 和 “!” 符号。</p>
<p>我们可以筛选出马力在某个范围内的汽车：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;(engine.horsepower &gt; 50) AND (engine.horsepower &lt; 200)&quot;</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;oop %@&quot;</span>, results);</span><br></pre></td></tr></table></figure>

<p>上面是筛选出马力在50和200之间的汽车。</p>
<p>谓词字符串中的运算符不区分大小写，比如上面的 AND，可以随便写，比如：And、aNd等。</p>
<p>不等号既适用于数字值也适用于字符串值，比如按照字母表顺序查看所有名字排在 “Newton” 之前的汽车：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;name &lt; &#x27;Newton&#x27;&quot;</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [results valueForKey:<span class="string">@&quot;name&quot;</span>]);</span><br></pre></td></tr></table></figure>

<h2 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h2><p>上面筛选马力在50到200之间的汽车使用的谓词字符串为 <code>&quot;(engine.horsepower &gt; 50) AND (engine.horsepower &lt; 200)&quot;</code>，我们还可以写得更加简洁：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;engine.horsepower BETWEEN &#123; 50, 200 &#125;&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>花括号表示数组，BETWEEN 将数组中的第一个元素看成数组的下限，第二个元素看成数组的上限。</p>
<p>可以使用 <code>%@</code> 格式说明符向 NSArray 数组中插入对象：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *betweens = [<span class="built_in">NSArray</span> arrayWithObjects:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">50</span>], [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">200</span>], <span class="literal">nil</span>];</span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;engine.horsepower BETWEEN %@&quot;</span>, betweens];</span><br></pre></td></tr></table></figure>

<p>也可以使用变量：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicateTemplate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;engine.horsepower BETWEEN $POWERS&quot;</span>];</span><br><span class="line">varDict = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:betweens, <span class="string">@&quot;POWERS&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">predicate = [predicateTemplate predicateWithSubstitutionVariables:varDict];</span><br></pre></td></tr></table></figure>

<p>数组不仅可以用来指定某个区间的端点值，还可以配合 IN 运算符来查找数组中是否含有某个特定值，跟 SQL 很像哈：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;name IN &#123; &#x27;Herbie&#x27;, &#x27;Snugs&#x27;, &#x27;Badger&#x27;, &#x27;Flap&#x27; &#125;&quot;</span>];</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [results valueForKey:<span class="string">@&quot;name&quot;</span>]);</span><br></pre></td></tr></table></figure>

<h1 id="0x07-有-SELF-就足够了"><a href="#0x07-有-SELF-就足够了" class="headerlink" title="0x07 有 SELF 就足够了"></a>0x07 有 SELF 就足够了</h1><p>有时候，我们可能需要将谓词应用于简单的值（例如纯文本的字符串），而不是那些通过键路径进行操作的复杂对象，比如我们需要从一汽车名称的数组中查询 name 时，就不能像之前那样子用了，这时候就轮到 <code>SELF</code> 出场了！</p>
<p><code>SELF</code> 表示的是响应谓词计算的对象，事实上我们可以将谓词中所有的键路径表示成对应的 SELF 形式：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;SELF.name IN &#123; &#x27;Herbie&#x27;, &#x27;Snugs&#x27;, &#x27;Badger&#x27;, &#x27;Flap&#x27; &#125;&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>我们先获取所有的汽车名称，然后构造一个谓词，并计算该谓词的值：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">names = [cars valueForKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;SELF IN &#123; &#x27;Herbie&#x27;, &#x27;Snugs&#x27;, &#x27;Badger&#x27;, &#x27;Flap&#x27; &#125;&quot;</span>];</span><br><span class="line">results = [names filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, results);</span><br></pre></td></tr></table></figure>

<p>结果和前面的示例是一样的：Herbie 和 Badger。</p>
<p>这里提一个问题，以下代码会输出什么呢？</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names1 = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;Herbie&quot;</span>, <span class="string">@&quot;Badger&quot;</span>, <span class="string">@&quot;Judge&quot;</span>, <span class="string">@&quot;Elvis&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *names2 = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;Judge&quot;</span>, <span class="string">@&quot;Paper Car&quot;</span>, <span class="string">@&quot;Badger&quot;</span>, <span class="string">@&quot;Phoenix&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;SELF IN %@&quot;</span>, names1];</span><br><span class="line">results = [names2 filteredArrayUsingPredicate:predicate];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, results);</span><br></pre></td></tr></table></figure>

<p>答案如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">    Judge,</span><br><span class="line">    Badger</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对于取两个数组交集的运算来说，这种方式很巧妙。谓词包含了第一个数组的内容，因此和下面的形式类似：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SELF IN &#123;<span class="string">&quot;Herbie&quot;</span>, <span class="string">&quot;Badger&quot;</span>, <span class="string">&quot;Judge&quot;</span>, <span class="string">&quot;Elvis&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>现在，使用该谓词筛选第二个名称数组，在 name2 中如果有同时存在两个数组中的字符串，那么 <code>SELF IN</code> 会确定它是符合条件的，因此它就会保留在结果数组中，如果对象只存在于第二个数组中，那么它不会与谓词中的任何字符串匹配，所以该对象将被过滤掉，而只存在于第一个数组中的字符串因为要用来进行比较，所以将一直保留在原来的位置，不会出现在结果数组中。</p>
<h1 id="0x08-字符串运算符"><a href="#0x08-字符串运算符" class="headerlink" title="0x08 字符串运算符"></a>0x08 字符串运算符</h1><p>之前使用字符串时说到过关系运算符，此外，还有一些针对字符串的关系运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>BEGINSWITH</td>
<td>检查某个字符串是否以另一个字符串开头</td>
</tr>
<tr>
<td>ENDSWITH</td>
<td>检查某个字符串是否以另一个字符串结尾</td>
</tr>
<tr>
<td>CONTAINS</td>
<td>检查某个字符串是否在另一个字符串内部</td>
</tr>
</tbody></table>
<p>使用关系运算符可以执行一些有用的操作，例如使用 <code>&quot;name BEGINSWITH &#39;Bad&#39;&quot;</code> 匹配 Badger，使用 <code>&quot;name ENDSWITH &#39;vis&#39;&quot;</code> 匹配 Elvis，以及使用 <code>&quot;name CONTAINS udg&quot;</code>  匹配 Judge。</p>
<p>如果是 <code>&quot;name BEGINSWITH &#39;HERB&#39;&quot;</code> 这样的呢？它不会与 Herbie 匹配，因为这些匹配是区分大小写的，同样，<code>&quot;name BEGINSWITH &#39;Hérb&#39;&quot;</code> 也不会与之匹配，因为其中的 e 是含有重音符的。为了避免这些情况，可以为运算符添加 [c]、[d] 或 [cd] 修饰符，其中 c 表示 “不区分大小写”，d 表示 “不区分发音符号（diacritic insensitive，即忽略重音符）”，cd 表示 “即不区分大小写，也不区分发音符号”。通常情况下，都会使用这两个修饰符，除非有特殊需求需要区分大小写或者重音符号。</p>
<p>所以 Herbie 和 “name BEGINSWITH[cd] ‘HERB’” 相匹配。</p>
<h1 id="0x09-LIKE-运算符"><a href="#0x09-LIKE-运算符" class="headerlink" title="0x09 LIKE 运算符"></a>0x09 LIKE 运算符</h1><p>了解 SQL 的同学看到 LIKE 应该能猜到了，没错，有时候匹配开头或者结尾，又或者是否包含还不够，所以谓词格式字符串还提供了 LIKE 运算符，问号表示与一个字符匹配，型号表示与任意个字符匹配，也可以称为 “通配符”。</p>
<p>谓词字符串 “name LIKE ‘*er*‘“ 将会与任何含有 er 的名称相匹配，等效于 CONTAINS。</p>
<p>谓词字符串 “name LIKE ‘???er*’” 将会与 Pager Car 相匹配，因为其中的 er 前面有3个字符，后面也有一些字符。但是它与 Badger 不匹配，因为 Badger 的 er 前面有4个字符。</p>
<p>另外，LIKE 也接收 [cd] 修饰符，用户忽略大小写和发音符号。</p>
<p>如果你喜欢用正则表达式，可以使用 MATCHES 运算符，赋给它一个正则表达式，谓词将会计算出它的值。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>NSPredicate</tag>
      </tags>
  </entry>
  <entry>
    <title>查找目标 App 在 iPhone 里的目录</title>
    <url>/2015/08/19/iosre-find-app-installation-and-sandbox-directory/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本文记录了我在学习 iOS 逆向工程的过程中学到的相关知识中的定位目标 App 的一些目录在 iPhone 中的路径，我看的书是 <a href="https://www.amazon.cn/iOS%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-%E6%B2%99%E6%A2%93%E7%A4%BE/dp/B00VFDVY7E/ref=sr_1_1?s=books&ie=UTF8&qid=1439878290&sr=1-1&keywords=ios+%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B">iOS应用逆向工程(第2版)</a>，有兴趣的同学可以购买学习。</p>
<span id="more"></span>

<h1 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h1><p>准备工作就不扯那么多了，要学习 iOS 逆向工程，最基本的是需要有一台已经越狱的 iPhone，而且已经安装了 OpenSSH 和 Cycript，刚越狱的 iPhone 的 SSH 密码默认是 <code>alpine.</code>（带英文标点），为了安全，最好修改成其他的，然后最好是还有一台 Mac。</p>
<h1 id="0x02-定位目标-App-的安装目录"><a href="#0x02-定位目标-App-的安装目录" class="headerlink" title="0x02 定位目标 App 的安装目录"></a>0x02 定位目标 App 的安装目录</h1><p>首先，我们先找到目标 App 的安装目标，AppStore 上下载的 App 一般都是安装在 <code>/var/mobile/Containers/Bundle/Application/</code> 下的，书中提到的这个小技巧，非常方便，简单粗暴，先关掉所有从 AppStore 上安装的 App，就只运行目标 App，然后用 Mac 通过 SSH 连接 iPhone，使用命令打印出所有的进程：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabf6029942.png"></p>
<p>可以看到有非常多的进程，找起来好麻烦，这里有一个更方便查看的命令，那就是使用 <code>grep</code>，因为我们知道了 App 所在目录的路径前缀，所以直接用 <code>grep</code> 来 “筛选” 出来，命令如下：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabfb3da079.png"></p>
<p>可以看到，只有一个结果，这个就是我们目标 App (这里是以 QQ 为例) 在我们的 iPhone 中所在的安装目录的绝对路径了。</p>
<h1 id="0x03-拷贝目标-App"><a href="#0x03-拷贝目标-App" class="headerlink" title="0x03 拷贝目标 App"></a>0x03 拷贝目标 App</h1><p>既然找到了，那我们就可以将它拷贝到我们的 Mac 上了，方法有多种，你可以选择是用类似 iFunBox 这样的工具，或者直接使用命令行 (scp) 的方式，这里以命令行的方式来进行拷贝，我在 Mac 上重新打开了一个终端，然后输入以下的命令来进行拷贝：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabfd485251.png"></p>
<p>Ps. 其实我这里已经完成了拷贝，只是命令被刷屏不见了，所以这里再把命令弄出来可以看到。</p>
<p>在 Finder 中打开拷贝的目标目录，可以看到目标 App 已经被拷贝出来了：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabfe895a6b.png"></p>
<h1 id="0x04-定位目标-App-的-Documents-目录"><a href="#0x04-定位目标-App-的-Documents-目录" class="headerlink" title="0x04 定位目标 App 的 Documents 目录"></a>0x04 定位目标 App 的 Documents 目录</h1><p>我们使用 Cycript 来找到目标 App 的 Documents 目录，非常简单，三步就能找到，首先要先知道目标 App 的 CFBundleExecutable：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabff607548.png"></p>
<p>可以看到 QQ 的 CFBundleExecutable 就是 “QQ”，根据我拷贝出来的几个 App，基本上可以估计，App 的 CFBundleExecutable 都是跟 <code>目标 App.app</code> 的名字一样的，不过为了确定性，使用上面的命令来确定真正的 CFBundleExecutable 也不麻烦。</p>
<p>确定了目标 App 的 CFBundleExecutable，那么就可以开始定位 Documents 目录了，输入下面的命令：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSFileManager</span> defaultManager] URLsForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomains:<span class="built_in">NSUserDomainMask</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2018/11/01/5bdac00333078.png"></p>
<p>这里说一下我在这个过程中遇到的问题以及怎么解决的，从上面这些图中可以看到，有时候我输入了命令，没有正确执行，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh: connect to host 192.168.36.75 port 22: Host is down</span><br></pre></td></tr></table></figure>

<p>这个问题的话，只要将手机解锁一下就 OK 了，反正我是这么解决的。</p>
<p>输入 <code>cycript -p QQ</code> 的时候，报了这个错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iPhone-5S:~ root<span class="comment"># cycript -p QQ</span></span><br><span class="line"></span><br><span class="line">*** _krncall(mach_vm_read_overwrite(task, data + offsetof(Baton, error), sizeof(baton-&gt;error), reinterpret_cast&lt;mach_vm_address_t&gt;(&amp;baton-&gt;error), &amp;error)):../Mach/Inject.cpp(293):InjectLibrary [<span class="built_in">return</span>=0x4]</span><br><span class="line">iPhone-5S:~ root<span class="comment"># cycript -p QQ</span></span><br><span class="line">unable to find process `QQ<span class="string">&#x27; using ps</span></span><br></pre></td></tr></table></figure>

<p>看错误信息，我感觉到应该是手机上 QQ 出了问题，我重新将 QQ 切换回前台，发现这个时候 QQ 应该是被杀掉的样子，然后等 QQ 重新运行好了，再输入 <code>cycript -p QQ</code> 就能正确执行了。</p>
<p>cycript 退出命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">?<span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h1 id="0x05-拷贝目标-App-的-Documents-目录"><a href="#0x05-拷贝目标-App-的-Documents-目录" class="headerlink" title="0x05 拷贝目标 App 的 Documents 目录"></a>0x05 拷贝目标 App 的 Documents 目录</h1><p>既然得到了目标 App 的 Documents 目录在手机中的绝对路径，那么我们就可以像上面拷贝目标 App 到 Mac 一样，将目标 App 的 Documents 目录也拷贝到 Mac 上，这里就不再累述了。</p>
<p>以上就是本文要记录的全过程了。</p>
]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向工程</tag>
        <tag>Cycript</tag>
      </tags>
  </entry>
  <entry>
    <title>我的书单</title>
    <url>/2015/06/08/my-books/</url>
    <content><![CDATA[<h1 id="感慨"><a href="#感慨" class="headerlink" title="感慨"></a>感慨</h1><p>花钱买书来提升自己的认知、技能，还有什么比这个更有价值的？<br>有！<br>买一些对自己有帮助的软件，也是很有价值的！</p>
<div class="note info"><p>注：我的 “看一遍” 和 “学一遍” 的区别，看一遍就是浏览一遍，带点自己的思考，可能印象不会很深；学一遍的话，浏览加上思考加上动手，印象会深些。</p>
</div>


<h1 id="纸质书"><a href="#纸质书" class="headerlink" title="纸质书"></a>纸质书</h1><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul>
<li>Java 编程思想 (第4版) (Thinking in Java) (看了几十页)</li>
<li>Effective Java 中文版 (第2版)</li>
<li>Java 开发实战经典 (大学的时候一个女同学送的，她不学 Java 了就送我了，学过两遍)</li>
<li>Java 学习笔记 (JDK 8)</li>
<li>写给大忙人看的 Java SE 8</li>
<li>Head First Java (中文版)(第2版)(涵盖 Java 5.0)</li>
</ul>
<h3 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C &#x2F; C++"></a>C &#x2F; C++</h3><ul>
<li>C Primer Plus (第五版) 中文版</li>
<li>C++ Primer (中文版) (第5版)</li>
<li>C 语言入门经典 (第5版)</li>
<li>C 和指针 (POINTERS ON C)</li>
<li>C 陷阱与缺陷 (C Traps and Pitfalls)</li>
<li>C 专家编程 Expert C Programming Deep C Secrets</li>
<li>C++ 编程思想 (两卷合订本)</li>
<li>C 程序设计新思维</li>
</ul>
<h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h3><ul>
<li>Objective-C 基础教程 (第二版) (学完一遍)</li>
<li>Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法 (看完一遍)</li>
<li>Cocoa 入门: 使用 Objective-C (第3版) (看完一遍)</li>
<li>Objective-C 2.0 Mac 和 iOS 开发实践指南 (原书第2版) (看完一遍)</li>
<li>Objective-C 开发范例代码大全 (看完一遍)</li>
<li>Objective-C 程序设计 (第6版) (看完一遍)</li>
</ul>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><ul>
<li>Swifter: 100个 Swift 开发必备 Tip</li>
<li>Swift 开发指南 (修订版) (辣鸡，看完一半左右，写得太差了，错误好多，看不下去了)</li>
</ul>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul>
<li>Python 开发实战</li>
<li>Python 3 面向对象编程</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul>
<li>JavaScript 基础教程 (第9版)</li>
</ul>
<h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><ul>
<li>快学 Scala</li>
</ul>
<h3 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h3><ul>
<li>Haskell 并行与并发编程</li>
</ul>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><ul>
<li>汇编语言的编程艺术 (第2版)</li>
<li>汇编语言 (第3版) (学到一半左右)</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>编程语言原理 (第10版)</li>
</ul>
<h2 id="移动开发"><a href="#移动开发" class="headerlink" title="移动开发"></a>移动开发</h2><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul>
<li>第一行代码 Android (学完一遍)</li>
<li>Android 开发入门与实战 (第二版)</li>
<li>Android 应用开发详解  (学完一遍)</li>
<li>Learning Android 中文版 (第2版)</li>
<li>疯狂 Android讲义 (第二版)</li>
<li>深入理解 Android 卷1</li>
<li>深入理解 Android 卷2</li>
<li>Android C++ 高级编程: 使用 NDK</li>
<li>Android 深度探索 (卷2) 系统应用源代码分析与 ROM 定制</li>
<li>Android 安全攻防实战</li>
<li>Android 恶意代码分析与渗透测试</li>
<li>Android 编程权威指南</li>
<li>Android 群英传</li>
<li>Android 底层接口与驱动开发技术详解</li>
<li>Android 源码分析实录</li>
</ul>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ul>
<li>精通 iOS 开发 (第六版) (学完一遍)</li>
<li>iOS 编程 (第4版) (学完一遍)</li>
<li>iOS 开发进阶 (看完一遍)</li>
<li>iOS Auto Layout 开发秘籍 (第2版) (看完一遍)</li>
<li>iOS 应用逆向工程 (第2版)</li>
<li>iOS应用逆向与安全（一次线下技术分享会找庆总签了名）</li>
<li>Core Data 应用开发实践指南</li>
<li>iOS 应用安全攻防实战</li>
<li>iOS 开发范例实战宝典 (基础篇)</li>
<li>iOS 开发范例实战宝典 (进阶篇)</li>
<li>黑客攻防技术宝典: iOS 实战篇</li>
<li>iOS 高级编程</li>
<li>iOS 8 应用开发实战: 205个快速上手的开发技巧 (看完一遍)</li>
<li>iOS 数据库应用高级编程 (第2版)</li>
<li>iOS 面试之道</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>大话移动 APP 测试: Android 与 iOS 应用测试指南</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="Linux-x2F-UNIX"><a href="#Linux-x2F-UNIX" class="headerlink" title="Linux &#x2F; UNIX"></a>Linux &#x2F; UNIX</h3><ul>
<li>鸟哥的 Linux 私房菜 基础学习篇 (第三版)</li>
<li>Linux 就是这个范儿</li>
<li>Linux &#x2F; Unix 设计思想 (看完一遍)</li>
<li>UNIX 编程艺术</li>
</ul>
<h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><ul>
<li>IDA Pro 权威指南 (第2版)</li>
</ul>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul>
<li>树莓派学习指南 (基于 Linux)</li>
</ul>
<h2 id="Web-相关"><a href="#Web-相关" class="headerlink" title="Web 相关"></a>Web 相关</h2><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li>高扩展性网站的50条原则</li>
</ul>
<h3 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul>
<li>高性能 JavaScript</li>
</ul>
<h2 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h2><h3 id="Cocos2D"><a href="#Cocos2D" class="headerlink" title="Cocos2D"></a>Cocos2D</h3><ul>
<li>我所理解的 COCOS2D-X</li>
</ul>
<h2 id="网络信息安全"><a href="#网络信息安全" class="headerlink" title="网络信息安全"></a>网络信息安全</h2><ul>
<li>白帽子讲 Web 安全 (纪念版)</li>
<li>安全技术大系: Web 前端黑客技术揭秘</li>
<li>Metasploit 渗透测试指南</li>
<li>Kali Linux &amp; BackTrack 渗透测试实战</li>
<li>Kali 渗透测试技术实战</li>
<li>SQL 注入攻击与防御 (第2版)</li>
<li>揭秘家用路由器 0day 漏洞挖掘技术</li>
<li>Python 黑帽子: 黑客与渗透测试编程之道</li>
<li>安全之路: Web 渗透技术及实战案例解析 (第2版)</li>
<li>XSS 跨站脚本攻击剖析与防御</li>
<li>黑客免杀攻防</li>
<li>入侵的艺术</li>
<li>欺骗的艺术</li>
<li>反入侵的艺术: 黑客入侵背后的真实故事</li>
<li>反欺骗的艺术: 世界传奇黑客的经历分享</li>
<li>线上幽灵 (世界头号黑客米特尼克自传)</li>
<li>黑客社会工程学攻击档案袋</li>
<li>掘金黑客</li>
<li>捉虫日记</li>
<li>黑客防线2011合订本 (下半年)</li>
<li>SEO 的艺术 (原书第2版)</li>
<li>社会工程 (卷2): 解读肢体语言 (看完一遍)</li>
<li>硬黑客: 智能硬件生死之战</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li>TCP &#x2F; IP 详解卷1: 协议</li>
<li>TCP &#x2F; IP 详解卷2: 实现</li>
<li>TCP &#x2F; IP 详解卷3: TCP 事务协议、HTTP、NNTP 和 UNIX 域协议</li>
<li>图灵程序设计丛书: 图解 TCP &#x2F; IP (第5版)</li>
<li>图灵程序设计丛书: 图解 HTTP (看完一遍)</li>
<li>图灵程序设计丛书: 图解网络硬件</li>
</ul>
<h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h2><ul>
<li>算法导论 (原书第三版)</li>
<li>算法心得 (高效算法的奥秘) (原书第二版)</li>
<li>啊哈！算法</li>
<li>大话数据结构</li>
<li>数据结构 (Java语言版)</li>
<li>算法设计与分析基础 (第3版)</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>大话数据库</li>
</ul>
<h2 id="其他信息技术书籍"><a href="#其他信息技术书籍" class="headerlink" title="其他信息技术书籍"></a>其他信息技术书籍</h2><ul>
<li>代码大全 (第2版)</li>
<li>计算机程序的构造和解释 (原书第2版)</li>
<li>计算机科学导论 (原书第3版)</li>
<li>计算机组成与设计: 硬件 &#x2F; 软件接口 (原书第5版)</li>
<li>大话设计模式</li>
<li>图灵程序设计丛书: 图解密码技术</li>
<li>解密搜索引擎技术实战 (第二版)</li>
<li>Head First 设计模式 (中文版)</li>
<li>精通正则表达式 (第3版)</li>
<li>程序员修炼之道 —— 从小工到专家</li>
<li>大教堂与集市</li>
<li>Git 权威指南</li>
<li>Git 版本控制管理 (第2版)</li>
<li>重构 改善既有代码的设计</li>
<li>程序员面试宝典 (第四版)</li>
<li>人月神话 (看完一遍)</li>
<li>软件产品结构师手记</li>
<li>人件 (原书第3版)</li>
<li>信息简史</li>
<li>MacTalk 人生元编程 (看完一遍)</li>
<li>数学与生活 (修订版)</li>
<li>图灵程序设计丛书: 程序员的数学</li>
<li>卓越程序员密码</li>
<li>程序员的数学思维修炼 (趣味解读)</li>
<li>黑客与画家: 硅谷创业之父 Paul Graham 文集 (看完一遍)</li>
<li>程序员的呐喊</li>
<li>编码: 隐匿在计算机软硬件背后的语言 (看完一遍)</li>
<li>设计原本: 计算机科学巨匠 Frederick P.Brooks 的反思 (珍藏版)</li>
<li>程序员的自我修养: 链接、装载与库</li>
<li>构建之法 现代软件工程（第三版）（看了一部分）</li>
</ul>
<h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>Oracle 数据库开发与应用 (大学的课本。。。)</li>
</ul>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul>
<li>Structs 2 + Hibernate + Spring 整合开发技术详解 (大学的课本。。。)</li>
</ul>
<h2 id="其他非技术书籍"><a href="#其他非技术书籍" class="headerlink" title="其他非技术书籍"></a>其他非技术书籍</h2><ul>
<li>让我留在你身边</li>
<li>告白与告别 (看完一遍)</li>
<li>王小波小说精编: 黄金时代 + 白银时代 + 青铜时代 (套装共3册)</li>
<li>沉默的大多数 (典藏版)</li>
<li>你的孤独, 虽败犹荣: 谁的青春不迷茫系列</li>
<li>悟空传 (完美纪念版)</li>
<li>我所理解的生活</li>
<li>老人与海 (修订版)</li>
<li>睡不着</li>
<li>I have a dream (原书名《别做梦了》)</li>
<li>No Wi-Fi</li>
</ul>
<h1 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h1><h2 id="iOS-1"><a href="#iOS-1" class="headerlink" title="iOS"></a>iOS</h2><ul>
<li>The iOS Apprentice</li>
<li>iOS Animations by Tutorials</li>
<li>Core Data by Tutorials</li>
<li>Swift by Tutorials</li>
<li>WatchKit by Tutorials</li>
<li>iOS 9 by Tutorials</li>
<li>iOS 8 by Tutorials</li>
<li>iOS 7 by Tutorials (学完一遍)</li>
<li>iOS 6 by Tutorials (挑章节学了一遍)</li>
<li>2D iOS &amp; tvOS Games by Tutorials</li>
<li>Objective-C Programming Big Nerd Ranch Guides 2nd Edition</li>
<li>Design Teardowns Pro</li>
<li>CFHipsterRef: Low-Level Programming on iOS &amp; Mac OS X (学完一遍)</li>
<li>Motion Design for iOS (学完一遍)</li>
<li>Intermediate iOS 9 Programming with Swift</li>
<li>Beginning iOS 9 Programming with Swift</li>
<li>Functional Programming in Swift</li>
<li>Advanced Swift</li>
<li>Producter - 让产品从 0 到 1</li>
<li>SWIFTER: 100 个 Swift 必备 Tips (第2版) (学完一遍)</li>
<li>A GUIDE TO IOS ANIMATION</li>
<li>Programming iOS 9</li>
<li>iOS Core Animation Advanced Techniques (iOS 核心动画高级技巧) (学完一遍)</li>
</ul>
<h2 id="Android-1"><a href="#Android-1" class="headerlink" title="Android"></a>Android</h2><ul>
<li>Android Programming</li>
</ul>
<h2 id="其他信息技术书籍-1"><a href="#其他信息技术书籍-1" class="headerlink" title="其他信息技术书籍"></a>其他信息技术书籍</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul>
<li>Pro Git (免费开源) (看完一遍)</li>
</ul>
<h2 id="其他非技术书籍-1"><a href="#其他非技术书籍-1" class="headerlink" title="其他非技术书籍"></a>其他非技术书籍</h2><ul>
<li>怦然心动 (看过一遍)</li>
<li>万万没想到：生活才是喜剧</li>
<li>程序员跳槽全攻略</li>
<li>码农故事 (看过一遍)</li>
</ul>
<h2 id="编译原理三大经典书籍（龙书-虎书-鲸书）（未购买）"><a href="#编译原理三大经典书籍（龙书-虎书-鲸书）（未购买）" class="headerlink" title="编译原理三大经典书籍（龙书 虎书 鲸书）（未购买）"></a>编译原理三大经典书籍（龙书 虎书 鲸书）（未购买）</h2><ul>
<li>龙书 (Dragon book)，英文名: Compilers: Principles, Techniques, and Tools；作者：Alfred V.Aho,Ravi Sethi,Jeffrey D.Ullman；中文名：编译原理技术和工具</li>
<li>虎书 (Tiger book)，英文名：Modern Compiler Implementation in C；作者：Andrew W.Appel, with Jens Palsberg；中文名：现代编译原理-C语言描述</li>
<li>鲸书 (Whale book)，英文名：Advanced Compiler Design and Implementation；作者：Steven S.Muchnick；中文名：高级编译器设计与实现</li>
</ul>
<h1 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h1><h2 id="iOS-2"><a href="#iOS-2" class="headerlink" title="iOS"></a>iOS</h2><ul>
<li>Learn to design an iPhone app with Sketch</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>书单</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>我购买的软件</title>
    <url>/2015/06/09/my-purchased-software/</url>
    <content><![CDATA[<h1 id="Mac-OS-X"><a href="#Mac-OS-X" class="headerlink" title="Mac OS X"></a>Mac OS X</h1><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ul>
<li><a href="http://revealapp.com/">Reveal</a>：用来查看 iOS App 的 UI 视图层次结构，一个很强大的 UI 分析工具。</li>
</ul>
<h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><ul>
<li><a href="https://www.charlesproxy.com/">Charles</a>：Charles 是在 Mac 下常用的截取网络封包的工具，在做 iOS 开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。(介绍来自<a href="https://www.infoq.com/cn/articles/network-packet-analysis-tool-charles">InfoQ</a>)</li>
</ul>
<h3 id="Reverse-Engineering-Tool"><a href="#Reverse-Engineering-Tool" class="headerlink" title="Reverse Engineering Tool"></a>Reverse Engineering Tool</h3><ul>
<li><a href="https://www.hopperapp.com/">Hopper</a>：Mac 和 Linux 上强大的反汇编工具。</li>
</ul>
<h3 id="Other-Tools"><a href="#Other-Tools" class="headerlink" title="Other Tools"></a>Other Tools</h3><ul>
<li><a href="https://www.alfredapp.com/">Alfred 2</a>：快速启动工具，当然功能不止这个，非常强大！特别是加上 Powerpack 之后。</li>
<li><a href="https://macpaw.com/cleanmymac">CleanMyMac 3</a>：Mac 上用来清除垃圾、卸载软件的软件。</li>
<li><a href="https://imtx.me/archives/1944.html">Manico</a>Manico 是一款为 OS X 设计的 App 快速启动及切换工具，它能显著提升你平常使用电脑的效率。</li>
<li><a href="https://pilotmoon.com/popclip/">PopClip</a>：在 Mac 上用鼠标选择文字后 PopClip 即会出现，可执行针对内容的特定操作，包括“拷贝”、“复制”以及其它插件操作。</li>
</ul>
<h3 id="Player"><a href="#Player" class="headerlink" title="Player"></a>Player</h3><ul>
<li><a href="https://itunes.apple.com/us/app/splayerx/id414675434?mt=12">SplayerX</a>：可以自动匹配字幕的播放器，非常棒，为了看高清的生活大爆炸买的。</li>
</ul>
<h3 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h3><ul>
<li><a href="http://happenapps.com/">Quiver</a>：The Programmer’s Notebook.</li>
<li><a href="https://zh.mweb.im/">MWeb</a>：专业的 Markdown 写作、记笔记、静态博客生成软件。</li>
</ul>
<h2 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h2><h3 id="日程管理"><a href="#日程管理" class="headerlink" title="日程管理"></a>日程管理</h3><ul>
<li><a href="https://flexibits.com/fantastical">Fantastical 2</a>：可能是 Mac 上最好用的日历</li>
</ul>
<h2 id="计划买的软件"><a href="#计划买的软件" class="headerlink" title="计划买的软件"></a>计划买的软件</h2><h3 id="Reverse-Engineering-Tool-1"><a href="#Reverse-Engineering-Tool-1" class="headerlink" title="Reverse Engineering Tool"></a>Reverse Engineering Tool</h3><ul>
<li><a href="https://www.hex-rays.com/products/ida/">IDA Pro</a>：这个应该不用多介绍了吧？就是太贵了，舍不得买。。。(老实说是现在还买不起。。。&#x3D; &#x3D;！)</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode 插件列表</title>
    <url>/2015/07/20/my-xcode-plug-in-list/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>当我第一次使用 Xcode 的时候，发现有一些功能在其他开发工具上 (比如 Android Studio) 有的，但是 Xcode 上没有，比如快捷提示模糊匹配 (就是 Fuzzy Completion)，加上 OC 方法名一看就明白是干嘛的，所以又臭又长，往往很难记住，所以模糊匹配的快捷提示就非常重要，好在有人写好这个插件了，感谢！最近在微博上看到，说 Xcode 7 自带这个功能了，又干死一个插件的节奏！开发工具搭配上插件，大大地提升了我们开发的效率。</p>
<h1 id="0x01-插件列表"><a href="#0x01-插件列表" class="headerlink" title="0x01 插件列表"></a>0x01 插件列表</h1><ol>
<li><a href="https://github.com/supermarin/Alcatraz">Alcatraz</a>：说到插件，不得不先说Alcatraz，这个就像 CocoaPods 对于 iOS 开发来说一样，管理我们安装的所有插件，也可以安装其他感兴趣的插件，非常方便。<img src="https://camo.githubusercontent.com/919efe4e1e53237df51d7010c862bd5c04fd6a70/687474703a2f2f616c63617472617a2e696f2f696d616765732f73637265656e73686f744032782e706e67"></li>
<li><a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin">FuzzyAutocomplete</a>：这个就是上面说到的那个功能，用了都说好！个人感觉有点小问题的是，输入数字也会触发 Fuzzy Completion，挺蛋疼的。<img src="https://i.loli.net/2018/11/01/5bdabbeb8c3d9.gif"></li>
<li><a href="https://github.com/kattrali/cocoapods-xcode-plugin">CocoaPods</a>：这个是 CocoaPods 在 Xcode 中的插件，省去了命令行操作，个人不常用，但是也还是安装了。<img src="https://github.com/kattrali/cocoadocs-xcode-plugin/raw/master/menu_rvm.png"></li>
<li><a href="https://github.com/holtwick/HOStringSense-for-Xcode">HOStringSense</a>：HOStringSense 可以说是大段文本利器，对于开发者而言，在输入大段文本时，如果文本中包含了各种换行和特殊字符，那是相当地头疼，但通过 HOStringSense，一切的问题都将迎刃而解。完美支持编辑正则表达式、多行文本、内联 HTML 等，还提供了极为快速的字符串长度统计反馈。<img src="https://github.com/holtwick/HOStringSense-for-Xcode/raw/master/StringDemoAnimation.gif"></li>
<li><a href="https://github.com/ksuther/KSImageNamed-Xcode">KSImageNamed</a>：填写图片文件名称的插件，当你写到[UIImage imaged:的时候，插件会把项目中的图片名称提示出来，并且还有预览功能，十分方便。<img src="https://camo.githubusercontent.com/c354bf04524df86daeabe7a6d2b9926fac790f85/68747470733a2f2f7261772e6769746875622e636f6d2f6b7375746865722f4b53496d6167654e616d65642d58636f64652f6d61737465722f73637265656e73686f742e676966"></li>
<li><a href="https://github.com/omz/ColorSense-for-Xcode">ColorSense</a>：当你用 UIColor 生成颜色时，它会把该颜色在代码右上角显示出来。<img src="https://i.loli.net/2018/11/01/5bdabc1db047a.png"></li>
<li><a href="https://github.com/rickytan/RTImageAssets">RTImageAssets</a>：自动将 @3x 的图片生成 @2x 和 @1x 的图片，或者从 @2x 生成 @3x 的图标。</li>
<li><a href="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter</a>：喵神的作品，输入 <code>///</code> 快速生成类似 Javadoc 的注释，自动识别参数返回值，非常棒！支持 OC 和 Swift。<img src="https://camo.githubusercontent.com/ca5518c9872e15b8a95b9d8c5f44bc331977d710/68747470733a2f2f7261772e6769746875622e636f6d2f6f6e65766361742f5656446f63756d656e7465722d58636f64652f6d61737465722f53637265656e53686f742e676966"></li>
<li><a href="https://github.com/neonichu/BBUDebuggerTuckAway">BBUDebuggerTuckAway</a>：在你编辑时自动隐藏下方 Debugger 窗口的插件，不用每次手动或者按快捷键去隐藏了。</li>
<li><a href="https://github.com/travisjeffery/ClangFormat-Xcode">ClangFormat</a>：格式化代码工具，能够让开发者使用 Clang 将代码格式化为 LLVM、Google、Chromium、Mozilla 或 WebKit 等格式，通过 ClangFormat，开发者不仅可以实现对代码的自动或批量格式化，还可以进行自定义配置。</li>
<li><a href="https://github.com/markohlebar/Peckham">Peckham</a>：快速生成 <code>#import</code> 语句。<img src="https://i.loli.net/2018/11/01/5bdabc03300e7.gif"></li>
<li><a href="https://github.com/qfish/XAlign">XAlign</a>：将你的代码变得整齐，处女座必备！有多种对齐方式，详情请点击链接进入 GitHub 查看。</li>
<li><a href="https://github.com/trawor/XToDo">XToDo</a>：一个注释辅助插件，可以把项目中的 TODO、FIXME 等注释列出来。<img src="https://i.loli.net/2018/11/01/5bdabc36eb98b.png"></li>
<li><a href="https://github.com/limejelly/Backlight-for-XCode">Backlight</a>：高亮正在编辑的那一行代码。<img src="https://raw.githubusercontent.com/limejelly/Backlight-for-XCode/master/screenshot.png"></li>
</ol>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Reveal 升级之后不能在手机上查看 App 的解决办法</title>
    <url>/2015/10/23/reveal-troubleshooting-0x00/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近因为 Mac OS X El Capitan 的发布，Reveal 也升级到了 1.6.x，然而之前的 1.5.x，在越狱的 iPhone 上，从 Cydia 中安装了 <a href="https://github.com/heardrwt/RevealLoader">RHRevealLoader</a>，就能够查看手机上的第三方 App，但是 1.6.x 就不行了，会提示：<code>The operation couldn&#39;t be completed. The iOS app is linked against a older version of the Reveal library. You may need to update the Reveal library i your iOS app.</code>：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdac03b7b59d.png"></p>
<p>然后我打开 Cydia 去查看插件是否有更新，可惜没有，所以我就自己找解决办法，最后我找到了这个插件的 GitHub 地址，看了一下 issues，然后就找到了 <a href="https://github.com/heardrwt/RevealLoader/issues/5">issue #5</a>，看到了解决办法：<code>replace at /Library/RHRevealLoader/libReveal.dylib</code>，亲测可行！</p>
<span id="more"></span>

<h1 id="0x01-替换"><a href="#0x01-替换" class="headerlink" title="0x01 替换"></a>0x01 替换</h1><p>看了报错信息，就可以知道，Reveal library 的版本太老了。然后我们就要将新的 library 替换手机里旧的 library，新的 library 在：<code>/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/</code> 下，名字叫：<code>libReveal.dylib</code>。</p>
<p>替换很简单，我们可以通过 <code>scp</code> 命令来实现，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib root@your-iPhone<span class="string">&#x27;s-IP-address:/Library/RHRevealLoader/libReveal.dylib</span></span><br></pre></td></tr></table></figure>

<p>需要输入一下 root 的密码，这样就 OK 啦。</p>
<h1 id="0x02-第二版更新-v2"><a href="#0x02-第二版更新-v2" class="headerlink" title="0x02 第二版更新 (v2)"></a>0x02 第二版更新 (v2)</h1><p>前一段时间，Reveal 发布了第二版，不再是 <code>libReveal.dylib</code>，而是 <code>RevealServer.framework</code>，所以真机连接再一次失效，不过按照老办法，试了一下，然而并没有效果，又试了一下将 <code>RevealServer.framework</code> 中的 <code>RevealServer</code> 单独拷贝到手机，还是没有用，结果无奈去官网寻找解决办法，结果当然是找到了！办法就是把 <code>RevealServer</code> 拷贝到手机的时候，将文件名改成 <code>libReveal.dylib</code> 就行了。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework/RevealServer root@your-iPhone<span class="string">&#x27;s-IP-address:/Library/RHRevealLoader/libReveal.dylib</span></span><br></pre></td></tr></table></figure>

<p>大功告成：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdac049eb96d.png"></p>
<p>USB 连接查看也可以了，原本的局域网 WiFi 查看还在。</p>
<p>查看第三方 App 也还是可以的：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdac057bfb91.png"></p>
<p>参考链接：<br><a href="http://support.revealapp.com/kb/getting-started/reveal-integration-guide">Reveal Integration Guide</a><br><a href="http://support.revealapp.com/discussions/questions/59651-where-is-librevealdylib-in-20-version">Where is libReveal.dylib in 2.0 version</a><br><a href="http://petersteinberger.com/blog/2013/how-to-inspect-the-view-hierarchy-of-3rd-party-apps/">How to Inspect the View Hierarchy of Third-Party Apps</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Reveal</tag>
      </tags>
  </entry>
  <entry>
    <title>UICollectionViews Now Have Easy Reordering</title>
    <url>/2015/08/08/uicollectionviews-now-have-easy-reordering/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇文章是 <a href="http://nshint.io/">NSHint</a> 上的 <a href="http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/">UICollectionViews Now Have Easy Reordering</a>。你可以直接去看英文的原文。</p>
<h1 id="0x01-正文"><a href="#0x01-正文" class="headerlink" title="0x01 正文"></a>0x01 正文</h1><p>哥是 <code>UICollectionView</code> 的头号大粉丝，它比它的老大哥 <code>UITableView</code> 更加的可定制化，现在哥经常使用 collection view 而不使用 table view。而且 iOS 9 也支持简单重排了。在这之前不太可能实现，并且要实现意味着这是一件非常痛苦的事情。让我们一起来瞧一瞧这个 API。你可以在 <a href="https://github.com/nshintio/uicollectionview-reordering">GitHub</a> 上找到这个 Xcode 项目。</p>
<p>使用 <code>UICollectionViewController</code> 是做简单重排的最简单的方法，现在，它多了一个新的属性 <code>installsStandardGestureForInteractiveMovement</code>，增加了重排 cells 的标准手势。这个属性默认为 <code>true</code>，这意味着我们只需要重载一个方法就可以完成我们想要的功能了，真是太赞了！</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">collectionView</span>(<span class="params">collectionView</span>: <span class="type">UICollectionView</span>,</span><br><span class="line">    <span class="params">moveItemAtIndexPath</span> <span class="params">sourceIndexPath</span>: <span class="type">NSIndexPath</span>,</span><br><span class="line">    <span class="params">toIndexPath</span> <span class="params">destinationIndexPath</span>: <span class="type">NSIndexPath</span>) &#123;</span><br><span class="line">    <span class="comment">// move your data order</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>moveItemAtIndexPath</code> 被重载了，所以 collection view 能推断出它的 items 能够移动。</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabe751572c.gif"></p>
<p>当我们想要在一个简单的 <code>UIViewController</code> 中使用 collection view，事情会变得非常繁琐。我们依然需要实现上述的 <code>UICollectionViewDataSource</code> 的几个方法，但是我们需要重写 <code>installsStandardGestureForInteractiveMovement</code>，不用担心，它也非常容易支持的。<code>supported.UILongPressGestureRecognizer</code> 是一个连续的手势识别，并且完全支持 panning。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    longPressGesture <span class="operator">=</span> <span class="type">UILongPressGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="string">&quot;handleLongGesture:&quot;</span>)</span><br><span class="line">    <span class="keyword">self</span>.collectionView.addGestureRecognizer(longPressGesture)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handleLongGesture</span>(<span class="params">gesture</span>: <span class="type">UILongPressGestureRecognizer</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(gesture.state) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Began</span>:</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> selectedIndexPath <span class="operator">=</span> <span class="keyword">self</span>.collectionView.indexPathForItemAtPoint(gesture.locationInView(<span class="keyword">self</span>.collectionView)) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        collectionView.beginInteractiveMovementForItemAtIndexPath(selectedIndexPath)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Changed</span>:</span><br><span class="line">        collectionView.updateInteractiveMovementTargetPosition(gesture.locationInView(gesture.view<span class="operator">!</span>))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UIGestureRecognizerState</span>.<span class="type">Ended</span>:</span><br><span class="line">        collectionView.endInteractiveMovement()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        collectionView.cancelInteractiveMovement()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们保存了在长按手势 handler 中获得的选择的 item 的下标，and depending on <strong>wether</strong> it has any value we allow to pan gesture to kick in(这里的 wether 应该是 whether 吧)。然后，我们根据手势的状态调用一些 collection view 新的方法：</p>
<ul>
<li><code>beginInteractiveMovementForItemAtIndexPath(indexPath: NSIndexPath)</code> 在特定的 index path 开始 cell 的交互移动动画</li>
<li><code>updateInteractiveMovementTargetPosition(targetPosition: CGPoint)</code> 在手势的过程中更新目标位置的交互移动动画</li>
<li><code>endInteractiveMovement()</code> 在你结束 pan 手势之后结束交互移动动画</li>
<li><code>cancelInteractiveMovement()</code> 取消交互移动动画</li>
</ul>
<p>这让处理 pan 手势显而易见。</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabe84b56b6.gif"></p>
<p>这行为和标准的 <code>UICollectionViewController</code> 是一样的。非常 cool，不过，我们可以用我们自己定制的 collection view layout 来将 collection view 的重排实现得更 cool！先来看看简单的瀑布流布局的交互移动动画。</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabe94468b4.gif"></p>
<p>嗯哼，看起来很 cool，但是如果我们不想在移动的过程中改变 cell 的大小呢？在交互移动动画的过程中，选择的 cell 的大小应该保持不变，这是可能的。<code>UICollectionViewLayout</code> 也有另外的方法来处理重排。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">invalidationContextForInteractivelyMovingItems</span>(<span class="params">targetIndexPaths</span>: [<span class="type">NSIndexPath</span>],</span><br><span class="line">    <span class="params">withTargetPosition</span> <span class="params">targetPosition</span>: <span class="type">CGPoint</span>,</span><br><span class="line">    <span class="params">previousIndexPaths</span>: [<span class="type">NSIndexPath</span>],</span><br><span class="line">    <span class="params">previousPosition</span>: <span class="type">CGPoint</span>) -&gt; <span class="type">UICollectionViewLayoutInvalidationContext</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">invalidationContextForEndingInteractiveMovementOfItemsToFinalIndexPaths</span>(<span class="params">indexPaths</span>: [<span class="type">NSIndexPath</span>],</span><br><span class="line">    <span class="params">previousIndexPaths</span>: [<span class="type">NSIndexPath</span>],</span><br><span class="line">    <span class="params">movementCancelled</span>: <span class="type">Bool</span>) -&gt; <span class="type">UICollectionViewLayoutInvalidationContext</span></span><br></pre></td></tr></table></figure>

<p>前一个方法是在目标 IndexPath 与之前的 cell 的 indexPath 的 cells 交互移动动画中被调用的，后一个方法也是类似的，但是它只在交互移动动画结束之后被调用。有了这些知识，我们就可以使用一个小技巧来实现我们的需求了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">invalidationContextForInteractivelyMovingItems</span>(<span class="params">targetIndexPaths</span>: [<span class="type">NSIndexPath</span>],</span><br><span class="line">    <span class="params">withTargetPosition</span> <span class="params">targetPosition</span>: <span class="type">CGPoint</span>,</span><br><span class="line">    <span class="params">previousIndexPaths</span>: [<span class="type">NSIndexPath</span>],</span><br><span class="line">    <span class="params">previousPosition</span>: <span class="type">CGPoint</span>) -&gt; <span class="type">UICollectionViewLayoutInvalidationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> context <span class="operator">=</span> <span class="keyword">super</span>.invalidationContextForInteractivelyMovingItems(targetIndexPaths,</span><br><span class="line">        withTargetPosition: targetPosition, previousIndexPaths: previousIndexPaths,</span><br><span class="line">        previousPosition: previousPosition)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.delegate<span class="operator">?</span>.collectionView<span class="operator">!</span>(<span class="keyword">self</span>.collectionView<span class="operator">!</span>, moveItemAtIndexPath: previousIndexPaths[<span class="number">0</span>],</span><br><span class="line">        toIndexPath: targetIndexPaths[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法非常简单粗暴，抓取当前正在移动的 cell 的之前和目标的 index path，然后调用 <code>UICollectionViewDataSource</code> 的方法来移动 items。</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabea1d6dc3.gif"></p>
<p>毫无疑问，一个 collection view 重排是一个非常神奇的 addition。UIKit 工程师们，干得漂亮！:)</p>
<p>P.S: 非常感谢 <a href="https://twitter.com/qdoug">Douglas Hill</a> 在我们的代码中提出的一些改进，谢谢你！继续保持！</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UICollectionView</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Mac 上使用 Charles 抓包</title>
    <url>/2015/07/23/use-charles-capture-package-in-mac/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在 Windows 平台上，抓包工具有 <a href="https://www.telerik.com/fiddler">Fiddler</a>，但是不能在 MacOSX 上使用，好在我们还有另外一个抓包神器：<a href="https://www.charlesproxy.com/">Charles</a>，而且是用 Java 编写的，所以是跨平台的，可能对有些人来说有一个缺点，那就是 Charles 是收费的，不过不要着急，下面会提供破解方法。</p>
<span id="more"></span>

<h1 id="0x01-安装与破解"><a href="#0x01-安装与破解" class="headerlink" title="0x01 安装与破解"></a>0x01 安装与破解</h1><p>Charles 既然是 Java 编写的，那么破解起来就挺容易的，不愿意购买的可以点击<a href="https://www.gfzj.us/tech/2015/06/24/charles-hacking.html">这里</a>查看破解教程，不过，购买的话是最好的，毕竟做开发的都不容易，支持正版，用起来也是非常舒心的。</p>
<p>安装就不多说了，很简单，只要安装了 JDK 就能运行，打开之后会弹出提示框，选择 Allow，然后界面大概就是这样子的：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabc87b6677.png"></p>
<p>一打开就开始抓包了，这些抓到的都是 Mac 端的包，可以看到，HTTP 和 HTTPS 都已经被抓到了。</p>
<h1 id="0x02-移动端抓包"><a href="#0x02-移动端抓包" class="headerlink" title="0x02 移动端抓包"></a>0x02 移动端抓包</h1><p>手机与 Mac 端必须在同一个路由器下才能实现抓包，先查看电脑的 IP：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabc98674db.png"></p>
<p>这里以 iPhone 为例，手机连接好 Wifi 之后，打开 <em><strong>Settings（设置）-&gt; Wi-Fi</strong></em> ，点击你连接的 Wi-Fi 的最右边的查看信息按钮进入详情界面，选择最下面的 <em><strong>Manual（手动）</strong></em> ， <em><strong>Server（服务器）</strong></em> 填 Mac 端的 IP， <em><strong>Port（端口）</strong></em> 填 <code>8888</code> 就行了：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabca6d028b.png"></p>
<p>如果手机上有网络请求发生，Charles 会弹出提示，我们选择 Allow 就可以了，然后在手机上打开要抓包的 App，进行网络操作，比如，这里我就打开《一个》：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabcb867d3f.png"></p>
<p>Charles 就会帮我们抓到包，通过查看网络地址，可以找到对我们真正有用的信息，因为我在 Instagram 上有关注韩寒，微博上也是，所以我对 <code>wufazhuce</code> 很眼熟，所以我就能判断这个应该是获取信息的地址：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabcca37e79.png"></p>
<p>展开之后，可以看到 Request 如下：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabcd85ffaf.png"></p>
<p>Response 如下：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabce844700.png"></p>
<p>想要知道请求的链接，我们可以选择右边的 <em>Overview</em> ：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabcf73a5c7.png"></p>
<p>我们可以将地址复制到浏览器中查看是否可以使用：</p>
<p><img src="https://i.loli.net/2018/11/01/5bdabd05ef160.png"></p>
<p>非常好！HTTP 抓包就是这样了。</p>
<div class="note warning"><p><strong>还有非常重要的一点，手机的 Wi-Fi 设置需要改回来，改成原来的 Off（关闭），不然 Mac 端关闭 Charles 之后，手机端会无法访问网络。</strong></p>
</div>


]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Charles</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>使用过的第三方服务</title>
    <url>/2016/10/05/used-third-party-services/</url>
    <content><![CDATA[<h1 id="0x00-代码托管"><a href="#0x00-代码托管" class="headerlink" title="0x00 代码托管"></a>0x00 代码托管</h1><p>团队开发项目，都会用到代码版本控制软件，比如：CVS、SVN、Git。CVS 现在基本看不到了，SVN 也少，但是还是有些公司在用。个人最喜欢的是 Git，最著名的 Git 托管网站是 <a href="https://github.com/">GitHub</a>，知名的全球程序猿同性交友网站 ( ͡° ͜ʖ ͡°)。基于 Git 的还有 <a href="https://coding.net/">Coding</a>、<a href="https://bitbucket.org/product">BitBucket</a>、<a href="https://gitlab.com/">GitLab</a>等。</p>
<ul>
<li><p>GitHub：个人使用起来最顺手的，最喜欢的，个人博客也是搭建在 GitHub 上的。要是想使用私有仓库，必须付费购买。</p>
</li>
<li><p>Coding：提供私有仓库，现在团队开发项目除了自己搭的 Git 服务，就是用 Coding 了，还不错。</p>
</li>
<li><p>BitBucket：用得不多，可能是 GitHub 用习惯了，这个用起来没那么顺手。</p>
</li>
</ul>
<h1 id="0x01-IM-即时通讯"><a href="#0x01-IM-即时通讯" class="headerlink" title="0x01 IM (即时通讯)"></a>0x01 IM (即时通讯)</h1><p>要做社交类的 App 的话，基本上都会集成 IM，要么自己搭，比如 XMPP、MQTT。也可以使用一些比较成熟的第三方提供的服务，有很多：环信、LeanCloud、阿里百川的云旺等等。</p>
<ul>
<li><p>环信：定制性比较高，但是用户信息字段很少，很多要自己塞到 ext 字段里面去，要是官方能增加昵称、头像等字段，会更好。</p>
</li>
<li><p>云旺：比较适合快速搭建的，感觉阿里百川的很多都是帮开发者做好直接调用的，的确是省时，但是想要扩展或者修改，就非常费力了。</p>
</li>
</ul>
<h1 id="0x02-存储"><a href="#0x02-存储" class="headerlink" title="0x02 存储"></a>0x02 存储</h1><p>存储的东西一般为图片，国内的话，七牛应该是首选吧。一般不会把自己应用的图片放自己服务器上，一是容量，而是速度，第三方服务基本都会有 CDN。</p>
<ul>
<li>七牛：有免费的量，但是付费的也不会很贵，速度也不错。</li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>IM</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 10 专业版激活方法（Windows 10 Professional Activation）</title>
    <url>/2019/07/18/windows-10-pro-activation/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/07/18/5d300dfa3e23994390.jpg"></p>
<span id="more"></span>

<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>初衷是因为 Mac 版的微信不能多开了，但是生活和工作是两个微信分开的，Mac 上又想两个微信都登录着，方便沟通。</p>
<p>尝试过登录网页版的微信，但是已经不支持了。后来是在 VMware 里面开虚拟机，顺便登录 QQ 和微信，但是吧，总感觉不太舒服。</p>
<p>最后是用 Parallels Desktop 来运行虚拟机，整体体验上好于 VMware，装了 Windows 10，但是要激活，试过一些密钥，激活不了，最后折腾了一下，激活成功了，遂记录一下，希望能帮到他人。</p>
<h1 id="0x01-开始"><a href="#0x01-开始" class="headerlink" title="0x01 开始"></a>0x01 开始</h1><p>首先，在左下角的搜索框中输入 <code>CMD</code>，在出现的 Command Prompt (命令提示符) 上右键，选择 Run as administrator (以管理员身份运行)，</p>
<p><img src="https://i.loli.net/2019/07/18/5d300e925d52164575.png"></p>
<p>然后输入以下命令（如果没有使用过密钥的话，这一步可以省略）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slmgr.vbs /upk</span><br></pre></td></tr></table></figure>

<p>回车运行之后，会弹窗显示 “已成功卸载了产品密钥”。</p>
<p>然后输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br></pre></td></tr></table></figure>

<p>回车运行之后，则绑定了新的密钥，会弹窗显示 “成功地安装了产品密钥…”。</p>
<p>接着输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slmgr /skms kms.xspace.in</span><br></pre></td></tr></table></figure>

<p>回车运行之后，会更改 KMS 的服务地址，弹窗显示 “密钥管理服务计算机名成功的设置为…”。</p>
<p>最后一步，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure>

<p>等待弹窗提示 “成功地激活了产品”。</p>
<p><strong>注意：如果提示失败，出错，那么可以更改一下 KMS 的服务地址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slmgr /skms zh.us.to</span><br></pre></td></tr></table></figure>

<p>然后再：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure>

<p>这样就可以了。</p>
<h1 id="0x02-结尾"><a href="#0x02-结尾" class="headerlink" title="0x02 结尾"></a>0x02 结尾</h1><p>密钥如果不可用，可以去网上找别的密钥，很多，这里就不 copy 了。</p>
<p>步骤截图：</p>
<p><img src="https://i.loli.net/2019/07/18/5d300eaa23f9d45782.png"></p>
<p>激活后的系统信息：</p>
<p><img src="https://i.loli.net/2019/07/18/5d300eb85d51069149.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
</search>
